<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>RTW Report - ToolPlaneDistance.cpp</title>
<style type="text/css"> .LN { font-style: italic; color: #888888 } </style>
<style type="text/css"> .CT { font-style: italic; color: #117755 } </style>
<style type="text/css"> .PP { font-style: bold;   color: #992211 } </style>
<style type="text/css"> .KW { font-style: bold;   color: #1122dd } </style>
<style type="text/css"> .DT { font-style: bold;   color: #112266 } </style>
<link rel="stylesheet" type="text/css" href="rtwreport.css"></link><script language="JavaScript" type="text/javascript" src="rtwreport_utils.js"></script>
<SCRIPT type="text/javascript" src="rtwannotate.js"></SCRIPT>
</head>
<body bgcolor="#eeeeee" text="#1122aa" onload="try {if (top) { if (top.rtwFileOnLoad) top.rtwFileOnLoad(window.document); else local_onload();}} catch(err) {};if (rtwannotate) {rtwannotate('StateRun_cpp_cov.xml');}">
<p>
<table border="0" cellspacing="0" cellpadding="6" width="100%" height="100%"><tr><td width="100%" valign="top" bgcolor="#ffffff">
<h4>File: <a href="../ToolPlaneDistance.cpp" target="rtwreport_document_frame" id="linkToText_plain">ToolPlaneDistance.cpp</a></h4>
<pre id="RTWcode" style="color:black;">
<a class="LN" name="1">   1</a>	<span class="CT">// ****************** ToolPlaneDistance.cpp *******************************</span>
<a class="LN" name="2">   2</a>	<span class="CT">// Generated by TwinCAT Target for MATLAB/Simulink (TE1400)</span>
<a class="LN" name="3">   3</a>	<span class="CT">// MATLAB R2017b (win64)</span>
<a class="LN" name="4">   4</a>	<span class="CT">// TwinCAT 3.1.4022</span>
<a class="LN" name="5">   5</a>	<span class="CT">// TwinCAT Target 1.2.1230</span>
<a class="LN" name="6">   6</a>	<span class="CT">// Beckhoff Automation GmbH &amp; Co. KG     (www.beckhoff.com)</span>
<a class="LN" name="7">   7</a>	<span class="CT">// *************************************************************</span>
<a class="LN" name="8">   8</a>	<span class="CT">/*
<a class="LN" name="9">   9</a>	 * ToolPlaneDistance.cpp
<a class="LN" name="10">  10</a>	 *
<a class="LN" name="11">  11</a>	 * Academic License - for use in teaching, academic research, and meeting
<a class="LN" name="12">  12</a>	 * course requirements at degree granting institutions only.  Not for
<a class="LN" name="13">  13</a>	 * government, commercial, or other organizational use.
<a class="LN" name="14">  14</a>	 *
<a class="LN" name="15">  15</a>	 * Code generation for model "ToolPlaneDistance".
<a class="LN" name="16">  16</a>	 *
<a class="LN" name="17">  17</a>	 * Model version              : 1.1507
<a class="LN" name="18">  18</a>	 * Simulink Coder version : 8.13 (R2017b) 24-Jul-2017
<a class="LN" name="19">  19</a>	 * C++ source code generated on : Wed Apr 25 10:18:36 2018
<a class="LN" name="20">  20</a>	 *
<a class="LN" name="21">  21</a>	 * Target selection: TwinCAT.tlc
<a class="LN" name="22">  22</a>	 * Note: GRT includes extra infrastructure and instrumentation for prototyping
<a class="LN" name="23">  23</a>	 * Embedded hardware selection: Intel-&gt;x86-64 (Windows64)
<a class="LN" name="24">  24</a>	 * Code generation objectives: Unspecified
<a class="LN" name="25">  25</a>	 * Validation result: Not run
<a class="LN" name="26">  26</a>	 */</span>
<a class="LN" name="27">  27</a>	
<a class="LN" name="28">  28</a>	<span class="KW">#include</span> <span class="PP">&quot;stdafx.h&quot;</span>
<a class="LN" name="29">  29</a>	<span class="KW">#include</span> <span class="PP">&quot;CToolPlaneDistance.h&quot;</span>
<a class="LN" name="30">  30</a>	<span class="KW">#include</span> <span class="PP">&quot;ToolPlaneDistance.h&quot;</span>
<a class="LN" name="31">  31</a>	<span class="KW">#include</span> <span class="PP">&quot;ToolPlaneDistance_private.h&quot;</span>
<a class="LN" name="32">  32</a>	
<a class="LN" name="33">  33</a>	void CToolPlaneDistance::ToolPlaneDistance_output (void)
<a class="LN" name="34">  34</a>	{
<a class="LN" name="35">  35</a>	  real_T pt[3];
<a class="LN" name="36">  36</a>	  real_T H_n2b2[16];
<a class="LN" name="37">  37</a>	  real_T H_n1b2[16];
<a class="LN" name="38">  38</a>	  static const int8_T b[16] = { 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 };
<a class="LN" name="39">  39</a>	
<a class="LN" name="40">  40</a>	  static const real_T b_a[16] = { 0.99997697651804751, 0.0066748605654442265,
<a class="LN" name="41">  41</a>	    -0.0012217488515357546, 0.0, -0.0066752203799496221, 0.99997767822357031,
<a class="LN" name="42">  42</a>	    -0.00029066729569189343, 0.0, 0.0012197814162613592, 0.0002988160463516084,
<a class="LN" name="43">  43</a>	    0.9999992114208226, 0.0, -3.7688459512217709, 3.3476011179532041,
<a class="LN" name="44">  44</a>	    0.973619107013598, 1.0 };
<a class="LN" name="45">  45</a>	
<a class="LN" name="46">  46</a>	  static const real_T d[3] = { -1.0820240997479491, 1.536041691521612,
<a class="LN" name="47">  47</a>	    -1.0244614487807751 };
<a class="LN" name="48">  48</a>	
<a class="LN" name="49">  49</a>	  static const real_T c_a[9] = { -0.49716724243009747, 0.86764746505320345,
<a class="LN" name="50">  50</a>	    0.0035509774996006884, 0.86764051357801664, 0.49717836120759562,
<a class="LN" name="51">  51</a>	    -0.0036900331983521608, -0.004967117124448933, 0.0012464083117572659,
<a class="LN" name="52">  52</a>	    -0.999986887020921 };
<a class="LN" name="53">  53</a>	
<a class="LN" name="54">  54</a>	  boolean_T p;
<a class="LN" name="55">  55</a>	  boolean_T p_0;
<a class="LN" name="56">  56</a>	  real_T J[9];
<a class="LN" name="57">  57</a>	  int32_T i;
<a class="LN" name="58">  58</a>	  real_T tmp[9];
<a class="LN" name="59">  59</a>	  real_T tmp_0[9];
<a class="LN" name="60">  60</a>	  real_T d_0[3];
<a class="LN" name="61">  61</a>	  int32_T i_0;
<a class="LN" name="62">  62</a>	  real_T H_n1b2_0[4];
<a class="LN" name="63">  63</a>	  real_T J_tmp;
<a class="LN" name="64">  64</a>	  real_T J_tmp_0;
<a class="LN" name="65">  65</a>	  real_T J_tmp_1;
<a class="LN" name="66">  66</a>	  real_T J_tmp_2;
<a class="LN" name="67">  67</a>	  real_T J_tmp_3;
<a class="LN" name="68">  68</a>	  real_T J_tmp_4;
<a class="LN" name="69">  69</a>	  real_T J_tmp_tmp;
<a class="LN" name="70">  70</a>	  real_T J_tmp_tmp_0;
<a class="LN" name="71">  71</a>	  real_T J_tmp_5;
<a class="LN" name="72">  72</a>	  real_T J_tmp_tmp_1;
<a class="LN" name="73">  73</a>	  real_T J_tmp_tmp_2;
<a class="LN" name="74">  74</a>	  real_T J_tmp_tmp_3;
<a class="LN" name="75">  75</a>	  real_T tmp_1;
<a class="LN" name="76">  76</a>	  real_T tmp_2;
<a class="LN" name="77">  77</a>	
<a class="LN" name="78">  78</a>	  <span class="CT">/* MATLABSystem: '&lt;S1&gt;/Forward Kinematics1' incorporates:
<a class="LN" name="79">  79</a>	   *  Constant: '&lt;S1&gt;/Constant'
<a class="LN" name="80">  80</a>	   *  Inport: '&lt;Root&gt;/q'
<a class="LN" name="81">  81</a>	   */</span>
<a class="LN" name="82">  82</a>	  p = false;
<a class="LN" name="83">  83</a>	  p_0 = true;
<a class="LN" name="84">  84</a>	  <span class="KW">if</span> (!(m_DWork.obj.dt == m_ModelParameters.L)) {
<a class="LN" name="85">  85</a>	    p_0 = false;
<a class="LN" name="86">  86</a>	  }
<a class="LN" name="87">  87</a>	
<a class="LN" name="88">  88</a>	  <span class="KW">if</span> (p_0) {
<a class="LN" name="89">  89</a>	    p = true;
<a class="LN" name="90">  90</a>	  }
<a class="LN" name="91">  91</a>	
<a class="LN" name="92">  92</a>	  <span class="KW">if</span> (!p) {
<a class="LN" name="93">  93</a>	    m_DWork.obj.dt = m_ModelParameters.L;
<a class="LN" name="94">  94</a>	  }
<a class="LN" name="95">  95</a>	
<a class="LN" name="96">  96</a>	  <span class="CT">/*  Position {b} -&gt; {t} */</span>
<a class="LN" name="97">  97</a>	  <span class="CT">/*  Obtained from formForwardModel */</span>
<a class="LN" name="98">  98</a>	  <span class="CT">/*  Velocity */</span>
<a class="LN" name="99">  99</a>	  <span class="CT">/*  Obtained from formForwardModel */</span>
<a class="LN" name="100"> 100</a>	  J_tmp = std::cos(m_Input.q[2]);
<a class="LN" name="101"> 101</a>	  J_tmp_0 = std::sin(m_Input.q[2]);
<a class="LN" name="102"> 102</a>	  J_tmp_tmp = std::sin(m_Input.q[1]);
<a class="LN" name="103"> 103</a>	  J_tmp_tmp_0 = m_DWork.obj.a3 * J_tmp;
<a class="LN" name="104"> 104</a>	  J_tmp_tmp_3 = m_DWork.obj.L * J_tmp_0;
<a class="LN" name="105"> 105</a>	  J_tmp_2 = ((m_DWork.obj.a1 - J_tmp_tmp_3) - J_tmp_tmp_0) +
<a class="LN" name="106"> 106</a>	    m_DWork.obj.a2 * J_tmp_tmp;
<a class="LN" name="107"> 107</a>	  J_tmp_4 = std::sin(m_Input.q[0]);
<a class="LN" name="108"> 108</a>	  J_tmp_5 = J_tmp_2 * -J_tmp_4;
<a class="LN" name="109"> 109</a>	  J[0] = J_tmp_5;
<a class="LN" name="110"> 110</a>	  J_tmp_1 = std::cos(m_Input.q[0]);
<a class="LN" name="111"> 111</a>	  J_tmp_3 = std::cos(m_Input.q[1]);
<a class="LN" name="112"> 112</a>	  J[3] = m_DWork.obj.a2 * J_tmp_1 * J_tmp_3;
<a class="LN" name="113"> 113</a>	  J_tmp_tmp_1 = m_DWork.obj.L * J_tmp;
<a class="LN" name="114"> 114</a>	  J_tmp_tmp_2 = m_DWork.obj.a3 * J_tmp_0;
<a class="LN" name="115"> 115</a>	  J_tmp = J_tmp_tmp_1 - J_tmp_tmp_2;
<a class="LN" name="116"> 116</a>	  J[6] = J_tmp * -J_tmp_1;
<a class="LN" name="117"> 117</a>	  J[1] = J_tmp_2 * -std::cos(m_Input.q[0]);
<a class="LN" name="118"> 118</a>	  J[4] = -m_DWork.obj.a2 * J_tmp_3 * J_tmp_4;
<a class="LN" name="119"> 119</a>	  J[7] = J_tmp * J_tmp_4;
<a class="LN" name="120"> 120</a>	  J[2] = 0.0;
<a class="LN" name="121"> 121</a>	  J[5] = -m_DWork.obj.a2 * J_tmp_tmp;
<a class="LN" name="122"> 122</a>	  J[8] = -m_DWork.obj.L * J_tmp_0 - J_tmp_tmp_0;
<a class="LN" name="123"> 123</a>	
<a class="LN" name="124"> 124</a>	  <span class="CT">/*  Acceleration */</span>
<a class="LN" name="125"> 125</a>	  <span class="CT">/*  Obtained from formForwardModel */</span>
<a class="LN" name="126"> 126</a>	  m_BlockIO.ForwardKinematics1_o1[0] = J_tmp_2 * J_tmp_1;
<a class="LN" name="127"> 127</a>	  m_BlockIO.ForwardKinematics1_o1[1] = J_tmp_5;
<a class="LN" name="128"> 128</a>	  m_BlockIO.ForwardKinematics1_o1[2] = ((J_tmp_tmp_1 +
<a class="LN" name="129"> 129</a>	    m_DWork.obj.d1) + m_DWork.obj.a2 * J_tmp_3) -
<a class="LN" name="130"> 130</a>	    J_tmp_tmp_2;
<a class="LN" name="131"> 131</a>	  J_tmp_0 = m_DWork.obj.a2 * m_ModelParameters.Constant_Value[1];
<a class="LN" name="132"> 132</a>	  J_tmp_5 = m_ModelParameters.Constant_Value[0] * J_tmp_1;
<a class="LN" name="133"> 133</a>	  J_tmp_tmp_1 = m_ModelParameters.Constant_Value[2] * J_tmp_4;
<a class="LN" name="134"> 134</a>	  tmp[0] = (J_tmp * J_tmp_tmp_1 - J_tmp_2 * J_tmp_5) - J_tmp_0 * J_tmp_3 *
<a class="LN" name="135"> 135</a>	    J_tmp_4;
<a class="LN" name="136"> 136</a>	  J_tmp_tmp_2 = J_tmp_0 * J_tmp_1;
<a class="LN" name="137"> 137</a>	  tmp[3] = -m_DWork.obj.a2 * m_ModelParameters.Constant_Value[0] *
<a class="LN" name="138"> 138</a>	    J_tmp_3 * J_tmp_4 - J_tmp_tmp_2 * J_tmp_tmp;
<a class="LN" name="139"> 139</a>	  tmp_1 = m_ModelParameters.Constant_Value[0] * J_tmp_4;
<a class="LN" name="140"> 140</a>	  tmp_2 = m_ModelParameters.Constant_Value[2] * J_tmp_1;
<a class="LN" name="141"> 141</a>	  J_tmp_tmp_0 += J_tmp_tmp_3;
<a class="LN" name="142"> 142</a>	  tmp[6] = J_tmp_tmp_0 * tmp_2 + J_tmp * tmp_1;
<a class="LN" name="143"> 143</a>	  tmp[1] = (J_tmp_2 * tmp_1 + J_tmp * tmp_2) - J_tmp_tmp_2 * J_tmp_3;
<a class="LN" name="144"> 144</a>	  tmp[4] = J_tmp_0 * J_tmp_4 * J_tmp_tmp - m_DWork.obj.a2 *
<a class="LN" name="145"> 145</a>	    m_ModelParameters.Constant_Value[0] * J_tmp_1 * J_tmp_3;
<a class="LN" name="146"> 146</a>	  tmp[7] = J_tmp * J_tmp_5 - J_tmp_tmp_0 * J_tmp_tmp_1;
<a class="LN" name="147"> 147</a>	  tmp[2] = 0.0;
<a class="LN" name="148"> 148</a>	  tmp[5] = -m_DWork.obj.a2 * m_ModelParameters.Constant_Value[1] *
<a class="LN" name="149"> 149</a>	    J_tmp_3;
<a class="LN" name="150"> 150</a>	  tmp[8] = J_tmp * -m_ModelParameters.Constant_Value[2];
<a class="LN" name="151"> 151</a>	
<a class="LN" name="152"> 152</a>	  <span class="CT">/* MATLAB Function: '&lt;S1&gt;/Tool-Plane Distance' incorporates:
<a class="LN" name="153"> 153</a>	   *  Inport: '&lt;Root&gt;/eta1'
<a class="LN" name="154"> 154</a>	   */</span>
<a class="LN" name="155"> 155</a>	  J_tmp_0 = std::cos(m_Input.eta[4]);
<a class="LN" name="156"> 156</a>	  J_tmp_5 = std::cos(m_Input.eta[5]);
<a class="LN" name="157"> 157</a>	  tmp_0[0] = J_tmp_0 * J_tmp_5;
<a class="LN" name="158"> 158</a>	  J_tmp_tmp_1 = std::sin(m_Input.eta[5]);
<a class="LN" name="159"> 159</a>	  tmp_0[3] = -J_tmp_0 * J_tmp_tmp_1;
<a class="LN" name="160"> 160</a>	  J_tmp_tmp_2 = std::sin(m_Input.eta[4]);
<a class="LN" name="161"> 161</a>	  tmp_0[6] = J_tmp_tmp_2;
<a class="LN" name="162"> 162</a>	  tmp_1 = std::cos(m_Input.eta[3]);
<a class="LN" name="163"> 163</a>	  tmp_2 = std::sin(m_Input.eta[3]);
<a class="LN" name="164"> 164</a>	  J_tmp_tmp_0 = J_tmp_5 * tmp_2;
<a class="LN" name="165"> 165</a>	  tmp_0[1] = J_tmp_tmp_0 * J_tmp_tmp_2 + tmp_1 * J_tmp_tmp_1;
<a class="LN" name="166"> 166</a>	  J_tmp_5 *= tmp_1;
<a class="LN" name="167"> 167</a>	  tmp_0[4] = J_tmp_5 - tmp_2 * J_tmp_tmp_2 * J_tmp_tmp_1;
<a class="LN" name="168"> 168</a>	  tmp_0[7] = -std::cos(m_Input.eta[4]) * tmp_2;
<a class="LN" name="169"> 169</a>	  tmp_0[2] = tmp_2 * J_tmp_tmp_1 - J_tmp_5 * J_tmp_tmp_2;
<a class="LN" name="170"> 170</a>	  tmp_0[5] = tmp_1 * J_tmp_tmp_2 * J_tmp_tmp_1 + J_tmp_tmp_0;
<a class="LN" name="171"> 171</a>	  tmp_0[8] = tmp_1 * J_tmp_0;
<a class="LN" name="172"> 172</a>	  <span class="KW">for</span> (i = 0; i &lt; 3; i++) {
<a class="LN" name="173"> 173</a>	    <span class="CT">/* MATLABSystem: '&lt;S1&gt;/Forward Kinematics1' incorporates:
<a class="LN" name="174"> 174</a>	     *  Constant: '&lt;S1&gt;/Constant'
<a class="LN" name="175"> 175</a>	     *  Constant: '&lt;S1&gt;/Constant1'
<a class="LN" name="176"> 176</a>	     */</span>
<a class="LN" name="177"> 177</a>	    m_BlockIO.ForwardKinematics1_o2[i] = 0.0;
<a class="LN" name="178"> 178</a>	    m_BlockIO.ForwardKinematics1_o2[i] += J[i] *
<a class="LN" name="179"> 179</a>	      m_ModelParameters.Constant_Value[0];
<a class="LN" name="180"> 180</a>	    m_BlockIO.ForwardKinematics1_o2[i] += J[i + 3] *
<a class="LN" name="181"> 181</a>	      m_ModelParameters.Constant_Value[1];
<a class="LN" name="182"> 182</a>	    m_BlockIO.ForwardKinematics1_o2[i] += J[i + 6] *
<a class="LN" name="183"> 183</a>	      m_ModelParameters.Constant_Value[2];
<a class="LN" name="184"> 184</a>	    m_BlockIO.ForwardKinematics1_o3[i] = (tmp[i + 6] *
<a class="LN" name="185"> 185</a>	      m_ModelParameters.Constant_Value[2] + (tmp[i + 3] *
<a class="LN" name="186"> 186</a>	      m_ModelParameters.Constant_Value[1] + tmp[i] *
<a class="LN" name="187"> 187</a>	      m_ModelParameters.Constant_Value[0])) + (J[i + 6] *
<a class="LN" name="188"> 188</a>	      m_ModelParameters.Constant1_Value[2] + (J[i + 3] *
<a class="LN" name="189"> 189</a>	      m_ModelParameters.Constant1_Value[1] + J[i] *
<a class="LN" name="190"> 190</a>	      m_ModelParameters.Constant1_Value[0]));
<a class="LN" name="191"> 191</a>	
<a class="LN" name="192"> 192</a>	    <span class="CT">/* MATLAB Function: '&lt;S1&gt;/Tool-Plane Distance' */</span>
<a class="LN" name="193"> 193</a>	    d_0[i] = ((c_a[i + 3] * m_BlockIO.ForwardKinematics1_o1[1] + c_a[i]
<a class="LN" name="194"> 194</a>	               * m_BlockIO.ForwardKinematics1_o1[0]) + c_a[i + 6] *
<a class="LN" name="195"> 195</a>	              m_BlockIO.ForwardKinematics1_o1[2]) + d[i];
<a class="LN" name="196"> 196</a>	  }
<a class="LN" name="197"> 197</a>	
<a class="LN" name="198"> 198</a>	  <span class="CT">/* MATLAB Function: '&lt;S1&gt;/Tool-Plane Distance' incorporates:
<a class="LN" name="199"> 199</a>	   *  Inport: '&lt;Root&gt;/eta1'
<a class="LN" name="200"> 200</a>	   *  Inport: '&lt;Root&gt;/eta2'
<a class="LN" name="201"> 201</a>	   *  Inport: '&lt;Root&gt;/h'
<a class="LN" name="202"> 202</a>	   */</span>
<a class="LN" name="203"> 203</a>	  <span class="KW">for</span> (i = 0; i &lt; 3; i++) {
<a class="LN" name="204"> 204</a>	    pt[i] = ((tmp_0[i + 3] * d_0[1] + tmp_0[i] * d_0[0]) + tmp_0[i + 6] * d_0[2])
<a class="LN" name="205"> 205</a>	      + m_Input.eta[i];
<a class="LN" name="206"> 206</a>	  }
<a class="LN" name="207"> 207</a>	
<a class="LN" name="208"> 208</a>	  <span class="KW">for</span> (i = 0; i &lt; 16; i++) {
<a class="LN" name="209"> 209</a>	    H_n2b2[i] = b[i];
<a class="LN" name="210"> 210</a>	  }
<a class="LN" name="211"> 211</a>	
<a class="LN" name="212"> 212</a>	  H_n2b2[12] = m_Input.eta_l[0];
<a class="LN" name="213"> 213</a>	  H_n2b2[13] = m_Input.eta_l[1];
<a class="LN" name="214"> 214</a>	  H_n2b2[14] = m_Input.eta_l[2];
<a class="LN" name="215"> 215</a>	  J_tmp = std::cos(m_Input.eta_l[4]);
<a class="LN" name="216"> 216</a>	  J_tmp_tmp = std::cos(m_Input.eta_l[5]);
<a class="LN" name="217"> 217</a>	  H_n2b2[0] = J_tmp * J_tmp_tmp;
<a class="LN" name="218"> 218</a>	  J_tmp_2 = std::sin(m_Input.eta_l[5]);
<a class="LN" name="219"> 219</a>	  H_n2b2[4] = -J_tmp * J_tmp_2;
<a class="LN" name="220"> 220</a>	  J_tmp_4 = std::sin(m_Input.eta_l[4]);
<a class="LN" name="221"> 221</a>	  H_n2b2[8] = J_tmp_4;
<a class="LN" name="222"> 222</a>	  J_tmp_1 = std::cos(m_Input.eta_l[3]);
<a class="LN" name="223"> 223</a>	  J_tmp_3 = std::sin(m_Input.eta_l[3]);
<a class="LN" name="224"> 224</a>	  J_tmp_tmp_0 = J_tmp_tmp * J_tmp_3;
<a class="LN" name="225"> 225</a>	  H_n2b2[1] = J_tmp_tmp_0 * J_tmp_4 + J_tmp_1 * J_tmp_2;
<a class="LN" name="226"> 226</a>	  J_tmp_tmp *= J_tmp_1;
<a class="LN" name="227"> 227</a>	  H_n2b2[5] = J_tmp_tmp - J_tmp_3 * J_tmp_4 * J_tmp_2;
<a class="LN" name="228"> 228</a>	  H_n2b2[9] = -std::cos(m_Input.eta_l[4]) * J_tmp_3;
<a class="LN" name="229"> 229</a>	  H_n2b2[2] = J_tmp_3 * J_tmp_2 - J_tmp_tmp * J_tmp_4;
<a class="LN" name="230"> 230</a>	  H_n2b2[6] = J_tmp_1 * J_tmp_4 * J_tmp_2 + J_tmp_tmp_0;
<a class="LN" name="231"> 231</a>	  H_n2b2[10] = J_tmp_1 * J_tmp;
<a class="LN" name="232"> 232</a>	  <span class="KW">for</span> (i = 0; i &lt; 4; i++) {
<a class="LN" name="233"> 233</a>	    <span class="KW">for</span> (i_0 = 0; i_0 &lt; 4; i_0++) {
<a class="LN" name="234"> 234</a>	      H_n1b2[i_0 + (i &lt;&lt; 2)] = 0.0;
<a class="LN" name="235"> 235</a>	      H_n1b2[i_0 + (i &lt;&lt; 2)] += H_n2b2[i &lt;&lt; 2] * b_a[i_0];
<a class="LN" name="236"> 236</a>	      H_n1b2[i_0 + (i &lt;&lt; 2)] += H_n2b2[(i &lt;&lt; 2) + 1] * b_a[i_0 + 4];
<a class="LN" name="237"> 237</a>	      H_n1b2[i_0 + (i &lt;&lt; 2)] += H_n2b2[(i &lt;&lt; 2) + 2] * b_a[i_0 + 8];
<a class="LN" name="238"> 238</a>	      H_n1b2[i_0 + (i &lt;&lt; 2)] += H_n2b2[(i &lt;&lt; 2) + 3] * b_a[i_0 + 12];
<a class="LN" name="239"> 239</a>	    }
<a class="LN" name="240"> 240</a>	  }
<a class="LN" name="241"> 241</a>	
<a class="LN" name="242"> 242</a>	  <span class="KW">for</span> (i = 0; i &lt; 4; i++) {
<a class="LN" name="243"> 243</a>	    J_tmp = H_n1b2[i + 12] + (H_n1b2[i + 8] * m_Input.h + (H_n1b2[i
<a class="LN" name="244"> 244</a>	      + 4] * 0.0 + H_n1b2[i] * 0.0));
<a class="LN" name="245"> 245</a>	    H_n1b2_0[i] = J_tmp;
<a class="LN" name="246"> 246</a>	  }
<a class="LN" name="247"> 247</a>	
<a class="LN" name="248"> 248</a>	  <span class="CT">/* Outport: '&lt;Root&gt;/d' incorporates:
<a class="LN" name="249"> 249</a>	   *  MATLAB Function: '&lt;S1&gt;/Tool-Plane Distance'
<a class="LN" name="250"> 250</a>	   */</span>
<a class="LN" name="251"> 251</a>	  m_Output.d = (((H_n1b2_0[0] - pt[0]) * H_n1b2[8] + (H_n1b2_0[1] -
<a class="LN" name="252"> 252</a>	    pt[1]) * H_n1b2[9]) + (H_n1b2_0[2] - pt[2]) * H_n1b2[10]) / (((pt[0] - pt[0])
<a class="LN" name="253"> 253</a>	    * H_n1b2[8] + (pt[1] - pt[1]) * H_n1b2[9]) + ((pt[2] + 1.0) - pt[2]) *
<a class="LN" name="254"> 254</a>	    H_n1b2[10]);
<a class="LN" name="255"> 255</a>	}
<a class="LN" name="256"> 256</a>	
<a class="LN" name="257"> 257</a>	void CToolPlaneDistance::ToolPlaneDistance_update (void)
<a class="LN" name="258"> 258</a>	{
<a class="LN" name="259"> 259</a>	  <span class="CT">/* Update absolute time for base rate */</span>
<a class="LN" name="260"> 260</a>	  <span class="CT">/* The "clockTick0" counts the number of times the code of this task has
<a class="LN" name="261"> 261</a>	   * been executed. The absolute time is the multiplication of "clockTick0"
<a class="LN" name="262"> 262</a>	   * and "Timing.stepSize0". Size of "clockTick0" ensures timer will not
<a class="LN" name="263"> 263</a>	   * overflow during the application lifespan selected.
<a class="LN" name="264"> 264</a>	   * Timer of this task consists of two 32 bit unsigned integers.
<a class="LN" name="265"> 265</a>	   * The two integers represent the low bits Timing.clockTick0 and the high bits
<a class="LN" name="266"> 266</a>	   * Timing.clockTickH0. When the low bit overflows to 0, the high bits increment.
<a class="LN" name="267"> 267</a>	   */</span>
<a class="LN" name="268"> 268</a>	  <span class="KW">if</span> (!(++(&amp;m_SimStruct)-&gt;Timing.clockTick0)) {
<a class="LN" name="269"> 269</a>	    ++(&amp;m_SimStruct)-&gt;Timing.clockTickH0;
<a class="LN" name="270"> 270</a>	  }
<a class="LN" name="271"> 271</a>	
<a class="LN" name="272"> 272</a>	  (&amp;m_SimStruct)-&gt;Timing.t[0] = (&amp;m_SimStruct)-&gt;Timing.clockTick0 *
<a class="LN" name="273"> 273</a>	    (&amp;m_SimStruct)-&gt;Timing.stepSize0 +
<a class="LN" name="274"> 274</a>	    (&amp;m_SimStruct)-&gt;Timing.clockTickH0 *
<a class="LN" name="275"> 275</a>	    (&amp;m_SimStruct)-&gt;Timing.stepSize0 * 4294967296.0;
<a class="LN" name="276"> 276</a>	}
<a class="LN" name="277"> 277</a>	
<a class="LN" name="278"> 278</a>	void CToolPlaneDistance::ToolPlaneDistance_initialize (void)
<a class="LN" name="279"> 279</a>	{
<a class="LN" name="280"> 280</a>	  <span class="CT">/* Start for MATLABSystem: '&lt;S1&gt;/Forward Kinematics1' */</span>
<a class="LN" name="281"> 281</a>	  m_DWork.obj.dt = 0.567;
<a class="LN" name="282"> 282</a>	  m_DWork.obj.a1 = 0.35;
<a class="LN" name="283"> 283</a>	  m_DWork.obj.a2 = 1.16;
<a class="LN" name="284"> 284</a>	  m_DWork.obj.a3 = 0.25;
<a class="LN" name="285"> 285</a>	  m_DWork.obj.d1 = 0.83;
<a class="LN" name="286"> 286</a>	  m_DWork.obj.d4 = 1.4922;
<a class="LN" name="287"> 287</a>	  m_DWork.obj.d6 = 0.21;
<a class="LN" name="288"> 288</a>	
<a class="LN" name="289"> 289</a>	  <span class="CT">/*  COMAUROBOT is a class providing both Matlab and */</span>
<a class="LN" name="290"> 290</a>	  <span class="CT">/*  Simulink funcitonality in terms of forward and inverse kinematic */</span>
<a class="LN" name="291"> 291</a>	  <span class="CT">/*  tranformations of the Comau SMART 5 NJ-110 3.0 industrial robot. */</span>
<a class="LN" name="292"> 292</a>	  <span class="CT">/*    */</span>
<a class="LN" name="293"> 293</a>	  <span class="CT">/*   *** DH Table - Comau Smart 5 NJ-110 3.0 *** */</span>
<a class="LN" name="294"> 294</a>	  <span class="CT">/*  --------------------------------------------------- */</span>
<a class="LN" name="295"> 295</a>	  <span class="CT">/*  | theta          | d            | alpha  | a      | */</span>
<a class="LN" name="296"> 296</a>	  <span class="CT">/*  --------------------------------------------------- */</span>
<a class="LN" name="297"> 297</a>	  <span class="CT">/*  | -q1            | d1           | a1     | pi/2   | */</span>
<a class="LN" name="298"> 298</a>	  <span class="CT">/*  | pi/2 - q2      | 0            | a2     | 0      | */</span>
<a class="LN" name="299"> 299</a>	  <span class="CT">/*  | q3 + pi/2 + q2 | 0            | a3     | pi/2   | */</span>
<a class="LN" name="300"> 300</a>	  <span class="CT">/*  | pi             | d4 + d5 + dt | 0      |-pi/2   | */</span>
<a class="LN" name="301"> 301</a>	  <span class="CT">/*  --------------------------------------------------- */</span>
<a class="LN" name="302"> 302</a>	  <span class="CT">/*  Can be changed during execution */</span>
<a class="LN" name="303"> 303</a>	  <span class="CT">/*  To wire exit point */</span>
<a class="LN" name="304"> 304</a>	  <span class="CT">/*  Can only be changes before execution starts */</span>
<a class="LN" name="305"> 305</a>	  <span class="CT">/*  Forward (true) or Inverse (false) */</span>
<a class="LN" name="306"> 306</a>	  <span class="CT">/*  Output T matrices */</span>
<a class="LN" name="307"> 307</a>	  <span class="CT">/*  Static link lengths */</span>
<a class="LN" name="308"> 308</a>	  <span class="CT">/*  {i-1} -&gt; {i} */</span>
<a class="LN" name="309"> 309</a>	  <span class="CT">/*  Simulink interface methods */</span>
<a class="LN" name="310"> 310</a>	  <span class="CT">/*  Perform one-time calculations, such as computing constants */</span>
<a class="LN" name="311"> 311</a>	  <span class="CT">/*  Inputs setup */</span>
<a class="LN" name="312"> 312</a>	  <span class="CT">/*  Outputs setup */</span>
<a class="LN" name="313"> 313</a>	  <span class="CT">/*  Forward kinematics */</span>
<a class="LN" name="314"> 314</a>	  <span class="CT">/*  Inverse kinematics */</span>
<a class="LN" name="315"> 315</a>	  <span class="CT">/*  Initialize / reset discrete-state properties */</span>
<a class="LN" name="316"> 316</a>	  <span class="CT">/*  Matlab interface methods */</span>
<a class="LN" name="317"> 317</a>	  m_DWork.obj.isInitialized = 0;
<a class="LN" name="318"> 318</a>	  m_DWork.obj.L = (m_DWork.obj.d4 +
<a class="LN" name="319"> 319</a>	    m_DWork.obj.d6) + m_DWork.obj.dt;
<a class="LN" name="320"> 320</a>	  m_DWork.objisempty = true;
<a class="LN" name="321"> 321</a>	  m_DWork.obj.dt = m_ModelParameters.L;
<a class="LN" name="322"> 322</a>	  m_DWork.obj.isInitialized = 1;
<a class="LN" name="323"> 323</a>	}
<a class="LN" name="324"> 324</a>	
<a class="LN" name="325"> 325</a>	void CToolPlaneDistance::ToolPlaneDistance_terminate (void)
<a class="LN" name="326"> 326</a>	{
<a class="LN" name="327"> 327</a>	  <span class="CT">/* Terminate for MATLABSystem: '&lt;S1&gt;/Forward Kinematics1' */</span>
<a class="LN" name="328"> 328</a>	  <span class="KW">if</span> (m_DWork.obj.isInitialized == 1) {
<a class="LN" name="329"> 329</a>	    m_DWork.obj.isInitialized = 2;
<a class="LN" name="330"> 330</a>	  }
<a class="LN" name="331"> 331</a>	
<a class="LN" name="332"> 332</a>	  <span class="CT">/* End of Terminate for MATLABSystem: '&lt;S1&gt;/Forward Kinematics1' */</span>
<a class="LN" name="333"> 333</a>	}
<a class="LN" name="334"> 334</a>	
<a class="LN" name="335"> 335</a>	void CToolPlaneDistance::MdlOutputs (int_T tid)
<a class="LN" name="336"> 336</a>	{
<a class="LN" name="337"> 337</a>	  ToolPlaneDistance_output();
<a class="LN" name="338"> 338</a>	  UNUSED_PARAMETER(tid);
<a class="LN" name="339"> 339</a>	}
<a class="LN" name="340"> 340</a>	
<a class="LN" name="341"> 341</a>	void CToolPlaneDistance::MdlUpdate (int_T tid)
<a class="LN" name="342"> 342</a>	{
<a class="LN" name="343"> 343</a>	  ToolPlaneDistance_update();
<a class="LN" name="344"> 344</a>	  UNUSED_PARAMETER(tid);
<a class="LN" name="345"> 345</a>	}
<a class="LN" name="346"> 346</a>	
<a class="LN" name="347"> 347</a>	void CToolPlaneDistance::MdlInitializeSizes (void)
<a class="LN" name="348"> 348</a>	{
<a class="LN" name="349"> 349</a>	}
<a class="LN" name="350"> 350</a>	
<a class="LN" name="351"> 351</a>	void CToolPlaneDistance::MdlInitializeSampleTimes (void)
<a class="LN" name="352"> 352</a>	{
<a class="LN" name="353"> 353</a>	}
<a class="LN" name="354"> 354</a>	
<a class="LN" name="355"> 355</a>	void CToolPlaneDistance::MdlInitialize (void)
<a class="LN" name="356"> 356</a>	{
<a class="LN" name="357"> 357</a>	}
<a class="LN" name="358"> 358</a>	
<a class="LN" name="359"> 359</a>	void CToolPlaneDistance::MdlStart (void)
<a class="LN" name="360"> 360</a>	{
<a class="LN" name="361"> 361</a>	  ToolPlaneDistance_initialize();
<a class="LN" name="362"> 362</a>	}
<a class="LN" name="363"> 363</a>	
<a class="LN" name="364"> 364</a>	void CToolPlaneDistance::MdlTerminate (void)
<a class="LN" name="365"> 365</a>	{
<a class="LN" name="366"> 366</a>	  ToolPlaneDistance_terminate();
<a class="LN" name="367"> 367</a>	}
<a class="LN" name="368"> 368</a>	
<a class="LN" name="369"> 369</a>	RT_MODEL_ToolPlaneDistance_T* CToolPlaneDistance::ToolPlaneDistance (void)
<a class="LN" name="370"> 370</a>	{
<a class="LN" name="371"> 371</a>	  <span class="CT">/* Registration code */</span>
<a class="LN" name="372"> 372</a>	
<a class="LN" name="373"> 373</a>	  <span class="CT">/* initialize non-finites */</span>
<a class="LN" name="374"> 374</a>	  rt_InitInfAndNaN(sizeof(real_T));
<a class="LN" name="375"> 375</a>	
<a class="LN" name="376"> 376</a>	  <span class="CT">/* initialize real-time model */</span>
<a class="LN" name="377"> 377</a>	
<a class="LN" name="378"> 378</a>	
<a class="LN" name="379"> 379</a>	
<a class="LN" name="380"> 380</a>	  <span class="CT">/* Initialize timing info */</span>
<a class="LN" name="381"> 381</a>	  {
<a class="LN" name="382"> 382</a>	    int_T *mdlTsMap = (&amp;m_SimStruct)-&gt;Timing.sampleTimeTaskIDArray;
<a class="LN" name="383"> 383</a>	    mdlTsMap[0] = 0;
<a class="LN" name="384"> 384</a>	    (&amp;m_SimStruct)-&gt;Timing.sampleTimeTaskIDPtr = (&amp;mdlTsMap[0]);
<a class="LN" name="385"> 385</a>	    (&amp;m_SimStruct)-&gt;Timing.sampleTimes =
<a class="LN" name="386"> 386</a>	      (&amp;(&amp;m_SimStruct)-&gt;Timing.sampleTimesArray[0]);
<a class="LN" name="387"> 387</a>	    (&amp;m_SimStruct)-&gt;Timing.offsetTimes =
<a class="LN" name="388"> 388</a>	      (&amp;(&amp;m_SimStruct)-&gt;Timing.offsetTimesArray[0]);
<a class="LN" name="389"> 389</a>	
<a class="LN" name="390"> 390</a>	    <span class="CT">/* task periods */</span>
<a class="LN" name="391"> 391</a>	    (&amp;m_SimStruct)-&gt;Timing.sampleTimes[0] = (0.005);
<a class="LN" name="392"> 392</a>	
<a class="LN" name="393"> 393</a>	    <span class="CT">/* task offsets */</span>
<a class="LN" name="394"> 394</a>	    (&amp;m_SimStruct)-&gt;Timing.offsetTimes[0] = (0.0);
<a class="LN" name="395"> 395</a>	  }
<a class="LN" name="396"> 396</a>	
<a class="LN" name="397"> 397</a>	  rtmSetTPtr((&amp;m_SimStruct), &amp;(&amp;m_SimStruct)-&gt;Timing.tArray[0]);
<a class="LN" name="398"> 398</a>	
<a class="LN" name="399"> 399</a>	  {
<a class="LN" name="400"> 400</a>	    int_T *mdlSampleHits = (&amp;m_SimStruct)-&gt;Timing.sampleHitArray;
<a class="LN" name="401"> 401</a>	    mdlSampleHits[0] = 1;
<a class="LN" name="402"> 402</a>	    (&amp;m_SimStruct)-&gt;Timing.sampleHits = (&amp;mdlSampleHits[0]);
<a class="LN" name="403"> 403</a>	  }
<a class="LN" name="404"> 404</a>	
<a class="LN" name="405"> 405</a>	  rtmSetTFinal((&amp;m_SimStruct), 300.0);
<a class="LN" name="406"> 406</a>	  (&amp;m_SimStruct)-&gt;Timing.stepSize0 = 0.005;
<a class="LN" name="407"> 407</a>	  (&amp;m_SimStruct)-&gt;solverInfoPtr = (&amp;(&amp;m_SimStruct)-&gt;solverInfo);
<a class="LN" name="408"> 408</a>	  (&amp;m_SimStruct)-&gt;Timing.stepSize = (0.005);
<a class="LN" name="409"> 409</a>	  rtsiSetFixedStepSize(&amp;(&amp;m_SimStruct)-&gt;solverInfo, 0.005);
<a class="LN" name="410"> 410</a>	  rtsiSetSolverMode(&amp;(&amp;m_SimStruct)-&gt;solverInfo, SOLVER_MODE_SINGLETASKING);
<a class="LN" name="411"> 411</a>	
<a class="LN" name="412"> 412</a>	  <span class="CT">/* block I/O */</span>
<a class="LN" name="413"> 413</a>	  (&amp;m_SimStruct)-&gt;blockIO = ((void *) &amp;m_BlockIO);
<a class="LN" name="414"> 414</a>	
<a class="LN" name="415"> 415</a>	
<a class="LN" name="416"> 416</a>	
<a class="LN" name="417"> 417</a>	  <span class="CT">/* parameters */</span>
<a class="LN" name="418"> 418</a>	  (&amp;m_SimStruct)-&gt;defaultParam = ((real_T *)&amp;m_ModelParameters);
<a class="LN" name="419"> 419</a>	
<a class="LN" name="420"> 420</a>	  <span class="CT">/* states (dwork) */</span>
<a class="LN" name="421"> 421</a>	  (&amp;m_SimStruct)-&gt;dwork = ((void *) &amp;m_DWork);
<a class="LN" name="422"> 422</a>	
<a class="LN" name="423"> 423</a>	
<a class="LN" name="424"> 424</a>	
<a class="LN" name="425"> 425</a>	  <span class="CT">/* external inputs */</span>
<a class="LN" name="426"> 426</a>	  (&amp;m_SimStruct)-&gt;inputs = (((void*)&amp;m_Input));
<a class="LN" name="427"> 427</a>	
<a class="LN" name="428"> 428</a>	
<a class="LN" name="429"> 429</a>	  <span class="CT">/* external outputs */</span>
<a class="LN" name="430"> 430</a>	  (&amp;m_SimStruct)-&gt;outputs = (&amp;m_Output);
<a class="LN" name="431"> 431</a>	  m_Output.d = 0.0;
<a class="LN" name="432"> 432</a>	
<a class="LN" name="433"> 433</a>	  <span class="CT">/* Initialize Sizes */</span>
<a class="LN" name="434"> 434</a>	  (&amp;m_SimStruct)-&gt;Sizes.numContStates = (0);<span class="CT">/* Number of continuous states */</span>
<a class="LN" name="435"> 435</a>	  (&amp;m_SimStruct)-&gt;Sizes.numY = (1);<span class="CT">/* Number of model outputs */</span>
<a class="LN" name="436"> 436</a>	  (&amp;m_SimStruct)-&gt;Sizes.numU = (16);<span class="CT">/* Number of model inputs */</span>
<a class="LN" name="437"> 437</a>	  (&amp;m_SimStruct)-&gt;Sizes.sysDirFeedThru = (1);<span class="CT">/* The model is direct feedthrough */</span>
<a class="LN" name="438"> 438</a>	  (&amp;m_SimStruct)-&gt;Sizes.numSampTimes = (1);<span class="CT">/* Number of sample times */</span>
<a class="LN" name="439"> 439</a>	  (&amp;m_SimStruct)-&gt;Sizes.numBlocks = (7);<span class="CT">/* Number of blocks */</span>
<a class="LN" name="440"> 440</a>	  (&amp;m_SimStruct)-&gt;Sizes.numBlockIO = (4);<span class="CT">/* Number of block outputs */</span>
<a class="LN" name="441"> 441</a>	  (&amp;m_SimStruct)-&gt;Sizes.numBlockPrms = (7);<span class="CT">/* Sum of parameter "widths" */</span>
<a class="LN" name="442"> 442</a>	  return (&amp;m_SimStruct);
<a class="LN" name="443"> 443</a>	}
<a class="LN" name="444"> 444</a>	</pre>
</td></tr></table>
</p>
</body>
</html>
