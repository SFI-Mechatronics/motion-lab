// ****************** ToolPlaneDistance.cpp *******************************
// Generated by TwinCAT Target for MATLAB/Simulink (TE1400)
// MATLAB R2017b (win64)
// TwinCAT 3.1.4022
// TwinCAT Target 1.2.1230
// Beckhoff Automation GmbH & Co. KG     (www.beckhoff.com)
// *************************************************************
/*
 * ToolPlaneDistance.cpp
 *
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 *
 * Code generation for model "ToolPlaneDistance".
 *
 * Model version              : 1.1507
 * Simulink Coder version : 8.13 (R2017b) 24-Jul-2017
 * C++ source code generated on : Wed Apr 25 10:18:36 2018
 *
 * Target selection: TwinCAT.tlc
 * Note: GRT includes extra infrastructure and instrumentation for prototyping
 * Embedded hardware selection: Intel->x86-64 (Windows64)
 * Code generation objectives: Unspecified
 * Validation result: Not run
 */

#include "stdafx.h"
#include "CToolPlaneDistance.h"
#include "ToolPlaneDistance.h"
#include "ToolPlaneDistance_private.h"

void CToolPlaneDistance::ToolPlaneDistance_output (void)
{
  real_T pt[3];
  real_T H_n2b2[16];
  real_T H_n1b2[16];
  static const int8_T b[16] = { 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 };

  static const real_T b_a[16] = { 0.99997697651804751, 0.0066748605654442265,
    -0.0012217488515357546, 0.0, -0.0066752203799496221, 0.99997767822357031,
    -0.00029066729569189343, 0.0, 0.0012197814162613592, 0.0002988160463516084,
    0.9999992114208226, 0.0, -3.7688459512217709, 3.3476011179532041,
    0.973619107013598, 1.0 };

  static const real_T d[3] = { -1.0820240997479491, 1.536041691521612,
    -1.0244614487807751 };

  static const real_T c_a[9] = { -0.49716724243009747, 0.86764746505320345,
    0.0035509774996006884, 0.86764051357801664, 0.49717836120759562,
    -0.0036900331983521608, -0.004967117124448933, 0.0012464083117572659,
    -0.999986887020921 };

  boolean_T p;
  boolean_T p_0;
  real_T J[9];
  int32_T i;
  real_T tmp[9];
  real_T tmp_0[9];
  real_T d_0[3];
  int32_T i_0;
  real_T H_n1b2_0[4];
  real_T J_tmp;
  real_T J_tmp_0;
  real_T J_tmp_1;
  real_T J_tmp_2;
  real_T J_tmp_3;
  real_T J_tmp_4;
  real_T J_tmp_tmp;
  real_T J_tmp_tmp_0;
  real_T J_tmp_5;
  real_T J_tmp_tmp_1;
  real_T J_tmp_tmp_2;
  real_T J_tmp_tmp_3;
  real_T tmp_1;
  real_T tmp_2;

  /* MATLABSystem: '<S1>/Forward Kinematics1' incorporates:
   *  Constant: '<S1>/Constant'
   *  Inport: '<Root>/q'
   */
  p = false;
  p_0 = true;
  if (!(m_DWork.obj.dt == m_ModelParameters.L)) {
    p_0 = false;
  }

  if (p_0) {
    p = true;
  }

  if (!p) {
    m_DWork.obj.dt = m_ModelParameters.L;
  }

  /*  Position {b} -> {t} */
  /*  Obtained from formForwardModel */
  /*  Velocity */
  /*  Obtained from formForwardModel */
  J_tmp = std::cos(m_Input.q[2]);
  J_tmp_0 = std::sin(m_Input.q[2]);
  J_tmp_tmp = std::sin(m_Input.q[1]);
  J_tmp_tmp_0 = m_DWork.obj.a3 * J_tmp;
  J_tmp_tmp_3 = m_DWork.obj.L * J_tmp_0;
  J_tmp_2 = ((m_DWork.obj.a1 - J_tmp_tmp_3) - J_tmp_tmp_0) +
    m_DWork.obj.a2 * J_tmp_tmp;
  J_tmp_4 = std::sin(m_Input.q[0]);
  J_tmp_5 = J_tmp_2 * -J_tmp_4;
  J[0] = J_tmp_5;
  J_tmp_1 = std::cos(m_Input.q[0]);
  J_tmp_3 = std::cos(m_Input.q[1]);
  J[3] = m_DWork.obj.a2 * J_tmp_1 * J_tmp_3;
  J_tmp_tmp_1 = m_DWork.obj.L * J_tmp;
  J_tmp_tmp_2 = m_DWork.obj.a3 * J_tmp_0;
  J_tmp = J_tmp_tmp_1 - J_tmp_tmp_2;
  J[6] = J_tmp * -J_tmp_1;
  J[1] = J_tmp_2 * -std::cos(m_Input.q[0]);
  J[4] = -m_DWork.obj.a2 * J_tmp_3 * J_tmp_4;
  J[7] = J_tmp * J_tmp_4;
  J[2] = 0.0;
  J[5] = -m_DWork.obj.a2 * J_tmp_tmp;
  J[8] = -m_DWork.obj.L * J_tmp_0 - J_tmp_tmp_0;

  /*  Acceleration */
  /*  Obtained from formForwardModel */
  m_BlockIO.ForwardKinematics1_o1[0] = J_tmp_2 * J_tmp_1;
  m_BlockIO.ForwardKinematics1_o1[1] = J_tmp_5;
  m_BlockIO.ForwardKinematics1_o1[2] = ((J_tmp_tmp_1 +
    m_DWork.obj.d1) + m_DWork.obj.a2 * J_tmp_3) -
    J_tmp_tmp_2;
  J_tmp_0 = m_DWork.obj.a2 * m_ModelParameters.Constant_Value[1];
  J_tmp_5 = m_ModelParameters.Constant_Value[0] * J_tmp_1;
  J_tmp_tmp_1 = m_ModelParameters.Constant_Value[2] * J_tmp_4;
  tmp[0] = (J_tmp * J_tmp_tmp_1 - J_tmp_2 * J_tmp_5) - J_tmp_0 * J_tmp_3 *
    J_tmp_4;
  J_tmp_tmp_2 = J_tmp_0 * J_tmp_1;
  tmp[3] = -m_DWork.obj.a2 * m_ModelParameters.Constant_Value[0] *
    J_tmp_3 * J_tmp_4 - J_tmp_tmp_2 * J_tmp_tmp;
  tmp_1 = m_ModelParameters.Constant_Value[0] * J_tmp_4;
  tmp_2 = m_ModelParameters.Constant_Value[2] * J_tmp_1;
  J_tmp_tmp_0 += J_tmp_tmp_3;
  tmp[6] = J_tmp_tmp_0 * tmp_2 + J_tmp * tmp_1;
  tmp[1] = (J_tmp_2 * tmp_1 + J_tmp * tmp_2) - J_tmp_tmp_2 * J_tmp_3;
  tmp[4] = J_tmp_0 * J_tmp_4 * J_tmp_tmp - m_DWork.obj.a2 *
    m_ModelParameters.Constant_Value[0] * J_tmp_1 * J_tmp_3;
  tmp[7] = J_tmp * J_tmp_5 - J_tmp_tmp_0 * J_tmp_tmp_1;
  tmp[2] = 0.0;
  tmp[5] = -m_DWork.obj.a2 * m_ModelParameters.Constant_Value[1] *
    J_tmp_3;
  tmp[8] = J_tmp * -m_ModelParameters.Constant_Value[2];

  /* MATLAB Function: '<S1>/Tool-Plane Distance' incorporates:
   *  Inport: '<Root>/eta1'
   */
  J_tmp_0 = std::cos(m_Input.eta[4]);
  J_tmp_5 = std::cos(m_Input.eta[5]);
  tmp_0[0] = J_tmp_0 * J_tmp_5;
  J_tmp_tmp_1 = std::sin(m_Input.eta[5]);
  tmp_0[3] = -J_tmp_0 * J_tmp_tmp_1;
  J_tmp_tmp_2 = std::sin(m_Input.eta[4]);
  tmp_0[6] = J_tmp_tmp_2;
  tmp_1 = std::cos(m_Input.eta[3]);
  tmp_2 = std::sin(m_Input.eta[3]);
  J_tmp_tmp_0 = J_tmp_5 * tmp_2;
  tmp_0[1] = J_tmp_tmp_0 * J_tmp_tmp_2 + tmp_1 * J_tmp_tmp_1;
  J_tmp_5 *= tmp_1;
  tmp_0[4] = J_tmp_5 - tmp_2 * J_tmp_tmp_2 * J_tmp_tmp_1;
  tmp_0[7] = -std::cos(m_Input.eta[4]) * tmp_2;
  tmp_0[2] = tmp_2 * J_tmp_tmp_1 - J_tmp_5 * J_tmp_tmp_2;
  tmp_0[5] = tmp_1 * J_tmp_tmp_2 * J_tmp_tmp_1 + J_tmp_tmp_0;
  tmp_0[8] = tmp_1 * J_tmp_0;
  for (i = 0; i < 3; i++) {
    /* MATLABSystem: '<S1>/Forward Kinematics1' incorporates:
     *  Constant: '<S1>/Constant'
     *  Constant: '<S1>/Constant1'
     */
    m_BlockIO.ForwardKinematics1_o2[i] = 0.0;
    m_BlockIO.ForwardKinematics1_o2[i] += J[i] *
      m_ModelParameters.Constant_Value[0];
    m_BlockIO.ForwardKinematics1_o2[i] += J[i + 3] *
      m_ModelParameters.Constant_Value[1];
    m_BlockIO.ForwardKinematics1_o2[i] += J[i + 6] *
      m_ModelParameters.Constant_Value[2];
    m_BlockIO.ForwardKinematics1_o3[i] = (tmp[i + 6] *
      m_ModelParameters.Constant_Value[2] + (tmp[i + 3] *
      m_ModelParameters.Constant_Value[1] + tmp[i] *
      m_ModelParameters.Constant_Value[0])) + (J[i + 6] *
      m_ModelParameters.Constant1_Value[2] + (J[i + 3] *
      m_ModelParameters.Constant1_Value[1] + J[i] *
      m_ModelParameters.Constant1_Value[0]));

    /* MATLAB Function: '<S1>/Tool-Plane Distance' */
    d_0[i] = ((c_a[i + 3] * m_BlockIO.ForwardKinematics1_o1[1] + c_a[i]
               * m_BlockIO.ForwardKinematics1_o1[0]) + c_a[i + 6] *
              m_BlockIO.ForwardKinematics1_o1[2]) + d[i];
  }

  /* MATLAB Function: '<S1>/Tool-Plane Distance' incorporates:
   *  Inport: '<Root>/eta1'
   *  Inport: '<Root>/eta2'
   *  Inport: '<Root>/h'
   */
  for (i = 0; i < 3; i++) {
    pt[i] = ((tmp_0[i + 3] * d_0[1] + tmp_0[i] * d_0[0]) + tmp_0[i + 6] * d_0[2])
      + m_Input.eta[i];
  }

  for (i = 0; i < 16; i++) {
    H_n2b2[i] = b[i];
  }

  H_n2b2[12] = m_Input.eta_l[0];
  H_n2b2[13] = m_Input.eta_l[1];
  H_n2b2[14] = m_Input.eta_l[2];
  J_tmp = std::cos(m_Input.eta_l[4]);
  J_tmp_tmp = std::cos(m_Input.eta_l[5]);
  H_n2b2[0] = J_tmp * J_tmp_tmp;
  J_tmp_2 = std::sin(m_Input.eta_l[5]);
  H_n2b2[4] = -J_tmp * J_tmp_2;
  J_tmp_4 = std::sin(m_Input.eta_l[4]);
  H_n2b2[8] = J_tmp_4;
  J_tmp_1 = std::cos(m_Input.eta_l[3]);
  J_tmp_3 = std::sin(m_Input.eta_l[3]);
  J_tmp_tmp_0 = J_tmp_tmp * J_tmp_3;
  H_n2b2[1] = J_tmp_tmp_0 * J_tmp_4 + J_tmp_1 * J_tmp_2;
  J_tmp_tmp *= J_tmp_1;
  H_n2b2[5] = J_tmp_tmp - J_tmp_3 * J_tmp_4 * J_tmp_2;
  H_n2b2[9] = -std::cos(m_Input.eta_l[4]) * J_tmp_3;
  H_n2b2[2] = J_tmp_3 * J_tmp_2 - J_tmp_tmp * J_tmp_4;
  H_n2b2[6] = J_tmp_1 * J_tmp_4 * J_tmp_2 + J_tmp_tmp_0;
  H_n2b2[10] = J_tmp_1 * J_tmp;
  for (i = 0; i < 4; i++) {
    for (i_0 = 0; i_0 < 4; i_0++) {
      H_n1b2[i_0 + (i << 2)] = 0.0;
      H_n1b2[i_0 + (i << 2)] += H_n2b2[i << 2] * b_a[i_0];
      H_n1b2[i_0 + (i << 2)] += H_n2b2[(i << 2) + 1] * b_a[i_0 + 4];
      H_n1b2[i_0 + (i << 2)] += H_n2b2[(i << 2) + 2] * b_a[i_0 + 8];
      H_n1b2[i_0 + (i << 2)] += H_n2b2[(i << 2) + 3] * b_a[i_0 + 12];
    }
  }

  for (i = 0; i < 4; i++) {
    J_tmp = H_n1b2[i + 12] + (H_n1b2[i + 8] * m_Input.h + (H_n1b2[i
      + 4] * 0.0 + H_n1b2[i] * 0.0));
    H_n1b2_0[i] = J_tmp;
  }

  /* Outport: '<Root>/d' incorporates:
   *  MATLAB Function: '<S1>/Tool-Plane Distance'
   */
  m_Output.d = (((H_n1b2_0[0] - pt[0]) * H_n1b2[8] + (H_n1b2_0[1] -
    pt[1]) * H_n1b2[9]) + (H_n1b2_0[2] - pt[2]) * H_n1b2[10]) / (((pt[0] - pt[0])
    * H_n1b2[8] + (pt[1] - pt[1]) * H_n1b2[9]) + ((pt[2] + 1.0) - pt[2]) *
    H_n1b2[10]);
}

void CToolPlaneDistance::ToolPlaneDistance_update (void)
{
  /* Update absolute time for base rate */
  /* The "clockTick0" counts the number of times the code of this task has
   * been executed. The absolute time is the multiplication of "clockTick0"
   * and "Timing.stepSize0". Size of "clockTick0" ensures timer will not
   * overflow during the application lifespan selected.
   * Timer of this task consists of two 32 bit unsigned integers.
   * The two integers represent the low bits Timing.clockTick0 and the high bits
   * Timing.clockTickH0. When the low bit overflows to 0, the high bits increment.
   */
  if (!(++(&m_SimStruct)->Timing.clockTick0)) {
    ++(&m_SimStruct)->Timing.clockTickH0;
  }

  (&m_SimStruct)->Timing.t[0] = (&m_SimStruct)->Timing.clockTick0 *
    (&m_SimStruct)->Timing.stepSize0 +
    (&m_SimStruct)->Timing.clockTickH0 *
    (&m_SimStruct)->Timing.stepSize0 * 4294967296.0;
}

void CToolPlaneDistance::ToolPlaneDistance_initialize (void)
{
  /* Start for MATLABSystem: '<S1>/Forward Kinematics1' */
  m_DWork.obj.dt = 0.567;
  m_DWork.obj.a1 = 0.35;
  m_DWork.obj.a2 = 1.16;
  m_DWork.obj.a3 = 0.25;
  m_DWork.obj.d1 = 0.83;
  m_DWork.obj.d4 = 1.4922;
  m_DWork.obj.d6 = 0.21;

  /*  COMAUROBOT is a class providing both Matlab and */
  /*  Simulink funcitonality in terms of forward and inverse kinematic */
  /*  tranformations of the Comau SMART 5 NJ-110 3.0 industrial robot. */
  /*    */
  /*   *** DH Table - Comau Smart 5 NJ-110 3.0 *** */
  /*  --------------------------------------------------- */
  /*  | theta          | d            | alpha  | a      | */
  /*  --------------------------------------------------- */
  /*  | -q1            | d1           | a1     | pi/2   | */
  /*  | pi/2 - q2      | 0            | a2     | 0      | */
  /*  | q3 + pi/2 + q2 | 0            | a3     | pi/2   | */
  /*  | pi             | d4 + d5 + dt | 0      |-pi/2   | */
  /*  --------------------------------------------------- */
  /*  Can be changed during execution */
  /*  To wire exit point */
  /*  Can only be changes before execution starts */
  /*  Forward (true) or Inverse (false) */
  /*  Output T matrices */
  /*  Static link lengths */
  /*  {i-1} -> {i} */
  /*  Simulink interface methods */
  /*  Perform one-time calculations, such as computing constants */
  /*  Inputs setup */
  /*  Outputs setup */
  /*  Forward kinematics */
  /*  Inverse kinematics */
  /*  Initialize / reset discrete-state properties */
  /*  Matlab interface methods */
  m_DWork.obj.isInitialized = 0;
  m_DWork.obj.L = (m_DWork.obj.d4 +
    m_DWork.obj.d6) + m_DWork.obj.dt;
  m_DWork.objisempty = true;
  m_DWork.obj.dt = m_ModelParameters.L;
  m_DWork.obj.isInitialized = 1;
}

void CToolPlaneDistance::ToolPlaneDistance_terminate (void)
{
  /* Terminate for MATLABSystem: '<S1>/Forward Kinematics1' */
  if (m_DWork.obj.isInitialized == 1) {
    m_DWork.obj.isInitialized = 2;
  }

  /* End of Terminate for MATLABSystem: '<S1>/Forward Kinematics1' */
}

void CToolPlaneDistance::MdlOutputs (int_T tid)
{
  ToolPlaneDistance_output();
  UNUSED_PARAMETER(tid);
}

void CToolPlaneDistance::MdlUpdate (int_T tid)
{
  ToolPlaneDistance_update();
  UNUSED_PARAMETER(tid);
}

void CToolPlaneDistance::MdlInitializeSizes (void)
{
}

void CToolPlaneDistance::MdlInitializeSampleTimes (void)
{
}

void CToolPlaneDistance::MdlInitialize (void)
{
}

void CToolPlaneDistance::MdlStart (void)
{
  ToolPlaneDistance_initialize();
}

void CToolPlaneDistance::MdlTerminate (void)
{
  ToolPlaneDistance_terminate();
}

RT_MODEL_ToolPlaneDistance_T* CToolPlaneDistance::ToolPlaneDistance (void)
{
  /* Registration code */

  /* initialize non-finites */
  rt_InitInfAndNaN(sizeof(real_T));

  /* initialize real-time model */



  /* Initialize timing info */
  {
    int_T *mdlTsMap = (&m_SimStruct)->Timing.sampleTimeTaskIDArray;
    mdlTsMap[0] = 0;
    (&m_SimStruct)->Timing.sampleTimeTaskIDPtr = (&mdlTsMap[0]);
    (&m_SimStruct)->Timing.sampleTimes =
      (&(&m_SimStruct)->Timing.sampleTimesArray[0]);
    (&m_SimStruct)->Timing.offsetTimes =
      (&(&m_SimStruct)->Timing.offsetTimesArray[0]);

    /* task periods */
    (&m_SimStruct)->Timing.sampleTimes[0] = (0.005);

    /* task offsets */
    (&m_SimStruct)->Timing.offsetTimes[0] = (0.0);
  }

  rtmSetTPtr((&m_SimStruct), &(&m_SimStruct)->Timing.tArray[0]);

  {
    int_T *mdlSampleHits = (&m_SimStruct)->Timing.sampleHitArray;
    mdlSampleHits[0] = 1;
    (&m_SimStruct)->Timing.sampleHits = (&mdlSampleHits[0]);
  }

  rtmSetTFinal((&m_SimStruct), 300.0);
  (&m_SimStruct)->Timing.stepSize0 = 0.005;
  (&m_SimStruct)->solverInfoPtr = (&(&m_SimStruct)->solverInfo);
  (&m_SimStruct)->Timing.stepSize = (0.005);
  rtsiSetFixedStepSize(&(&m_SimStruct)->solverInfo, 0.005);
  rtsiSetSolverMode(&(&m_SimStruct)->solverInfo, SOLVER_MODE_SINGLETASKING);

  /* block I/O */
  (&m_SimStruct)->blockIO = ((void *) &m_BlockIO);



  /* parameters */
  (&m_SimStruct)->defaultParam = ((real_T *)&m_ModelParameters);

  /* states (dwork) */
  (&m_SimStruct)->dwork = ((void *) &m_DWork);



  /* external inputs */
  (&m_SimStruct)->inputs = (((void*)&m_Input));


  /* external outputs */
  (&m_SimStruct)->outputs = (&m_Output);
  m_Output.d = 0.0;

  /* Initialize Sizes */
  (&m_SimStruct)->Sizes.numContStates = (0);/* Number of continuous states */
  (&m_SimStruct)->Sizes.numY = (1);/* Number of model outputs */
  (&m_SimStruct)->Sizes.numU = (16);/* Number of model inputs */
  (&m_SimStruct)->Sizes.sysDirFeedThru = (1);/* The model is direct feedthrough */
  (&m_SimStruct)->Sizes.numSampTimes = (1);/* Number of sample times */
  (&m_SimStruct)->Sizes.numBlocks = (7);/* Number of blocks */
  (&m_SimStruct)->Sizes.numBlockIO = (4);/* Number of block outputs */
  (&m_SimStruct)->Sizes.numBlockPrms = (7);/* Sum of parameter "widths" */
  return (&m_SimStruct);
}
