<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>RTW Report - HydroSimulator.cpp</title>
<style type="text/css"> .LN { font-style: italic; color: #888888 } </style>
<style type="text/css"> .CT { font-style: italic; color: #117755 } </style>
<style type="text/css"> .PP { font-style: bold;   color: #992211 } </style>
<style type="text/css"> .KW { font-style: bold;   color: #1122dd } </style>
<style type="text/css"> .DT { font-style: bold;   color: #112266 } </style>
<link rel="stylesheet" type="text/css" href="rtwreport.css"></link><script language="JavaScript" type="text/javascript" src="rtwreport_utils.js"></script>
<SCRIPT type="text/javascript" src="rtwannotate.js"></SCRIPT>
</head>
<body bgcolor="#eeeeee" text="#1122aa" onload="try {if (top) { if (top.rtwFileOnLoad) top.rtwFileOnLoad(window.document); else local_onload();}} catch(err) {};if (rtwannotate) {rtwannotate('StateRun_cpp_cov.xml');}">
<p>
<table border="0" cellspacing="0" cellpadding="6" width="100%" height="100%"><tr><td width="100%" valign="top" bgcolor="#ffffff">
<h4>File: <a href="../HydroSimulator.cpp" target="rtwreport_document_frame" id="linkToText_plain">HydroSimulator.cpp</a></h4>
<pre id="RTWcode" style="color:black;">
<a class="LN" name="1">   1</a>	<span class="CT">// ****************** HydroSimulator.cpp *******************************</span>
<a class="LN" name="2">   2</a>	<span class="CT">// Generated by TwinCAT Target for MATLAB/Simulink (TE1400)</span>
<a class="LN" name="3">   3</a>	<span class="CT">// MATLAB R2019a (win64)</span>
<a class="LN" name="4">   4</a>	<span class="CT">// TwinCAT 3.1.4022</span>
<a class="LN" name="5">   5</a>	<span class="CT">// TwinCAT Target 1.2.1237</span>
<a class="LN" name="6">   6</a>	<span class="CT">// Beckhoff Automation GmbH &amp; Co. KG     (www.beckhoff.com)</span>
<a class="LN" name="7">   7</a>	<span class="CT">// *************************************************************</span>
<a class="LN" name="8">   8</a>	<span class="CT">/*
<a class="LN" name="9">   9</a>	 * HydroSimulator.cpp
<a class="LN" name="10">  10</a>	 *
<a class="LN" name="11">  11</a>	 * Academic License - for use in teaching, academic research, and meeting
<a class="LN" name="12">  12</a>	 * course requirements at degree granting institutions only.  Not for
<a class="LN" name="13">  13</a>	 * government, commercial, or other organizational use.
<a class="LN" name="14">  14</a>	 *
<a class="LN" name="15">  15</a>	 * Code generation for model "HydroSimulator".
<a class="LN" name="16">  16</a>	 *
<a class="LN" name="17">  17</a>	 * Model version              : 1.867
<a class="LN" name="18">  18</a>	 * Simulink Coder version : 9.1 (R2019a) 23-Nov-2018
<a class="LN" name="19">  19</a>	 * C++ source code generated on : Fri Dec 20 06:07:41 2019
<a class="LN" name="20">  20</a>	 *
<a class="LN" name="21">  21</a>	 * Target selection: TwinCAT.tlc
<a class="LN" name="22">  22</a>	 * Note: GRT includes extra infrastructure and instrumentation for prototyping
<a class="LN" name="23">  23</a>	 * Embedded hardware selection: Intel-&gt;x86-64 (Windows64)
<a class="LN" name="24">  24</a>	 * Code generation objective: Execution efficiency
<a class="LN" name="25">  25</a>	 * Validation result: Not run
<a class="LN" name="26">  26</a>	 */</span>
<a class="LN" name="27">  27</a>	
<a class="LN" name="28">  28</a>	<span class="KW">#include</span> <span class="PP">&quot;stdafx.h&quot;</span>
<a class="LN" name="29">  29</a>	<span class="KW">#include</span> <span class="PP">&quot;CHydroSimulator.h&quot;</span>
<a class="LN" name="30">  30</a>	<span class="KW">#include</span> <span class="PP">&quot;HydroSimulator.h&quot;</span>
<a class="LN" name="31">  31</a>	<span class="KW">#include</span> <span class="PP">&quot;HydroSimulator_private.h&quot;</span>
<a class="LN" name="32">  32</a>	<span class="CT">/* Solver interface called by GRT_Main */</span>
<a class="LN" name="33">  33</a>	<span class="KW">#ifndef</span> USE_GENERATED_SOLVER
<a class="LN" name="34">  34</a>	
<a class="LN" name="35">  35</a>	<span class="KW">#endif</span>
<a class="LN" name="36">  36</a>	
<a class="LN" name="37">  37</a>	
<a class="LN" name="38">  38</a>	void CHydroSimulator::rate_scheduler (void)
<a class="LN" name="39">  39</a>	{
<a class="LN" name="40">  40</a>	  <span class="CT">/* Compute which subrates run during the next base time step.  Subrates
<a class="LN" name="41">  41</a>	   * are an integer multiple of the base rate counter.  Therefore, the subtask
<a class="LN" name="42">  42</a>	   * counter is reset when it reaches its limit (zero means run).
<a class="LN" name="43">  43</a>	   */</span>
<a class="LN" name="44">  44</a>	  ((&amp;m_SimStruct)-&gt;Timing.TaskCounters.TID[2])++;
<a class="LN" name="45">  45</a>	  <span class="KW">if</span> (((&amp;m_SimStruct)-&gt;Timing.TaskCounters.TID[2]) &gt; 1) {<span class="CT">/* Sample time: [0.01s, 0.0s] */</span>
<a class="LN" name="46">  46</a>	    (&amp;m_SimStruct)-&gt;Timing.TaskCounters.TID[2] = 0;
<a class="LN" name="47">  47</a>	  }
<a class="LN" name="48">  48</a>	
<a class="LN" name="49">  49</a>	  (&amp;m_SimStruct)-&gt;Timing.sampleHits[2] =
<a class="LN" name="50">  50</a>	    ((&amp;m_SimStruct)-&gt;Timing.TaskCounters.TID[2] == 0);
<a class="LN" name="51">  51</a>	  ((&amp;m_SimStruct)-&gt;Timing.TaskCounters.TID[3])++;
<a class="LN" name="52">  52</a>	  <span class="KW">if</span> (((&amp;m_SimStruct)-&gt;Timing.TaskCounters.TID[3]) &gt; 199) {<span class="CT">/* Sample time: [1.0s, 0.0s] */</span>
<a class="LN" name="53">  53</a>	    (&amp;m_SimStruct)-&gt;Timing.TaskCounters.TID[3] = 0;
<a class="LN" name="54">  54</a>	  }
<a class="LN" name="55">  55</a>	
<a class="LN" name="56">  56</a>	  (&amp;m_SimStruct)-&gt;Timing.sampleHits[3] =
<a class="LN" name="57">  57</a>	    ((&amp;m_SimStruct)-&gt;Timing.TaskCounters.TID[3] == 0);
<a class="LN" name="58">  58</a>	}
<a class="LN" name="59">  59</a>	
<a class="LN" name="60">  60</a>	void CHydroSimulator::rt_ertODEUpdateContinuousStates (RTWSolverInfo *si )
<a class="LN" name="61">  61</a>	{
<a class="LN" name="62">  62</a>	  <span class="CT">/* Solver Matrices */</span>
<a class="LN" name="63">  63</a>	  static const real_T rt_ODE3_A[3] = {
<a class="LN" name="64">  64</a>	    1.0/2.0, 3.0/4.0, 1.0
<a class="LN" name="65">  65</a>	  };
<a class="LN" name="66">  66</a>	
<a class="LN" name="67">  67</a>	  static const real_T rt_ODE3_B[3][3] = {
<a class="LN" name="68">  68</a>	    { 1.0/2.0, 0.0, 0.0 },
<a class="LN" name="69">  69</a>	
<a class="LN" name="70">  70</a>	    { 0.0, 3.0/4.0, 0.0 },
<a class="LN" name="71">  71</a>	
<a class="LN" name="72">  72</a>	    { 2.0/9.0, 1.0/3.0, 4.0/9.0 }
<a class="LN" name="73">  73</a>	  };
<a class="LN" name="74">  74</a>	
<a class="LN" name="75">  75</a>	  time_T t = rtsiGetT(si);
<a class="LN" name="76">  76</a>	  time_T tnew = rtsiGetSolverStopTime(si);
<a class="LN" name="77">  77</a>	  time_T h = rtsiGetStepSize(si);
<a class="LN" name="78">  78</a>	  real_T *x = rtsiGetContStates(si);
<a class="LN" name="79">  79</a>	  ODE3_IntgData *id = (ODE3_IntgData *)rtsiGetSolverData(si);
<a class="LN" name="80">  80</a>	  real_T *y = id-&gt;y;
<a class="LN" name="81">  81</a>	  real_T *f0 = id-&gt;f[0];
<a class="LN" name="82">  82</a>	  real_T *f1 = id-&gt;f[1];
<a class="LN" name="83">  83</a>	  real_T *f2 = id-&gt;f[2];
<a class="LN" name="84">  84</a>	  real_T hB[3];
<a class="LN" name="85">  85</a>	  int_T i;
<a class="LN" name="86">  86</a>	  int_T nXc = 30;
<a class="LN" name="87">  87</a>	  rtsiSetSimTimeStep(si,MINOR_TIME_STEP);
<a class="LN" name="88">  88</a>	
<a class="LN" name="89">  89</a>	  <span class="CT">/* Save the state values at time t in y, we'll use x as ynew. */</span>
<a class="LN" name="90">  90</a>	  (void) memcpy(y, x,
<a class="LN" name="91">  91</a>	                (uint_T)nXc*sizeof(real_T));
<a class="LN" name="92">  92</a>	
<a class="LN" name="93">  93</a>	  <span class="CT">/* Assumes that rtsiSetT and ModelOutputs are up-to-date */</span>
<a class="LN" name="94">  94</a>	  <span class="CT">/* f0 = f(t,y) */</span>
<a class="LN" name="95">  95</a>	  rtsiSetdX(si, f0);
<a class="LN" name="96">  96</a>	  HydroSimulator_derivatives();
<a class="LN" name="97">  97</a>	
<a class="LN" name="98">  98</a>	  <span class="CT">/* f(:,2) = feval(odefile, t + hA(1), y + f*hB(:,1), args(:)(*)); */</span>
<a class="LN" name="99">  99</a>	  hB[0] = h * rt_ODE3_B[0][0];
<a class="LN" name="100"> 100</a>	  <span class="KW">for</span> (i = 0; i &lt; nXc; i++) {
<a class="LN" name="101"> 101</a>	    x[i] = y[i] + (f0[i]*hB[0]);
<a class="LN" name="102"> 102</a>	  }
<a class="LN" name="103"> 103</a>	
<a class="LN" name="104"> 104</a>	  rtsiSetT(si, t + h*rt_ODE3_A[0]);
<a class="LN" name="105"> 105</a>	  rtsiSetdX(si, f1);
<a class="LN" name="106"> 106</a>	  HydroSimulator_output();
<a class="LN" name="107"> 107</a>	  HydroSimulator_derivatives();
<a class="LN" name="108"> 108</a>	
<a class="LN" name="109"> 109</a>	  <span class="CT">/* f(:,3) = feval(odefile, t + hA(2), y + f*hB(:,2), args(:)(*)); */</span>
<a class="LN" name="110"> 110</a>	  <span class="KW">for</span> (i = 0; i &lt;= 1; i++) {
<a class="LN" name="111"> 111</a>	    hB[i] = h * rt_ODE3_B[1][i];
<a class="LN" name="112"> 112</a>	  }
<a class="LN" name="113"> 113</a>	
<a class="LN" name="114"> 114</a>	  <span class="KW">for</span> (i = 0; i &lt; nXc; i++) {
<a class="LN" name="115"> 115</a>	    x[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1]);
<a class="LN" name="116"> 116</a>	  }
<a class="LN" name="117"> 117</a>	
<a class="LN" name="118"> 118</a>	  rtsiSetT(si, t + h*rt_ODE3_A[1]);
<a class="LN" name="119"> 119</a>	  rtsiSetdX(si, f2);
<a class="LN" name="120"> 120</a>	  HydroSimulator_output();
<a class="LN" name="121"> 121</a>	  HydroSimulator_derivatives();
<a class="LN" name="122"> 122</a>	
<a class="LN" name="123"> 123</a>	  <span class="CT">/* tnew = t + hA(3);
<a class="LN" name="124"> 124</a>	     ynew = y + f*hB(:,3); */</span>
<a class="LN" name="125"> 125</a>	  <span class="KW">for</span> (i = 0; i &lt;= 2; i++) {
<a class="LN" name="126"> 126</a>	    hB[i] = h * rt_ODE3_B[2][i];
<a class="LN" name="127"> 127</a>	  }
<a class="LN" name="128"> 128</a>	
<a class="LN" name="129"> 129</a>	  <span class="KW">for</span> (i = 0; i &lt; nXc; i++) {
<a class="LN" name="130"> 130</a>	    x[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1] + f2[i]*hB[2]);
<a class="LN" name="131"> 131</a>	  }
<a class="LN" name="132"> 132</a>	
<a class="LN" name="133"> 133</a>	  rtsiSetT(si, tnew);
<a class="LN" name="134"> 134</a>	  rtsiSetSimTimeStep(si,MAJOR_TIME_STEP);
<a class="LN" name="135"> 135</a>	}
<a class="LN" name="136"> 136</a>	
<a class="LN" name="137"> 137</a>	real_T CHydroSimulator::rt_urand_Upu32_Yd_f_pw_snf (uint32_T *u)
<a class="LN" name="138"> 138</a>	{
<a class="LN" name="139"> 139</a>	  uint32_T lo;
<a class="LN" name="140"> 140</a>	  uint32_T hi;
<a class="LN" name="141"> 141</a>	
<a class="LN" name="142"> 142</a>	  <span class="CT">/* Uniform random number generator (random number between 0 and 1)
<a class="LN" name="143"> 143</a>	
<a class="LN" name="144"> 144</a>	     #define IA      16807                      magic multiplier = 7^5
<a class="LN" name="145"> 145</a>	     #define IM      2147483647                 modulus = 2^31-1
<a class="LN" name="146"> 146</a>	     #define IQ      127773                     IM div IA
<a class="LN" name="147"> 147</a>	     #define IR      2836                       IM modulo IA
<a class="LN" name="148"> 148</a>	     #define S       4.656612875245797e-10      reciprocal of 2^31-1
<a class="LN" name="149"> 149</a>	     test = IA * (seed % IQ) - IR * (seed/IQ)
<a class="LN" name="150"> 150</a>	     seed = test &lt; 0 ? (test + IM) : test
<a class="LN" name="151"> 151</a>	     return (seed*S)
<a class="LN" name="152"> 152</a>	   */</span>
<a class="LN" name="153"> 153</a>	  lo = *u % 127773U * 16807U;
<a class="LN" name="154"> 154</a>	  hi = *u / 127773U * 2836U;
<a class="LN" name="155"> 155</a>	  <span class="KW">if</span> (lo &lt; hi) {
<a class="LN" name="156"> 156</a>	    *u = 2147483647U - (hi - lo);
<a class="LN" name="157"> 157</a>	  } <span class="KW">else</span> {
<a class="LN" name="158"> 158</a>	    *u = lo - hi;
<a class="LN" name="159"> 159</a>	  }
<a class="LN" name="160"> 160</a>	
<a class="LN" name="161"> 161</a>	  return static_cast&lt;real_T&gt;(*u) * 4.6566128752457969E-10;
<a class="LN" name="162"> 162</a>	}
<a class="LN" name="163"> 163</a>	
<a class="LN" name="164"> 164</a>	real_T CHydroSimulator::rt_nrand_Upu32_Yd_f_pw_snf (uint32_T *u)
<a class="LN" name="165"> 165</a>	{
<a class="LN" name="166"> 166</a>	  real_T y;
<a class="LN" name="167"> 167</a>	  real_T sr;
<a class="LN" name="168"> 168</a>	  real_T si;
<a class="LN" name="169"> 169</a>	
<a class="LN" name="170"> 170</a>	  <span class="CT">/* Normal (Gaussian) random number generator */</span>
<a class="LN" name="171"> 171</a>	  <span class="KW">do</span> {
<a class="LN" name="172"> 172</a>	    sr = 2.0 * rt_urand_Upu32_Yd_f_pw_snf(u) - 1.0;
<a class="LN" name="173"> 173</a>	    si = 2.0 * rt_urand_Upu32_Yd_f_pw_snf(u) - 1.0;
<a class="LN" name="174"> 174</a>	    si = sr * sr + si * si;
<a class="LN" name="175"> 175</a>	  } <span class="KW">while</span> (si &gt; 1.0);
<a class="LN" name="176"> 176</a>	
<a class="LN" name="177"> 177</a>	  y = std::sqrt(-2.0 * std::log(si) / si) * sr;
<a class="LN" name="178"> 178</a>	  return y;
<a class="LN" name="179"> 179</a>	}
<a class="LN" name="180"> 180</a>	
<a class="LN" name="181"> 181</a>	void CHydroSimulator::HydroSimulator_output (void)
<a class="LN" name="182"> 182</a>	{
<a class="LN" name="183"> 183</a>	  static const real_T a[36] = { 1.4690053746876147E-7, 0.0,
<a class="LN" name="184"> 184</a>	    -4.8180009592214244E-10, 0.0, 1.8427800367678206E-10, -0.0, 0.0,
<a class="LN" name="185"> 185</a>	    1.3291241933627674E-7, -0.0, -4.1523910573686178E-9, 0.0,
<a class="LN" name="186"> 186</a>	    2.246118561264065E-11, -4.8180009592214244E-10, -0.0, 5.755014152022931E-8,
<a class="LN" name="187"> 187</a>	    -0.0, -3.9714920529310617E-10, -0.0, 0.0, -4.1523910573686178E-9, -0.0,
<a class="LN" name="188"> 188</a>	    2.8964882301736963E-9, 0.0, 4.8718802883020507E-11, 1.8427800367678206E-10,
<a class="LN" name="189"> 189</a>	    0.0, -3.9714920529310617E-10, 0.0, 1.5190088863133132E-10, -0.0, -0.0,
<a class="LN" name="190"> 190</a>	    2.246118561264065E-11, -0.0, 4.8718802883020507E-11, -0.0,
<a class="LN" name="191"> 191</a>	    2.8099979955902821E-10 };
<a class="LN" name="192"> 192</a>	
<a class="LN" name="193"> 193</a>	  static const real_T b_a[36] = { 589675.19075222965, 0.0, 0.0, 0.0, 0.0, 0.0,
<a class="LN" name="194"> 194</a>	    0.0, 1.9628508E+6, 0.0, 1.9009739E+6, 0.0, 5.7397055E+6, 0.0, 0.0,
<a class="LN" name="195"> 195</a>	    1.5460518E+6, 0.0, 3.7347568E+7, 0.0, 0.0, 1.9009739E+6, 0.0,
<a class="LN" name="196"> 196</a>	    3.536832185572774E+7, 0.0, -4.7547112E+7, 0.0, 0.0, 3.7347568E+7, 0.0,
<a class="LN" name="197"> 197</a>	    1.5862845E+9, 0.0, 0.0, 5.7397055E+6, 0.0, -4.7547112E+7, 0.0, 8.9457563E+8
<a class="LN" name="198"> 198</a>	  };
<a class="LN" name="199"> 199</a>	
<a class="LN" name="200"> 200</a>	  static const real_T c_a[36] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
<a class="LN" name="201"> 201</a>	    0.0, 0.0, 0.0, 0.0, 0.0, 1.3910359E+7, 0.0, 7.0729128E+7, 0.0, 0.0, 0.0, 0.0,
<a class="LN" name="202"> 202</a>	    1.3379735E+8, 0.0, 0.0, 0.0, 0.0, 7.0729128E+7, 0.0, 6.467778E+9, 0.0, 0.0,
<a class="LN" name="203"> 203</a>	    0.0, 0.0, 0.0, 0.0, 0.0 };
<a class="LN" name="204"> 204</a>	
<a class="LN" name="205"> 205</a>	  real_T J[36];
<a class="LN" name="206"> 206</a>	  real_T T[9];
<a class="LN" name="207"> 207</a>	  real_T a_0;
<a class="LN" name="208"> 208</a>	  static const int8_T b[36] = { 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0,
<a class="LN" name="209"> 209</a>	    0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1 };
<a class="LN" name="210"> 210</a>	
<a class="LN" name="211"> 211</a>	  static const int8_T c[3] = { 1, 0, 0 };
<a class="LN" name="212"> 212</a>	
<a class="LN" name="213"> 213</a>	  int32_T iU;
<a class="LN" name="214"> 214</a>	  int32_T i;
<a class="LN" name="215"> 215</a>	  real_T c_a_0[6];
<a class="LN" name="216"> 216</a>	  real_T tmp[6];
<a class="LN" name="217"> 217</a>	  real_T tmp_0[9];
<a class="LN" name="218"> 218</a>	  real_T tmp_1[9];
<a class="LN" name="219"> 219</a>	  real_T c_0[9];
<a class="LN" name="220"> 220</a>	  int32_T i_0;
<a class="LN" name="221"> 221</a>	  real_T a_idx_1;
<a class="LN" name="222"> 222</a>	  real_T a_idx_3;
<a class="LN" name="223"> 223</a>	  real_T c_tmp;
<a class="LN" name="224"> 224</a>	  real_T c_tmp_0;
<a class="LN" name="225"> 225</a>	  <span class="KW">if</span> (rtmIsMajorTimeStep((&amp;m_SimStruct))) {
<a class="LN" name="226"> 226</a>	    <span class="CT">/* set solver stop time */</span>
<a class="LN" name="227"> 227</a>	    <span class="KW">if</span> (!((&amp;m_SimStruct)-&gt;Timing.clockTick0+1)) {
<a class="LN" name="228"> 228</a>	      rtsiSetSolverStopTime(&amp;(&amp;m_SimStruct)-&gt;solverInfo,
<a class="LN" name="229"> 229</a>	                            (((&amp;m_SimStruct)-&gt;Timing.clockTickH0 + 1) *
<a class="LN" name="230"> 230</a>	        (&amp;m_SimStruct)-&gt;Timing.stepSize0 * 4294967296.0));
<a class="LN" name="231"> 231</a>	    } <span class="KW">else</span> {
<a class="LN" name="232"> 232</a>	      rtsiSetSolverStopTime(&amp;(&amp;m_SimStruct)-&gt;solverInfo,
<a class="LN" name="233"> 233</a>	                            (((&amp;m_SimStruct)-&gt;Timing.clockTick0 + 1) *
<a class="LN" name="234"> 234</a>	        (&amp;m_SimStruct)-&gt;Timing.stepSize0 +
<a class="LN" name="235"> 235</a>	        (&amp;m_SimStruct)-&gt;Timing.clockTickH0 *
<a class="LN" name="236"> 236</a>	        (&amp;m_SimStruct)-&gt;Timing.stepSize0 * 4294967296.0));
<a class="LN" name="237"> 237</a>	    }
<a class="LN" name="238"> 238</a>	  }                                    <span class="CT">/* end MajorTimeStep */</span>
<a class="LN" name="239"> 239</a>	
<a class="LN" name="240"> 240</a>	  <span class="CT">/* Update absolute time of base rate at minor time step */</span>
<a class="LN" name="241"> 241</a>	  <span class="KW">if</span> (rtmIsMinorTimeStep((&amp;m_SimStruct))) {
<a class="LN" name="242"> 242</a>	    (&amp;m_SimStruct)-&gt;Timing.t[0] = rtsiGetT(&amp;(&amp;m_SimStruct)-&gt;solverInfo);
<a class="LN" name="243"> 243</a>	  }
<a class="LN" name="244"> 244</a>	
<a class="LN" name="245"> 245</a>	  <span class="KW">if</span> (rtmIsMajorTimeStep((&amp;m_SimStruct)) &amp;&amp;
<a class="LN" name="246"> 246</a>	      (&amp;m_SimStruct)-&gt;Timing.TaskCounters.TID[1] == 0) {
<a class="LN" name="247"> 247</a>	    <span class="KW">for</span> (i = 0; i &lt; 6; i++) {
<a class="LN" name="248"> 248</a>	      <span class="CT">/* UnitDelay: '&lt;S5&gt;/Unit Delay' */</span>
<a class="LN" name="249"> 249</a>	      m_BlockIO.UnitDelay[i] = m_DWork.UnitDelay_DSTATE[i];
<a class="LN" name="250"> 250</a>	
<a class="LN" name="251"> 251</a>	      <span class="CT">/* Saturate: '&lt;S5&gt;/Saturation1' */</span>
<a class="LN" name="252"> 252</a>	      <span class="KW">if</span> (m_BlockIO.UnitDelay[i] &gt; m_ModelParameters.Saturation1_UpperSat)
<a class="LN" name="253"> 253</a>	      {
<a class="LN" name="254"> 254</a>	        <span class="CT">/* Outport: '&lt;Root&gt;/scale' */</span>
<a class="LN" name="255"> 255</a>	        m_Output.scale[i] = m_ModelParameters.Saturation1_UpperSat;
<a class="LN" name="256"> 256</a>	      } <span class="KW">else</span> <span class="KW">if</span> (m_BlockIO.UnitDelay[i] &lt;
<a class="LN" name="257"> 257</a>	                 m_ModelParameters.Saturation1_LowerSat) {
<a class="LN" name="258"> 258</a>	        <span class="CT">/* Outport: '&lt;Root&gt;/scale' */</span>
<a class="LN" name="259"> 259</a>	        m_Output.scale[i] = m_ModelParameters.Saturation1_LowerSat;
<a class="LN" name="260"> 260</a>	      } <span class="KW">else</span> {
<a class="LN" name="261"> 261</a>	        <span class="CT">/* Outport: '&lt;Root&gt;/scale' */</span>
<a class="LN" name="262"> 262</a>	        m_Output.scale[i] = m_BlockIO.UnitDelay[i];
<a class="LN" name="263"> 263</a>	      }
<a class="LN" name="264"> 264</a>	
<a class="LN" name="265"> 265</a>	      <span class="CT">/* End of Saturate: '&lt;S5&gt;/Saturation1' */</span>
<a class="LN" name="266"> 266</a>	    }
<a class="LN" name="267"> 267</a>	  }
<a class="LN" name="268"> 268</a>	
<a class="LN" name="269"> 269</a>	  <span class="KW">for</span> (i = 0; i &lt; 6; i++) {
<a class="LN" name="270"> 270</a>	    <span class="CT">/* Abs: '&lt;S5&gt;/Abs1' incorporates:
<a class="LN" name="271"> 271</a>	     *  Inport: '&lt;Root&gt;/etaMax'
<a class="LN" name="272"> 272</a>	     */</span>
<a class="LN" name="273"> 273</a>	    m_BlockIO.Abs1[i] = std::abs(m_Input.etaMax[i]);
<a class="LN" name="274"> 274</a>	
<a class="LN" name="275"> 275</a>	    <span class="CT">/* Integrator: '&lt;S1&gt;/Integrator1' */</span>
<a class="LN" name="276"> 276</a>	    m_BlockIO.Integrator1[i] = m_ContState.Integrator1_CSTATE[i];
<a class="LN" name="277"> 277</a>	
<a class="LN" name="278"> 278</a>	    <span class="CT">/* Product: '&lt;S5&gt;/Product' incorporates:
<a class="LN" name="279"> 279</a>	     *  Outport: '&lt;Root&gt;/scale'
<a class="LN" name="280"> 280</a>	     */</span>
<a class="LN" name="281"> 281</a>	    m_BlockIO.Product[i] = m_BlockIO.Integrator1[i] *
<a class="LN" name="282"> 282</a>	      m_Output.scale[i];
<a class="LN" name="283"> 283</a>	
<a class="LN" name="284"> 284</a>	    <span class="CT">/* RelationalOperator: '&lt;S54&gt;/LowerRelop1' */</span>
<a class="LN" name="285"> 285</a>	    m_BlockIO.LowerRelop1[i] = (m_BlockIO.Product[i] &gt;
<a class="LN" name="286"> 286</a>	      m_BlockIO.Abs1[i]);
<a class="LN" name="287"> 287</a>	
<a class="LN" name="288"> 288</a>	    <span class="CT">/* UnaryMinus: '&lt;S5&gt;/Unary Minus' */</span>
<a class="LN" name="289"> 289</a>	    m_BlockIO.UnaryMinus[i] = -m_BlockIO.Abs1[i];
<a class="LN" name="290"> 290</a>	
<a class="LN" name="291"> 291</a>	    <span class="CT">/* RelationalOperator: '&lt;S54&gt;/UpperRelop' */</span>
<a class="LN" name="292"> 292</a>	    m_BlockIO.UpperRelop[i] = (m_BlockIO.Product[i] &lt;
<a class="LN" name="293"> 293</a>	      m_BlockIO.UnaryMinus[i]);
<a class="LN" name="294"> 294</a>	
<a class="LN" name="295"> 295</a>	    <span class="CT">/* Switch: '&lt;S54&gt;/Switch' */</span>
<a class="LN" name="296"> 296</a>	    <span class="KW">if</span> (m_BlockIO.UpperRelop[i]) {
<a class="LN" name="297"> 297</a>	      m_BlockIO.Gain[i] = m_BlockIO.UnaryMinus[i];
<a class="LN" name="298"> 298</a>	    } <span class="KW">else</span> {
<a class="LN" name="299"> 299</a>	      m_BlockIO.Gain[i] = m_BlockIO.Product[i];
<a class="LN" name="300"> 300</a>	    }
<a class="LN" name="301"> 301</a>	
<a class="LN" name="302"> 302</a>	    <span class="CT">/* End of Switch: '&lt;S54&gt;/Switch' */</span>
<a class="LN" name="303"> 303</a>	
<a class="LN" name="304"> 304</a>	    <span class="CT">/* Switch: '&lt;S54&gt;/Switch2' */</span>
<a class="LN" name="305"> 305</a>	    <span class="KW">if</span> (m_BlockIO.LowerRelop1[i]) {
<a class="LN" name="306"> 306</a>	      m_BlockIO.Gain[i] = m_BlockIO.Abs1[i];
<a class="LN" name="307"> 307</a>	    }
<a class="LN" name="308"> 308</a>	
<a class="LN" name="309"> 309</a>	    <span class="CT">/* End of Switch: '&lt;S54&gt;/Switch2' */</span>
<a class="LN" name="310"> 310</a>	
<a class="LN" name="311"> 311</a>	    <span class="CT">/* Outport: '&lt;Root&gt;/eta' */</span>
<a class="LN" name="312"> 312</a>	    m_Output.eta[i] = m_BlockIO.Gain[i];
<a class="LN" name="313"> 313</a>	
<a class="LN" name="314"> 314</a>	    <span class="CT">/* Integrator: '&lt;S1&gt;/Integrator' */</span>
<a class="LN" name="315"> 315</a>	    m_BlockIO.Integrator[i] = m_ContState.Integrator_CSTATE[i];
<a class="LN" name="316"> 316</a>	
<a class="LN" name="317"> 317</a>	    <span class="CT">/* Outport: '&lt;Root&gt;/v' */</span>
<a class="LN" name="318"> 318</a>	    m_Output.v[i] = m_BlockIO.Integrator[i];
<a class="LN" name="319"> 319</a>	  }
<a class="LN" name="320"> 320</a>	
<a class="LN" name="321"> 321</a>	  <span class="KW">if</span> (rtmIsMajorTimeStep((&amp;m_SimStruct)) &amp;&amp;
<a class="LN" name="322"> 322</a>	      (&amp;m_SimStruct)-&gt;Timing.TaskCounters.TID[3] == 0) {
<a class="LN" name="323"> 323</a>	    <span class="CT">/* MATLAB Function: '&lt;S1&gt;/LinearWaveModel' incorporates:
<a class="LN" name="324"> 324</a>	     *  Inport: '&lt;Root&gt;/lambda'
<a class="LN" name="325"> 325</a>	     *  Inport: '&lt;Root&gt;/sigma'
<a class="LN" name="326"> 326</a>	     *  Inport: '&lt;Root&gt;/w0'
<a class="LN" name="327"> 327</a>	     */</span>
<a class="LN" name="328"> 328</a>	    a_idx_1 = -(m_Input.w0 * m_Input.w0);
<a class="LN" name="329"> 329</a>	    a_idx_3 = std::abs(m_Input.lambda * m_Input.w0) * -2.0;
<a class="LN" name="330"> 330</a>	    memset(&amp;m_BlockIO.A[0], 0, 144U * sizeof(real_T));
<a class="LN" name="331"> 331</a>	    m_BlockIO.A[0] = 0.0;
<a class="LN" name="332"> 332</a>	    m_BlockIO.A[26] = 0.0;
<a class="LN" name="333"> 333</a>	    m_BlockIO.A[52] = 0.0;
<a class="LN" name="334"> 334</a>	    m_BlockIO.A[78] = 0.0;
<a class="LN" name="335"> 335</a>	    m_BlockIO.A[104] = 0.0;
<a class="LN" name="336"> 336</a>	    m_BlockIO.A[130] = 0.0;
<a class="LN" name="337"> 337</a>	    m_BlockIO.A[1] = a_idx_1;
<a class="LN" name="338"> 338</a>	    m_BlockIO.A[27] = a_idx_1;
<a class="LN" name="339"> 339</a>	    m_BlockIO.A[53] = a_idx_1;
<a class="LN" name="340"> 340</a>	    m_BlockIO.A[79] = a_idx_1;
<a class="LN" name="341"> 341</a>	    m_BlockIO.A[105] = a_idx_1;
<a class="LN" name="342"> 342</a>	    m_BlockIO.A[131] = a_idx_1;
<a class="LN" name="343"> 343</a>	    m_BlockIO.A[12] = 1.0;
<a class="LN" name="344"> 344</a>	    m_BlockIO.A[38] = 1.0;
<a class="LN" name="345"> 345</a>	    m_BlockIO.A[64] = 1.0;
<a class="LN" name="346"> 346</a>	    m_BlockIO.A[90] = 1.0;
<a class="LN" name="347"> 347</a>	    m_BlockIO.A[116] = 1.0;
<a class="LN" name="348"> 348</a>	    m_BlockIO.A[142] = 1.0;
<a class="LN" name="349"> 349</a>	    m_BlockIO.A[13] = a_idx_3;
<a class="LN" name="350"> 350</a>	    m_BlockIO.A[39] = a_idx_3;
<a class="LN" name="351"> 351</a>	    m_BlockIO.A[65] = a_idx_3;
<a class="LN" name="352"> 352</a>	    m_BlockIO.A[91] = a_idx_3;
<a class="LN" name="353"> 353</a>	    m_BlockIO.A[117] = a_idx_3;
<a class="LN" name="354"> 354</a>	    m_BlockIO.A[143] = a_idx_3;
<a class="LN" name="355"> 355</a>	    a_idx_1 = std::abs(2.0 * m_Input.lambda * m_Input.w0 *
<a class="LN" name="356"> 356</a>	                       m_Input.sigma);
<a class="LN" name="357"> 357</a>	    memset(&amp;m_BlockIO.B[0], 0, 72U * sizeof(real_T));
<a class="LN" name="358"> 358</a>	    memset(&amp;m_BlockIO.C[0], 0, 72U * sizeof(real_T));
<a class="LN" name="359"> 359</a>	    m_BlockIO.B[0] = 0.0;
<a class="LN" name="360"> 360</a>	    m_BlockIO.B[14] = 0.0;
<a class="LN" name="361"> 361</a>	    m_BlockIO.B[28] = 0.0;
<a class="LN" name="362"> 362</a>	    m_BlockIO.B[42] = 0.0;
<a class="LN" name="363"> 363</a>	    m_BlockIO.B[56] = 0.0;
<a class="LN" name="364"> 364</a>	    m_BlockIO.B[70] = 0.0;
<a class="LN" name="365"> 365</a>	    m_BlockIO.B[1] = a_idx_1;
<a class="LN" name="366"> 366</a>	    m_BlockIO.B[15] = a_idx_1;
<a class="LN" name="367"> 367</a>	    m_BlockIO.B[29] = a_idx_1;
<a class="LN" name="368"> 368</a>	    m_BlockIO.B[43] = a_idx_1;
<a class="LN" name="369"> 369</a>	    m_BlockIO.B[57] = a_idx_1;
<a class="LN" name="370"> 370</a>	    m_BlockIO.B[71] = a_idx_1;
<a class="LN" name="371"> 371</a>	    m_BlockIO.C[0] = 0.0;
<a class="LN" name="372"> 372</a>	    m_BlockIO.C[13] = 0.0;
<a class="LN" name="373"> 373</a>	    m_BlockIO.C[26] = 0.0;
<a class="LN" name="374"> 374</a>	    m_BlockIO.C[39] = 0.0;
<a class="LN" name="375"> 375</a>	    m_BlockIO.C[52] = 0.0;
<a class="LN" name="376"> 376</a>	    m_BlockIO.C[65] = 0.0;
<a class="LN" name="377"> 377</a>	    m_BlockIO.C[6] = 1.0;
<a class="LN" name="378"> 378</a>	    m_BlockIO.C[19] = 1.0;
<a class="LN" name="379"> 379</a>	    m_BlockIO.C[32] = 1.0;
<a class="LN" name="380"> 380</a>	    m_BlockIO.C[45] = 1.0;
<a class="LN" name="381"> 381</a>	    m_BlockIO.C[58] = 1.0;
<a class="LN" name="382"> 382</a>	    m_BlockIO.C[71] = 1.0;
<a class="LN" name="383"> 383</a>	    memset(&amp;m_BlockIO.D[0], 0, 36U * sizeof(real_T));
<a class="LN" name="384"> 384</a>	  }
<a class="LN" name="385"> 385</a>	
<a class="LN" name="386"> 386</a>	  <span class="CT">/* Integrator: '&lt;S8&gt;/Integrator' */</span>
<a class="LN" name="387"> 387</a>	  memcpy(&amp;m_BlockIO.x[0], &amp;m_ContState.Integrator_CSTATE_f[0], 12U *
<a class="LN" name="388"> 388</a>	         sizeof(real_T));
<a class="LN" name="389"> 389</a>	
<a class="LN" name="390"> 390</a>	  <span class="CT">/* Product: '&lt;S8&gt;/Product3' */</span>
<a class="LN" name="391"> 391</a>	  <span class="KW">for</span> (iU = 0; iU &lt; 6; iU++) {
<a class="LN" name="392"> 392</a>	    m_BlockIO.Gain[iU] = 0.0;
<a class="LN" name="393"> 393</a>	    <span class="KW">for</span> (i_0 = 0; i_0 &lt; 12; i_0++) {
<a class="LN" name="394"> 394</a>	      m_BlockIO.Gain[iU] += m_BlockIO.C[6 * i_0 + iU] *
<a class="LN" name="395"> 395</a>	        m_BlockIO.x[i_0];
<a class="LN" name="396"> 396</a>	    }
<a class="LN" name="397"> 397</a>	  }
<a class="LN" name="398"> 398</a>	
<a class="LN" name="399"> 399</a>	  <span class="CT">/* End of Product: '&lt;S8&gt;/Product3' */</span>
<a class="LN" name="400"> 400</a>	  <span class="KW">if</span> (rtmIsMajorTimeStep((&amp;m_SimStruct)) &amp;&amp;
<a class="LN" name="401"> 401</a>	      (&amp;m_SimStruct)-&gt;Timing.TaskCounters.TID[2] == 0) {
<a class="LN" name="402"> 402</a>	    <span class="CT">/* RandomNumber: '&lt;S1&gt;/Random Sequence' */</span>
<a class="LN" name="403"> 403</a>	    <span class="KW">for</span> (iU = 0; iU &lt; 6; iU++) {
<a class="LN" name="404"> 404</a>	      m_BlockIO.RandomSequence[iU] = m_DWork.NextOutput[iU];
<a class="LN" name="405"> 405</a>	    }
<a class="LN" name="406"> 406</a>	
<a class="LN" name="407"> 407</a>	    <span class="CT">/* End of RandomNumber: '&lt;S1&gt;/Random Sequence' */</span>
<a class="LN" name="408"> 408</a>	
<a class="LN" name="409"> 409</a>	    <span class="CT">/* Product: '&lt;S8&gt;/Product2' */</span>
<a class="LN" name="410"> 410</a>	    <span class="KW">for</span> (iU = 0; iU &lt; 6; iU++) {
<a class="LN" name="411"> 411</a>	      m_BlockIO.Du[iU] = 0.0;
<a class="LN" name="412"> 412</a>	      <span class="KW">for</span> (i_0 = 0; i_0 &lt; 6; i_0++) {
<a class="LN" name="413"> 413</a>	        m_BlockIO.Du[iU] += m_BlockIO.D[6 * i_0 + iU] *
<a class="LN" name="414"> 414</a>	          m_BlockIO.RandomSequence[i_0];
<a class="LN" name="415"> 415</a>	      }
<a class="LN" name="416"> 416</a>	    }
<a class="LN" name="417"> 417</a>	
<a class="LN" name="418"> 418</a>	    <span class="CT">/* End of Product: '&lt;S8&gt;/Product2' */</span>
<a class="LN" name="419"> 419</a>	  }
<a class="LN" name="420"> 420</a>	
<a class="LN" name="421"> 421</a>	  <span class="KW">for</span> (iU = 0; iU &lt; 6; iU++) {
<a class="LN" name="422"> 422</a>	    <span class="CT">/* Sum: '&lt;S8&gt;/Sum1' */</span>
<a class="LN" name="423"> 423</a>	    m_BlockIO.Gain[iU] += m_BlockIO.Du[iU];
<a class="LN" name="424"> 424</a>	
<a class="LN" name="425"> 425</a>	    <span class="CT">/* Gain: '&lt;S1&gt;/Gain' */</span>
<a class="LN" name="426"> 426</a>	    m_BlockIO.Gain[iU] *= m_ModelParameters.Gain_Gain[iU];
<a class="LN" name="427"> 427</a>	  }
<a class="LN" name="428"> 428</a>	
<a class="LN" name="429"> 429</a>	  <span class="KW">if</span> (rtmIsMajorTimeStep((&amp;m_SimStruct)) &amp;&amp;
<a class="LN" name="430"> 430</a>	      (&amp;m_SimStruct)-&gt;Timing.TaskCounters.TID[1] == 0) {
<a class="LN" name="431"> 431</a>	    <span class="CT">/* Saturate: '&lt;S1&gt;/Input Saturation' incorporates:
<a class="LN" name="432"> 432</a>	     *  Constant: '&lt;S1&gt;/u'
<a class="LN" name="433"> 433</a>	     */</span>
<a class="LN" name="434"> 434</a>	    <span class="KW">for</span> (i = 0; i &lt; 6; i++) {
<a class="LN" name="435"> 435</a>	      <span class="KW">if</span> (m_ModelParameters.u_Value[i] &gt;
<a class="LN" name="436"> 436</a>	          m_ModelParameters.InputSaturation_UpperSat[i]) {
<a class="LN" name="437"> 437</a>	        m_BlockIO.InputSaturation[i] =
<a class="LN" name="438"> 438</a>	          m_ModelParameters.InputSaturation_UpperSat[i];
<a class="LN" name="439"> 439</a>	      } <span class="KW">else</span> <span class="KW">if</span> (m_ModelParameters.u_Value[i] &lt;
<a class="LN" name="440"> 440</a>	                 m_ModelParameters.InputSaturation_LowerSat[i]) {
<a class="LN" name="441"> 441</a>	        m_BlockIO.InputSaturation[i] =
<a class="LN" name="442"> 442</a>	          m_ModelParameters.InputSaturation_LowerSat[i];
<a class="LN" name="443"> 443</a>	      } <span class="KW">else</span> {
<a class="LN" name="444"> 444</a>	        m_BlockIO.InputSaturation[i] = m_ModelParameters.u_Value[i];
<a class="LN" name="445"> 445</a>	      }
<a class="LN" name="446"> 446</a>	    }
<a class="LN" name="447"> 447</a>	
<a class="LN" name="448"> 448</a>	    <span class="CT">/* End of Saturate: '&lt;S1&gt;/Input Saturation' */</span>
<a class="LN" name="449"> 449</a>	  }
<a class="LN" name="450"> 450</a>	
<a class="LN" name="451"> 451</a>	  <span class="CT">/* Sum: '&lt;S1&gt;/Sum1' */</span>
<a class="LN" name="452"> 452</a>	  <span class="KW">for</span> (i = 0; i &lt; 6; i++) {
<a class="LN" name="453"> 453</a>	    m_BlockIO.SumD[i] = m_BlockIO.InputSaturation[i] -
<a class="LN" name="454"> 454</a>	      m_BlockIO.Integrator1[i];
<a class="LN" name="455"> 455</a>	  }
<a class="LN" name="456"> 456</a>	
<a class="LN" name="457"> 457</a>	  <span class="CT">/* End of Sum: '&lt;S1&gt;/Sum1' */</span>
<a class="LN" name="458"> 458</a>	  <span class="KW">if</span> (rtmIsMajorTimeStep((&amp;m_SimStruct)) &amp;&amp;
<a class="LN" name="459"> 459</a>	      (&amp;m_SimStruct)-&gt;Timing.TaskCounters.TID[3] == 0) {
<a class="LN" name="460"> 460</a>	    <span class="CT">/* Saturate: '&lt;S1&gt;/Poles Saturation' incorporates:
<a class="LN" name="461"> 461</a>	     *  Constant: '&lt;S1&gt;/poles'
<a class="LN" name="462"> 462</a>	     */</span>
<a class="LN" name="463"> 463</a>	    <span class="KW">if</span> (m_ModelParameters.poles_Value &gt; m_ModelParameters.PolesSaturation_UpperSat)
<a class="LN" name="464"> 464</a>	    {
<a class="LN" name="465"> 465</a>	      m_BlockIO.PolesSaturation =
<a class="LN" name="466"> 466</a>	        m_ModelParameters.PolesSaturation_UpperSat;
<a class="LN" name="467"> 467</a>	    } <span class="KW">else</span> <span class="KW">if</span> (m_ModelParameters.poles_Value &lt;
<a class="LN" name="468"> 468</a>	               m_ModelParameters.PolesSaturation_LowerSat) {
<a class="LN" name="469"> 469</a>	      m_BlockIO.PolesSaturation =
<a class="LN" name="470"> 470</a>	        m_ModelParameters.PolesSaturation_LowerSat;
<a class="LN" name="471"> 471</a>	    } <span class="KW">else</span> {
<a class="LN" name="472"> 472</a>	      m_BlockIO.PolesSaturation = m_ModelParameters.poles_Value;
<a class="LN" name="473"> 473</a>	    }
<a class="LN" name="474"> 474</a>	
<a class="LN" name="475"> 475</a>	    <span class="CT">/* End of Saturate: '&lt;S1&gt;/Poles Saturation' */</span>
<a class="LN" name="476"> 476</a>	
<a class="LN" name="477"> 477</a>	    <span class="CT">/* MATLAB Function: '&lt;S1&gt;/PolePlacer' */</span>
<a class="LN" name="478"> 478</a>	    <span class="KW">for</span> (i = 0; i &lt; 6; i++) {
<a class="LN" name="479"> 479</a>	      m_BlockIO.Kp[i] = 0.0;
<a class="LN" name="480"> 480</a>	      m_BlockIO.Kd[i] = 0.0;
<a class="LN" name="481"> 481</a>	    }
<a class="LN" name="482"> 482</a>	
<a class="LN" name="483"> 483</a>	    a_idx_1 = std::abs(m_BlockIO.PolesSaturation);
<a class="LN" name="484"> 484</a>	    a_idx_3 = a_idx_1 * a_idx_1;
<a class="LN" name="485"> 485</a>	    m_BlockIO.Kp[0] = (a_idx_3 * 11.557450930296984 - 100.0) /
<a class="LN" name="486"> 486</a>	      0.00016957249073865904;
<a class="LN" name="487"> 487</a>	    m_BlockIO.Kp[1] = (a_idx_3 * 4.0268412070014108 - 100.0) /
<a class="LN" name="488"> 488</a>	      5.1838649785438191E-5;
<a class="LN" name="489"> 489</a>	    m_BlockIO.Kp[5] = (a_idx_3 * 4.0706796111413865 - 100.0) /
<a class="LN" name="490"> 490</a>	      1.1383490937706065E-7;
<a class="LN" name="491"> 491</a>	    m_BlockIO.Kd[0] = (((23.114901860593967 * a_idx_1 - 1.0) -
<a class="LN" name="492"> 492</a>	      m_BlockIO.Kp[0] * 1.6957249073865904E-6) - 1155.7450930296984) /
<a class="LN" name="493"> 493</a>	      0.00016957249073865904;
<a class="LN" name="494"> 494</a>	    m_BlockIO.Kd[1] = (((8.0536824140028216 * a_idx_1 - 1.0) -
<a class="LN" name="495"> 495</a>	      m_BlockIO.Kp[1] * 5.1838649785438193E-7) - 402.68412070014108) /
<a class="LN" name="496"> 496</a>	      5.1838649785438191E-5;
<a class="LN" name="497"> 497</a>	    m_BlockIO.Kd[5] = (((8.1413592222827731 * a_idx_1 - 1.0) -
<a class="LN" name="498"> 498</a>	      m_BlockIO.Kp[5] * 1.1383490937706064E-9) - 407.06796111413865) /
<a class="LN" name="499"> 499</a>	      1.1383490937706065E-7;
<a class="LN" name="500"> 500</a>	    <span class="KW">for</span> (i = 0; i &lt; 6; i++) {
<a class="LN" name="501"> 501</a>	      m_BlockIO.Kp[i] = std::abs(m_BlockIO.Kp[i]);
<a class="LN" name="502"> 502</a>	      m_BlockIO.Kd[i] = std::abs(m_BlockIO.Kd[i]);
<a class="LN" name="503"> 503</a>	    }
<a class="LN" name="504"> 504</a>	
<a class="LN" name="505"> 505</a>	    m_BlockIO.N = 100.0;
<a class="LN" name="506"> 506</a>	
<a class="LN" name="507"> 507</a>	    <span class="CT">/* End of MATLAB Function: '&lt;S1&gt;/PolePlacer' */</span>
<a class="LN" name="508"> 508</a>	  }
<a class="LN" name="509"> 509</a>	
<a class="LN" name="510"> 510</a>	  <span class="KW">for</span> (i = 0; i &lt; 6; i++) {
<a class="LN" name="511"> 511</a>	    <span class="CT">/* Product: '&lt;S43&gt;/PProd Out' */</span>
<a class="LN" name="512"> 512</a>	    m_BlockIO.Sum_d[i] = m_BlockIO.SumD[i] * m_BlockIO.Kp[i];
<a class="LN" name="513"> 513</a>	
<a class="LN" name="514"> 514</a>	    <span class="CT">/* Product: '&lt;S32&gt;/DProd Out' */</span>
<a class="LN" name="515"> 515</a>	    m_BlockIO.SumD[i] *= m_BlockIO.Kd[i];
<a class="LN" name="516"> 516</a>	
<a class="LN" name="517"> 517</a>	    <span class="CT">/* Integrator: '&lt;S33&gt;/Filter' */</span>
<a class="LN" name="518"> 518</a>	    m_BlockIO.Filter[i] = m_ContState.Filter_CSTATE[i];
<a class="LN" name="519"> 519</a>	
<a class="LN" name="520"> 520</a>	    <span class="CT">/* Sum: '&lt;S33&gt;/SumD' */</span>
<a class="LN" name="521"> 521</a>	    m_BlockIO.SumD[i] -= m_BlockIO.Filter[i];
<a class="LN" name="522"> 522</a>	
<a class="LN" name="523"> 523</a>	    <span class="CT">/* Product: '&lt;S41&gt;/NProd Out' */</span>
<a class="LN" name="524"> 524</a>	    m_BlockIO.NProdOut[i] = m_BlockIO.SumD[i] * m_BlockIO.N;
<a class="LN" name="525"> 525</a>	
<a class="LN" name="526"> 526</a>	    <span class="CT">/* Sum: '&lt;S47&gt;/Sum' */</span>
<a class="LN" name="527"> 527</a>	    m_BlockIO.Sum_d[i] += m_BlockIO.NProdOut[i];
<a class="LN" name="528"> 528</a>	
<a class="LN" name="529"> 529</a>	    <span class="CT">/* Sum: '&lt;S1&gt;/Sum' */</span>
<a class="LN" name="530"> 530</a>	    m_BlockIO.Sum[i] = m_BlockIO.Gain[i] +
<a class="LN" name="531"> 531</a>	      m_BlockIO.Sum_d[i];
<a class="LN" name="532"> 532</a>	
<a class="LN" name="533"> 533</a>	    <span class="CT">/* MATLAB Function: '&lt;S1&gt;/StateSpaceModel' */</span>
<a class="LN" name="534"> 534</a>	    a_idx_1 = 0.0;
<a class="LN" name="535"> 535</a>	    c_a_0[i] = 0.0;
<a class="LN" name="536"> 536</a>	    <span class="KW">for</span> (iU = 0; iU &lt; 6; iU++) {
<a class="LN" name="537"> 537</a>	      i_0 = 6 * iU + i;
<a class="LN" name="538"> 538</a>	      a_idx_1 += b_a[i_0] * m_BlockIO.Integrator[iU];
<a class="LN" name="539"> 539</a>	      c_a_0[i] += c_a[i_0] * m_BlockIO.Integrator1[iU];
<a class="LN" name="540"> 540</a>	    }
<a class="LN" name="541"> 541</a>	
<a class="LN" name="542"> 542</a>	    tmp[i] = (m_BlockIO.Sum[i] - a_idx_1) - c_a_0[i];
<a class="LN" name="543"> 543</a>	  }
<a class="LN" name="544"> 544</a>	
<a class="LN" name="545"> 545</a>	  <span class="KW">for</span> (i = 0; i &lt; 6; i++) {
<a class="LN" name="546"> 546</a>	    <span class="CT">/* MATLAB Function: '&lt;S1&gt;/StateSpaceModel' */</span>
<a class="LN" name="547"> 547</a>	    m_BlockIO.v_t[i] = 0.0;
<a class="LN" name="548"> 548</a>	    <span class="KW">for</span> (iU = 0; iU &lt; 6; iU++) {
<a class="LN" name="549"> 549</a>	      m_BlockIO.v_t[i] += a[6 * iU + i] * tmp[iU];
<a class="LN" name="550"> 550</a>	    }
<a class="LN" name="551"> 551</a>	
<a class="LN" name="552"> 552</a>	    <span class="CT">/* Outport: '&lt;Root&gt;/v_t' */</span>
<a class="LN" name="553"> 553</a>	    m_Output.v_t[i] = m_BlockIO.v_t[i];
<a class="LN" name="554"> 554</a>	  }
<a class="LN" name="555"> 555</a>	
<a class="LN" name="556"> 556</a>	  <span class="CT">/* MATLAB Function: '&lt;S1&gt;/BodyToWorld' */</span>
<a class="LN" name="557"> 557</a>	  <span class="KW">for</span> (iU = 0; iU &lt; 36; iU++) {
<a class="LN" name="558"> 558</a>	    J[iU] = b[iU];
<a class="LN" name="559"> 559</a>	  }
<a class="LN" name="560"> 560</a>	
<a class="LN" name="561"> 561</a>	  a_idx_1 = std::cos(m_BlockIO.Integrator1[5]);
<a class="LN" name="562"> 562</a>	  T[0] = a_idx_1;
<a class="LN" name="563"> 563</a>	  a_idx_3 = std::sin(m_BlockIO.Integrator1[5]);
<a class="LN" name="564"> 564</a>	  T[3] = -a_idx_3;
<a class="LN" name="565"> 565</a>	  T[6] = 0.0;
<a class="LN" name="566"> 566</a>	  T[1] = a_idx_3;
<a class="LN" name="567"> 567</a>	  T[4] = a_idx_1;
<a class="LN" name="568"> 568</a>	  T[7] = 0.0;
<a class="LN" name="569"> 569</a>	  a_idx_1 = std::cos(m_BlockIO.Integrator1[4]);
<a class="LN" name="570"> 570</a>	  tmp_0[0] = a_idx_1;
<a class="LN" name="571"> 571</a>	  tmp_0[3] = 0.0;
<a class="LN" name="572"> 572</a>	  a_idx_3 = std::sin(m_BlockIO.Integrator1[4]);
<a class="LN" name="573"> 573</a>	  tmp_0[6] = a_idx_3;
<a class="LN" name="574"> 574</a>	  T[2] = 0.0;
<a class="LN" name="575"> 575</a>	  tmp_0[1] = 0.0;
<a class="LN" name="576"> 576</a>	  T[5] = 0.0;
<a class="LN" name="577"> 577</a>	  tmp_0[4] = 1.0;
<a class="LN" name="578"> 578</a>	  T[8] = 1.0;
<a class="LN" name="579"> 579</a>	  tmp_0[7] = 0.0;
<a class="LN" name="580"> 580</a>	  tmp_0[2] = -a_idx_3;
<a class="LN" name="581"> 581</a>	  tmp_0[5] = 0.0;
<a class="LN" name="582"> 582</a>	  tmp_0[8] = a_idx_1;
<a class="LN" name="583"> 583</a>	  <span class="KW">for</span> (iU = 0; iU &lt; 3; iU++) {
<a class="LN" name="584"> 584</a>	    <span class="KW">for</span> (i_0 = 0; i_0 &lt; 3; i_0++) {
<a class="LN" name="585"> 585</a>	      i = iU + 3 * i_0;
<a class="LN" name="586"> 586</a>	      tmp_1[i] = 0.0;
<a class="LN" name="587"> 587</a>	      tmp_1[i] += tmp_0[3 * i_0] * T[iU];
<a class="LN" name="588"> 588</a>	      tmp_1[i] += tmp_0[3 * i_0 + 1] * T[iU + 3];
<a class="LN" name="589"> 589</a>	      tmp_1[i] += tmp_0[3 * i_0 + 2] * T[iU + 6];
<a class="LN" name="590"> 590</a>	    }
<a class="LN" name="591"> 591</a>	
<a class="LN" name="592"> 592</a>	    c_0[3 * iU] = c[iU];
<a class="LN" name="593"> 593</a>	  }
<a class="LN" name="594"> 594</a>	
<a class="LN" name="595"> 595</a>	  c_0[1] = 0.0;
<a class="LN" name="596"> 596</a>	  c_tmp_0 = std::cos(m_BlockIO.Integrator1[3]);
<a class="LN" name="597"> 597</a>	  c_0[4] = c_tmp_0;
<a class="LN" name="598"> 598</a>	  c_tmp = std::sin(m_BlockIO.Integrator1[3]);
<a class="LN" name="599"> 599</a>	  c_0[7] = -c_tmp;
<a class="LN" name="600"> 600</a>	  c_0[2] = 0.0;
<a class="LN" name="601"> 601</a>	  c_0[5] = c_tmp;
<a class="LN" name="602"> 602</a>	  c_0[8] = c_tmp_0;
<a class="LN" name="603"> 603</a>	  <span class="KW">for</span> (iU = 0; iU &lt; 3; iU++) {
<a class="LN" name="604"> 604</a>	    <span class="KW">for</span> (i_0 = 0; i_0 &lt; 3; i_0++) {
<a class="LN" name="605"> 605</a>	      i = i_0 + 6 * iU;
<a class="LN" name="606"> 606</a>	      J[i] = 0.0;
<a class="LN" name="607"> 607</a>	      J[i] += c_0[3 * iU] * tmp_1[i_0];
<a class="LN" name="608"> 608</a>	      J[i] += c_0[3 * iU + 1] * tmp_1[i_0 + 3];
<a class="LN" name="609"> 609</a>	      J[i] += c_0[3 * iU + 2] * tmp_1[i_0 + 6];
<a class="LN" name="610"> 610</a>	    }
<a class="LN" name="611"> 611</a>	  }
<a class="LN" name="612"> 612</a>	
<a class="LN" name="613"> 613</a>	  memset(&amp;T[0], 0, 9U * sizeof(real_T));
<a class="LN" name="614"> 614</a>	  T[0] = 1.0;
<a class="LN" name="615"> 615</a>	  T[4] = 1.0;
<a class="LN" name="616"> 616</a>	  T[8] = 1.0;
<a class="LN" name="617"> 617</a>	  <span class="KW">if</span> (a_idx_1 != 0.0) {
<a class="LN" name="618"> 618</a>	    a_0 = 1.0 / a_idx_1;
<a class="LN" name="619"> 619</a>	    T[0] = a_0 * a_idx_1;
<a class="LN" name="620"> 620</a>	    T[3] = c_tmp * a_idx_3 * a_0;
<a class="LN" name="621"> 621</a>	    T[6] = c_tmp_0 * a_idx_3 * a_0;
<a class="LN" name="622"> 622</a>	    T[1] = a_0 * 0.0;
<a class="LN" name="623"> 623</a>	    T[4] = c_tmp_0 * a_idx_1 * a_0;
<a class="LN" name="624"> 624</a>	    T[7] = -c_tmp * a_idx_1 * a_0;
<a class="LN" name="625"> 625</a>	    T[2] = a_0 * 0.0;
<a class="LN" name="626"> 626</a>	    T[5] = a_0 * c_tmp;
<a class="LN" name="627"> 627</a>	    T[8] = a_0 * c_tmp_0;
<a class="LN" name="628"> 628</a>	  }
<a class="LN" name="629"> 629</a>	
<a class="LN" name="630"> 630</a>	  <span class="KW">for</span> (iU = 0; iU &lt; 3; iU++) {
<a class="LN" name="631"> 631</a>	    i = 6 * (3 + iU);
<a class="LN" name="632"> 632</a>	    J[3 + i] = T[3 * iU];
<a class="LN" name="633"> 633</a>	    J[4 + i] = T[3 * iU + 1];
<a class="LN" name="634"> 634</a>	    J[5 + i] = T[3 * iU + 2];
<a class="LN" name="635"> 635</a>	  }
<a class="LN" name="636"> 636</a>	
<a class="LN" name="637"> 637</a>	  <span class="KW">for</span> (iU = 0; iU &lt; 6; iU++) {
<a class="LN" name="638"> 638</a>	    m_BlockIO.eta_t[iU] = 0.0;
<a class="LN" name="639"> 639</a>	    <span class="KW">for</span> (i_0 = 0; i_0 &lt; 6; i_0++) {
<a class="LN" name="640"> 640</a>	      m_BlockIO.eta_t[iU] += J[6 * i_0 + iU] *
<a class="LN" name="641"> 641</a>	        m_BlockIO.Integrator[i_0];
<a class="LN" name="642"> 642</a>	    }
<a class="LN" name="643"> 643</a>	  }
<a class="LN" name="644"> 644</a>	
<a class="LN" name="645"> 645</a>	  <span class="CT">/* End of MATLAB Function: '&lt;S1&gt;/BodyToWorld' */</span>
<a class="LN" name="646"> 646</a>	  <span class="KW">if</span> (rtmIsMajorTimeStep((&amp;m_SimStruct)) &amp;&amp;
<a class="LN" name="647"> 647</a>	      (&amp;m_SimStruct)-&gt;Timing.TaskCounters.TID[1] == 0) {
<a class="LN" name="648"> 648</a>	    <span class="CT">/* UnitDelay: '&lt;S53&gt;/Delay Input1' */</span>
<a class="LN" name="649"> 649</a>	    m_BlockIO.Uk1 = m_DWork.DelayInput1_DSTATE;
<a class="LN" name="650"> 650</a>	  }
<a class="LN" name="651"> 651</a>	
<a class="LN" name="652"> 652</a>	  <span class="CT">/* RelationalOperator: '&lt;S55&gt;/Compare' incorporates:
<a class="LN" name="653"> 653</a>	   *  Constant: '&lt;S55&gt;/Constant'
<a class="LN" name="654"> 654</a>	   *  Inport: '&lt;Root&gt;/bReset'
<a class="LN" name="655"> 655</a>	   */</span>
<a class="LN" name="656"> 656</a>	  m_BlockIO.Compare = (static_cast&lt;int32_T&gt;(m_Input.bReset) &gt;
<a class="LN" name="657"> 657</a>	    static_cast&lt;int32_T&gt;(m_ModelParameters.Constant_Value_l));
<a class="LN" name="658"> 658</a>	
<a class="LN" name="659"> 659</a>	  <span class="CT">/* RelationalOperator: '&lt;S53&gt;/FixPt Relational Operator' */</span>
<a class="LN" name="660"> 660</a>	  m_BlockIO.FixPtRelationalOperator = (static_cast&lt;int32_T&gt;
<a class="LN" name="661"> 661</a>	    (m_BlockIO.Compare) &gt; static_cast&lt;int32_T&gt;(m_BlockIO.Uk1));
<a class="LN" name="662"> 662</a>	  <span class="KW">for</span> (i = 0; i &lt; 6; i++) {
<a class="LN" name="663"> 663</a>	    <span class="CT">/* Switch: '&lt;S5&gt;/Switch1' incorporates:
<a class="LN" name="664"> 664</a>	     *  Constant: '&lt;S5&gt;/Constant'
<a class="LN" name="665"> 665</a>	     */</span>
<a class="LN" name="666"> 666</a>	    <span class="KW">if</span> (m_BlockIO.FixPtRelationalOperator) {
<a class="LN" name="667"> 667</a>	      m_BlockIO.Switch1[i] = m_ModelParameters.Constant_Value[i];
<a class="LN" name="668"> 668</a>	    } <span class="KW">else</span> {
<a class="LN" name="669"> 669</a>	      <span class="CT">/* Abs: '&lt;S5&gt;/Abs2' */</span>
<a class="LN" name="670"> 670</a>	      m_BlockIO.Divide[i] = std::abs(m_BlockIO.Product[i]);
<a class="LN" name="671"> 671</a>	
<a class="LN" name="672"> 672</a>	      <span class="CT">/* RelationalOperator: '&lt;S5&gt;/Relational Operator' */</span>
<a class="LN" name="673"> 673</a>	      m_BlockIO.RelationalOperator[i] = (m_BlockIO.Divide[i] &gt;=
<a class="LN" name="674"> 674</a>	        m_BlockIO.Abs1[i]);
<a class="LN" name="675"> 675</a>	
<a class="LN" name="676"> 676</a>	      <span class="CT">/* Abs: '&lt;S5&gt;/Abs' */</span>
<a class="LN" name="677"> 677</a>	      m_BlockIO.Divide[i] = std::abs(m_BlockIO.Integrator1[i]);
<a class="LN" name="678"> 678</a>	
<a class="LN" name="679"> 679</a>	      <span class="CT">/* Saturate: '&lt;S5&gt;/Saturation' */</span>
<a class="LN" name="680"> 680</a>	      <span class="KW">if</span> (m_BlockIO.Divide[i] &gt; m_ModelParameters.Saturation_UpperSat) {
<a class="LN" name="681"> 681</a>	        m_BlockIO.Divide[i] = m_ModelParameters.Saturation_UpperSat;
<a class="LN" name="682"> 682</a>	      } <span class="KW">else</span> {
<a class="LN" name="683"> 683</a>	        <span class="KW">if</span> (m_BlockIO.Divide[i] &lt; m_ModelParameters.Saturation_LowerSat) {
<a class="LN" name="684"> 684</a>	          m_BlockIO.Divide[i] = m_ModelParameters.Saturation_LowerSat;
<a class="LN" name="685"> 685</a>	        }
<a class="LN" name="686"> 686</a>	      }
<a class="LN" name="687"> 687</a>	
<a class="LN" name="688"> 688</a>	      <span class="CT">/* End of Saturate: '&lt;S5&gt;/Saturation' */</span>
<a class="LN" name="689"> 689</a>	
<a class="LN" name="690"> 690</a>	      <span class="CT">/* Product: '&lt;S5&gt;/Divide' */</span>
<a class="LN" name="691"> 691</a>	      m_BlockIO.Divide[i] = m_BlockIO.Abs1[i] /
<a class="LN" name="692"> 692</a>	        m_BlockIO.Divide[i];
<a class="LN" name="693"> 693</a>	
<a class="LN" name="694"> 694</a>	      <span class="CT">/* Switch: '&lt;S5&gt;/Switch' */</span>
<a class="LN" name="695"> 695</a>	      <span class="KW">if</span> (m_BlockIO.RelationalOperator[i]) {
<a class="LN" name="696"> 696</a>	        m_BlockIO.Switch[i] = m_BlockIO.Divide[i];
<a class="LN" name="697"> 697</a>	      } <span class="KW">else</span> {
<a class="LN" name="698"> 698</a>	        m_BlockIO.Switch[i] = m_BlockIO.UnitDelay[i];
<a class="LN" name="699"> 699</a>	      }
<a class="LN" name="700"> 700</a>	
<a class="LN" name="701"> 701</a>	      <span class="CT">/* End of Switch: '&lt;S5&gt;/Switch' */</span>
<a class="LN" name="702"> 702</a>	      m_BlockIO.Switch1[i] = m_BlockIO.Switch[i];
<a class="LN" name="703"> 703</a>	    }
<a class="LN" name="704"> 704</a>	
<a class="LN" name="705"> 705</a>	    <span class="CT">/* End of Switch: '&lt;S5&gt;/Switch1' */</span>
<a class="LN" name="706"> 706</a>	  }
<a class="LN" name="707"> 707</a>	
<a class="LN" name="708"> 708</a>	  <span class="KW">if</span> (rtmIsMajorTimeStep((&amp;m_SimStruct)) &amp;&amp;
<a class="LN" name="709"> 709</a>	      (&amp;m_SimStruct)-&gt;Timing.TaskCounters.TID[2] == 0) {
<a class="LN" name="710"> 710</a>	    <span class="CT">/* Product: '&lt;S8&gt;/Product' */</span>
<a class="LN" name="711"> 711</a>	    <span class="KW">for</span> (iU = 0; iU &lt; 12; iU++) {
<a class="LN" name="712"> 712</a>	      m_BlockIO.Bu[iU] = 0.0;
<a class="LN" name="713"> 713</a>	      <span class="KW">for</span> (i_0 = 0; i_0 &lt; 6; i_0++) {
<a class="LN" name="714"> 714</a>	        m_BlockIO.Bu[iU] += m_BlockIO.B[12 * i_0 + iU] *
<a class="LN" name="715"> 715</a>	          m_BlockIO.RandomSequence[i_0];
<a class="LN" name="716"> 716</a>	      }
<a class="LN" name="717"> 717</a>	    }
<a class="LN" name="718"> 718</a>	
<a class="LN" name="719"> 719</a>	    <span class="CT">/* End of Product: '&lt;S8&gt;/Product' */</span>
<a class="LN" name="720"> 720</a>	  }
<a class="LN" name="721"> 721</a>	
<a class="LN" name="722"> 722</a>	  <span class="KW">for</span> (i = 0; i &lt; 12; i++) {
<a class="LN" name="723"> 723</a>	    <span class="CT">/* Product: '&lt;S8&gt;/Product1' */</span>
<a class="LN" name="724"> 724</a>	    m_BlockIO.Ax[i] = 0.0;
<a class="LN" name="725"> 725</a>	    <span class="KW">for</span> (iU = 0; iU &lt; 12; iU++) {
<a class="LN" name="726"> 726</a>	      m_BlockIO.Ax[i] += m_BlockIO.A[12 * iU + i] *
<a class="LN" name="727"> 727</a>	        m_BlockIO.x[iU];
<a class="LN" name="728"> 728</a>	    }
<a class="LN" name="729"> 729</a>	
<a class="LN" name="730"> 730</a>	    <span class="CT">/* End of Product: '&lt;S8&gt;/Product1' */</span>
<a class="LN" name="731"> 731</a>	
<a class="LN" name="732"> 732</a>	    <span class="CT">/* Sum: '&lt;S8&gt;/Sum' */</span>
<a class="LN" name="733"> 733</a>	    m_BlockIO.dx[i] = m_BlockIO.Bu[i] + m_BlockIO.Ax[i];
<a class="LN" name="734"> 734</a>	  }
<a class="LN" name="735"> 735</a>	}
<a class="LN" name="736"> 736</a>	
<a class="LN" name="737"> 737</a>	void CHydroSimulator::HydroSimulator_update (void)
<a class="LN" name="738"> 738</a>	{
<a class="LN" name="739"> 739</a>	  int32_T i;
<a class="LN" name="740"> 740</a>	  <span class="KW">if</span> (rtmIsMajorTimeStep((&amp;m_SimStruct)) &amp;&amp;
<a class="LN" name="741"> 741</a>	      (&amp;m_SimStruct)-&gt;Timing.TaskCounters.TID[1] == 0) {
<a class="LN" name="742"> 742</a>	    <span class="CT">/* Update for UnitDelay: '&lt;S5&gt;/Unit Delay' */</span>
<a class="LN" name="743"> 743</a>	    <span class="KW">for</span> (i = 0; i &lt; 6; i++) {
<a class="LN" name="744"> 744</a>	      m_DWork.UnitDelay_DSTATE[i] = m_BlockIO.Switch1[i];
<a class="LN" name="745"> 745</a>	    }
<a class="LN" name="746"> 746</a>	
<a class="LN" name="747"> 747</a>	    <span class="CT">/* End of Update for UnitDelay: '&lt;S5&gt;/Unit Delay' */</span>
<a class="LN" name="748"> 748</a>	
<a class="LN" name="749"> 749</a>	    <span class="CT">/* Update for UnitDelay: '&lt;S53&gt;/Delay Input1' */</span>
<a class="LN" name="750"> 750</a>	    m_DWork.DelayInput1_DSTATE = m_BlockIO.Compare;
<a class="LN" name="751"> 751</a>	  }
<a class="LN" name="752"> 752</a>	
<a class="LN" name="753"> 753</a>	  <span class="KW">if</span> (rtmIsMajorTimeStep((&amp;m_SimStruct)) &amp;&amp;
<a class="LN" name="754"> 754</a>	      (&amp;m_SimStruct)-&gt;Timing.TaskCounters.TID[2] == 0) {
<a class="LN" name="755"> 755</a>	    <span class="CT">/* Update for RandomNumber: '&lt;S1&gt;/Random Sequence' */</span>
<a class="LN" name="756"> 756</a>	    <span class="KW">for</span> (i = 0; i &lt; 6; i++) {
<a class="LN" name="757"> 757</a>	      m_DWork.NextOutput[i] = rt_nrand_Upu32_Yd_f_pw_snf
<a class="LN" name="758"> 758</a>	        (&amp;m_DWork.RandSeed[i]) *
<a class="LN" name="759"> 759</a>	        m_ModelParameters.RandomSequence_StdDev[i] +
<a class="LN" name="760"> 760</a>	        m_ModelParameters.RandomSequence_Mean[i];
<a class="LN" name="761"> 761</a>	    }
<a class="LN" name="762"> 762</a>	
<a class="LN" name="763"> 763</a>	    <span class="CT">/* End of Update for RandomNumber: '&lt;S1&gt;/Random Sequence' */</span>
<a class="LN" name="764"> 764</a>	  }
<a class="LN" name="765"> 765</a>	
<a class="LN" name="766"> 766</a>	  <span class="KW">if</span> (rtmIsMajorTimeStep((&amp;m_SimStruct))) {
<a class="LN" name="767"> 767</a>	    rt_ertODEUpdateContinuousStates(&amp;(&amp;m_SimStruct)-&gt;solverInfo);
<a class="LN" name="768"> 768</a>	  }
<a class="LN" name="769"> 769</a>	
<a class="LN" name="770"> 770</a>	  <span class="CT">/* Update absolute time for base rate */</span>
<a class="LN" name="771"> 771</a>	  <span class="CT">/* The "clockTick0" counts the number of times the code of this task has
<a class="LN" name="772"> 772</a>	   * been executed. The absolute time is the multiplication of "clockTick0"
<a class="LN" name="773"> 773</a>	   * and "Timing.stepSize0". Size of "clockTick0" ensures timer will not
<a class="LN" name="774"> 774</a>	   * overflow during the application lifespan selected.
<a class="LN" name="775"> 775</a>	   * Timer of this task consists of two 32 bit unsigned integers.
<a class="LN" name="776"> 776</a>	   * The two integers represent the low bits Timing.clockTick0 and the high bits
<a class="LN" name="777"> 777</a>	   * Timing.clockTickH0. When the low bit overflows to 0, the high bits increment.
<a class="LN" name="778"> 778</a>	   */</span>
<a class="LN" name="779"> 779</a>	  <span class="KW">if</span> (!(++(&amp;m_SimStruct)-&gt;Timing.clockTick0)) {
<a class="LN" name="780"> 780</a>	    ++(&amp;m_SimStruct)-&gt;Timing.clockTickH0;
<a class="LN" name="781"> 781</a>	  }
<a class="LN" name="782"> 782</a>	
<a class="LN" name="783"> 783</a>	  (&amp;m_SimStruct)-&gt;Timing.t[0] = rtsiGetSolverStopTime
<a class="LN" name="784"> 784</a>	    (&amp;(&amp;m_SimStruct)-&gt;solverInfo);
<a class="LN" name="785"> 785</a>	
<a class="LN" name="786"> 786</a>	  {
<a class="LN" name="787"> 787</a>	    <span class="CT">/* Update absolute timer for sample time: [0.005s, 0.0s] */</span>
<a class="LN" name="788"> 788</a>	    <span class="CT">/* The "clockTick1" counts the number of times the code of this task has
<a class="LN" name="789"> 789</a>	     * been executed. The absolute time is the multiplication of "clockTick1"
<a class="LN" name="790"> 790</a>	     * and "Timing.stepSize1". Size of "clockTick1" ensures timer will not
<a class="LN" name="791"> 791</a>	     * overflow during the application lifespan selected.
<a class="LN" name="792"> 792</a>	     * Timer of this task consists of two 32 bit unsigned integers.
<a class="LN" name="793"> 793</a>	     * The two integers represent the low bits Timing.clockTick1 and the high bits
<a class="LN" name="794"> 794</a>	     * Timing.clockTickH1. When the low bit overflows to 0, the high bits increment.
<a class="LN" name="795"> 795</a>	     */</span>
<a class="LN" name="796"> 796</a>	    <span class="KW">if</span> (!(++(&amp;m_SimStruct)-&gt;Timing.clockTick1)) {
<a class="LN" name="797"> 797</a>	      ++(&amp;m_SimStruct)-&gt;Timing.clockTickH1;
<a class="LN" name="798"> 798</a>	    }
<a class="LN" name="799"> 799</a>	
<a class="LN" name="800"> 800</a>	    (&amp;m_SimStruct)-&gt;Timing.t[1] = (&amp;m_SimStruct)-&gt;Timing.clockTick1 *
<a class="LN" name="801"> 801</a>	      (&amp;m_SimStruct)-&gt;Timing.stepSize1 + (&amp;m_SimStruct)-&gt;Timing.clockTickH1 *
<a class="LN" name="802"> 802</a>	      (&amp;m_SimStruct)-&gt;Timing.stepSize1 * 4294967296.0;
<a class="LN" name="803"> 803</a>	  }
<a class="LN" name="804"> 804</a>	
<a class="LN" name="805"> 805</a>	  <span class="KW">if</span> (rtmIsMajorTimeStep((&amp;m_SimStruct)) &amp;&amp;
<a class="LN" name="806"> 806</a>	      (&amp;m_SimStruct)-&gt;Timing.TaskCounters.TID[2] == 0) {
<a class="LN" name="807"> 807</a>	    <span class="CT">/* Update absolute timer for sample time: [0.01s, 0.0s] */</span>
<a class="LN" name="808"> 808</a>	    <span class="CT">/* The "clockTick2" counts the number of times the code of this task has
<a class="LN" name="809"> 809</a>	     * been executed. The absolute time is the multiplication of "clockTick2"
<a class="LN" name="810"> 810</a>	     * and "Timing.stepSize2". Size of "clockTick2" ensures timer will not
<a class="LN" name="811"> 811</a>	     * overflow during the application lifespan selected.
<a class="LN" name="812"> 812</a>	     * Timer of this task consists of two 32 bit unsigned integers.
<a class="LN" name="813"> 813</a>	     * The two integers represent the low bits Timing.clockTick2 and the high bits
<a class="LN" name="814"> 814</a>	     * Timing.clockTickH2. When the low bit overflows to 0, the high bits increment.
<a class="LN" name="815"> 815</a>	     */</span>
<a class="LN" name="816"> 816</a>	    <span class="KW">if</span> (!(++(&amp;m_SimStruct)-&gt;Timing.clockTick2)) {
<a class="LN" name="817"> 817</a>	      ++(&amp;m_SimStruct)-&gt;Timing.clockTickH2;
<a class="LN" name="818"> 818</a>	    }
<a class="LN" name="819"> 819</a>	
<a class="LN" name="820"> 820</a>	    (&amp;m_SimStruct)-&gt;Timing.t[2] = (&amp;m_SimStruct)-&gt;Timing.clockTick2 *
<a class="LN" name="821"> 821</a>	      (&amp;m_SimStruct)-&gt;Timing.stepSize2 + (&amp;m_SimStruct)-&gt;Timing.clockTickH2 *
<a class="LN" name="822"> 822</a>	      (&amp;m_SimStruct)-&gt;Timing.stepSize2 * 4294967296.0;
<a class="LN" name="823"> 823</a>	  }
<a class="LN" name="824"> 824</a>	
<a class="LN" name="825"> 825</a>	  <span class="KW">if</span> (rtmIsMajorTimeStep((&amp;m_SimStruct)) &amp;&amp;
<a class="LN" name="826"> 826</a>	      (&amp;m_SimStruct)-&gt;Timing.TaskCounters.TID[3] == 0) {
<a class="LN" name="827"> 827</a>	    <span class="CT">/* Update absolute timer for sample time: [1.0s, 0.0s] */</span>
<a class="LN" name="828"> 828</a>	    <span class="CT">/* The "clockTick3" counts the number of times the code of this task has
<a class="LN" name="829"> 829</a>	     * been executed. The absolute time is the multiplication of "clockTick3"
<a class="LN" name="830"> 830</a>	     * and "Timing.stepSize3". Size of "clockTick3" ensures timer will not
<a class="LN" name="831"> 831</a>	     * overflow during the application lifespan selected.
<a class="LN" name="832"> 832</a>	     * Timer of this task consists of two 32 bit unsigned integers.
<a class="LN" name="833"> 833</a>	     * The two integers represent the low bits Timing.clockTick3 and the high bits
<a class="LN" name="834"> 834</a>	     * Timing.clockTickH3. When the low bit overflows to 0, the high bits increment.
<a class="LN" name="835"> 835</a>	     */</span>
<a class="LN" name="836"> 836</a>	    <span class="KW">if</span> (!(++(&amp;m_SimStruct)-&gt;Timing.clockTick3)) {
<a class="LN" name="837"> 837</a>	      ++(&amp;m_SimStruct)-&gt;Timing.clockTickH3;
<a class="LN" name="838"> 838</a>	    }
<a class="LN" name="839"> 839</a>	
<a class="LN" name="840"> 840</a>	    (&amp;m_SimStruct)-&gt;Timing.t[3] = (&amp;m_SimStruct)-&gt;Timing.clockTick3 *
<a class="LN" name="841"> 841</a>	      (&amp;m_SimStruct)-&gt;Timing.stepSize3 + (&amp;m_SimStruct)-&gt;Timing.clockTickH3 *
<a class="LN" name="842"> 842</a>	      (&amp;m_SimStruct)-&gt;Timing.stepSize3 * 4294967296.0;
<a class="LN" name="843"> 843</a>	  }
<a class="LN" name="844"> 844</a>	
<a class="LN" name="845"> 845</a>	  rate_scheduler();
<a class="LN" name="846"> 846</a>	}
<a class="LN" name="847"> 847</a>	
<a class="LN" name="848"> 848</a>	void CHydroSimulator::HydroSimulator_derivatives (void)
<a class="LN" name="849"> 849</a>	{
<a class="LN" name="850"> 850</a>	  int32_T i;
<a class="LN" name="851"> 851</a>	  XDot_HydroSimulator_T *_rtXdot;
<a class="LN" name="852"> 852</a>	  _rtXdot = ((XDot_HydroSimulator_T *) (&amp;m_SimStruct)-&gt;derivs);
<a class="LN" name="853"> 853</a>	  <span class="KW">for</span> (i = 0; i &lt; 6; i++) {
<a class="LN" name="854"> 854</a>	    <span class="CT">/* Derivatives for Integrator: '&lt;S1&gt;/Integrator1' */</span>
<a class="LN" name="855"> 855</a>	    _rtXdot-&gt;Integrator1_CSTATE[i] = m_BlockIO.eta_t[i];
<a class="LN" name="856"> 856</a>	
<a class="LN" name="857"> 857</a>	    <span class="CT">/* Derivatives for Integrator: '&lt;S1&gt;/Integrator' */</span>
<a class="LN" name="858"> 858</a>	    _rtXdot-&gt;Integrator_CSTATE[i] = m_BlockIO.v_t[i];
<a class="LN" name="859"> 859</a>	  }
<a class="LN" name="860"> 860</a>	
<a class="LN" name="861"> 861</a>	  <span class="CT">/* Derivatives for Integrator: '&lt;S8&gt;/Integrator' */</span>
<a class="LN" name="862"> 862</a>	  memcpy(&amp;_rtXdot-&gt;Integrator_CSTATE_f[0], &amp;m_BlockIO.dx[0], 12U * sizeof
<a class="LN" name="863"> 863</a>	         (real_T));
<a class="LN" name="864"> 864</a>	
<a class="LN" name="865"> 865</a>	  <span class="CT">/* Derivatives for Integrator: '&lt;S33&gt;/Filter' */</span>
<a class="LN" name="866"> 866</a>	  <span class="KW">for</span> (i = 0; i &lt; 6; i++) {
<a class="LN" name="867"> 867</a>	    _rtXdot-&gt;Filter_CSTATE[i] = m_BlockIO.NProdOut[i];
<a class="LN" name="868"> 868</a>	  }
<a class="LN" name="869"> 869</a>	
<a class="LN" name="870"> 870</a>	  <span class="CT">/* End of Derivatives for Integrator: '&lt;S33&gt;/Filter' */</span>
<a class="LN" name="871"> 871</a>	}
<a class="LN" name="872"> 872</a>	
<a class="LN" name="873"> 873</a>	void CHydroSimulator::HydroSimulator_initialize (void)
<a class="LN" name="874"> 874</a>	{
<a class="LN" name="875"> 875</a>	  {
<a class="LN" name="876"> 876</a>	    uint32_T tseed;
<a class="LN" name="877"> 877</a>	    int32_T r;
<a class="LN" name="878"> 878</a>	    int32_T t;
<a class="LN" name="879"> 879</a>	    int32_T i;
<a class="LN" name="880"> 880</a>	    real_T tmp;
<a class="LN" name="881"> 881</a>	    <span class="KW">for</span> (i = 0; i &lt; 6; i++) {
<a class="LN" name="882"> 882</a>	      <span class="CT">/* InitializeConditions for UnitDelay: '&lt;S5&gt;/Unit Delay' */</span>
<a class="LN" name="883"> 883</a>	      m_DWork.UnitDelay_DSTATE[i] =
<a class="LN" name="884"> 884</a>	        m_ModelParameters.UnitDelay_InitialCondition;
<a class="LN" name="885"> 885</a>	
<a class="LN" name="886"> 886</a>	      <span class="CT">/* InitializeConditions for Integrator: '&lt;S1&gt;/Integrator1' */</span>
<a class="LN" name="887"> 887</a>	      m_ContState.Integrator1_CSTATE[i] = m_ModelParameters.Integrator1_IC[i];
<a class="LN" name="888"> 888</a>	
<a class="LN" name="889"> 889</a>	      <span class="CT">/* InitializeConditions for Integrator: '&lt;S1&gt;/Integrator' */</span>
<a class="LN" name="890"> 890</a>	      m_ContState.Integrator_CSTATE[i] = m_ModelParameters.Integrator_IC[i];
<a class="LN" name="891"> 891</a>	    }
<a class="LN" name="892"> 892</a>	
<a class="LN" name="893"> 893</a>	    <span class="CT">/* InitializeConditions for Integrator: '&lt;S8&gt;/Integrator' */</span>
<a class="LN" name="894"> 894</a>	    memcpy(&amp;m_ContState.Integrator_CSTATE_f[0],
<a class="LN" name="895"> 895</a>	           &amp;m_ModelParameters.Integrator_IC_k[0], 12U * sizeof(real_T));
<a class="LN" name="896"> 896</a>	    <span class="KW">for</span> (i = 0; i &lt; 6; i++) {
<a class="LN" name="897"> 897</a>	      <span class="CT">/* InitializeConditions for RandomNumber: '&lt;S1&gt;/Random Sequence' */</span>
<a class="LN" name="898"> 898</a>	      tmp = std::floor(m_ModelParameters.RandomSequence_Seed[i]);
<a class="LN" name="899"> 899</a>	      <span class="KW">if</span> (rtIsNaN(tmp) || rtIsInf(tmp)) {
<a class="LN" name="900"> 900</a>	        tmp = 0.0;
<a class="LN" name="901"> 901</a>	      } <span class="KW">else</span> {
<a class="LN" name="902"> 902</a>	        tmp = std::fmod(tmp, 4.294967296E+9);
<a class="LN" name="903"> 903</a>	      }
<a class="LN" name="904"> 904</a>	
<a class="LN" name="905"> 905</a>	      tseed = tmp &lt; 0.0 ? static_cast&lt;uint32_T&gt;(-static_cast&lt;int32_T&gt;
<a class="LN" name="906"> 906</a>	        (static_cast&lt;uint32_T&gt;(-tmp))) : static_cast&lt;uint32_T&gt;(tmp);
<a class="LN" name="907"> 907</a>	      r = static_cast&lt;int32_T&gt;((tseed &gt;&gt; 16U));
<a class="LN" name="908"> 908</a>	      t = static_cast&lt;int32_T&gt;((tseed &amp; 32768U));
<a class="LN" name="909"> 909</a>	      tseed = ((((tseed - (static_cast&lt;uint32_T&gt;(r) &lt;&lt; 16U)) + t) &lt;&lt; 16U) + t) +
<a class="LN" name="910"> 910</a>	        r;
<a class="LN" name="911"> 911</a>	      <span class="KW">if</span> (tseed &lt; 1U) {
<a class="LN" name="912"> 912</a>	        tseed = 1144108930U;
<a class="LN" name="913"> 913</a>	      } <span class="KW">else</span> {
<a class="LN" name="914"> 914</a>	        <span class="KW">if</span> (tseed &gt; 2147483646U) {
<a class="LN" name="915"> 915</a>	          tseed = 2147483646U;
<a class="LN" name="916"> 916</a>	        }
<a class="LN" name="917"> 917</a>	      }
<a class="LN" name="918"> 918</a>	
<a class="LN" name="919"> 919</a>	      m_DWork.RandSeed[i] = tseed;
<a class="LN" name="920"> 920</a>	      m_DWork.NextOutput[i] = rt_nrand_Upu32_Yd_f_pw_snf
<a class="LN" name="921"> 921</a>	        (&amp;m_DWork.RandSeed[i]) *
<a class="LN" name="922"> 922</a>	        m_ModelParameters.RandomSequence_StdDev[i] +
<a class="LN" name="923"> 923</a>	        m_ModelParameters.RandomSequence_Mean[i];
<a class="LN" name="924"> 924</a>	
<a class="LN" name="925"> 925</a>	      <span class="CT">/* End of InitializeConditions for RandomNumber: '&lt;S1&gt;/Random Sequence' */</span>
<a class="LN" name="926"> 926</a>	
<a class="LN" name="927"> 927</a>	      <span class="CT">/* InitializeConditions for Integrator: '&lt;S33&gt;/Filter' */</span>
<a class="LN" name="928"> 928</a>	      m_ContState.Filter_CSTATE[i] =
<a class="LN" name="929"> 929</a>	        m_ModelParameters.DPController_InitialConditionFo;
<a class="LN" name="930"> 930</a>	    }
<a class="LN" name="931"> 931</a>	
<a class="LN" name="932"> 932</a>	    <span class="CT">/* InitializeConditions for UnitDelay: '&lt;S53&gt;/Delay Input1' */</span>
<a class="LN" name="933"> 933</a>	    m_DWork.DelayInput1_DSTATE =
<a class="LN" name="934"> 934</a>	      m_ModelParameters.DetectRisePositive_vinit;
<a class="LN" name="935"> 935</a>	  }
<a class="LN" name="936"> 936</a>	}
<a class="LN" name="937"> 937</a>	
<a class="LN" name="938"> 938</a>	void CHydroSimulator::HydroSimulator_terminate (void)
<a class="LN" name="939"> 939</a>	{
<a class="LN" name="940"> 940</a>	  <span class="CT">/* (no terminate code required) */</span>
<a class="LN" name="941"> 941</a>	}
<a class="LN" name="942"> 942</a>	
<a class="LN" name="943"> 943</a>	void CHydroSimulator::rt_ODECreateIntegrationData (RTWSolverInfo *si)
<a class="LN" name="944"> 944</a>	{
<a class="LN" name="945"> 945</a>	  UNUSED_PARAMETER(si);
<a class="LN" name="946"> 946</a>	  return;
<a class="LN" name="947"> 947</a>	}                                      <span class="CT">/* do nothing */</span>
<a class="LN" name="948"> 948</a>	
<a class="LN" name="949"> 949</a>	void CHydroSimulator::rt_ODEDestroyIntegrationData (RTWSolverInfo *si)
<a class="LN" name="950"> 950</a>	{
<a class="LN" name="951"> 951</a>	  UNUSED_PARAMETER(si);
<a class="LN" name="952"> 952</a>	  return;
<a class="LN" name="953"> 953</a>	}                                      <span class="CT">/* do nothing */</span>
<a class="LN" name="954"> 954</a>	
<a class="LN" name="955"> 955</a>	void CHydroSimulator::rt_ODEUpdateContinuousStates (RTWSolverInfo *si)
<a class="LN" name="956"> 956</a>	{
<a class="LN" name="957"> 957</a>	  UNUSED_PARAMETER(si);
<a class="LN" name="958"> 958</a>	  return;
<a class="LN" name="959"> 959</a>	}                                      <span class="CT">/* do nothing */</span>
<a class="LN" name="960"> 960</a>	
<a class="LN" name="961"> 961</a>	void CHydroSimulator::MdlOutputs (int_T tid)
<a class="LN" name="962"> 962</a>	{
<a class="LN" name="963"> 963</a>	  HydroSimulator_output();
<a class="LN" name="964"> 964</a>	  UNUSED_PARAMETER(tid);
<a class="LN" name="965"> 965</a>	}
<a class="LN" name="966"> 966</a>	
<a class="LN" name="967"> 967</a>	void CHydroSimulator::MdlUpdate (int_T tid)
<a class="LN" name="968"> 968</a>	{
<a class="LN" name="969"> 969</a>	  HydroSimulator_update();
<a class="LN" name="970"> 970</a>	  UNUSED_PARAMETER(tid);
<a class="LN" name="971"> 971</a>	}
<a class="LN" name="972"> 972</a>	
<a class="LN" name="973"> 973</a>	void CHydroSimulator::MdlInitializeSizes (void)
<a class="LN" name="974"> 974</a>	{
<a class="LN" name="975"> 975</a>	}
<a class="LN" name="976"> 976</a>	
<a class="LN" name="977"> 977</a>	void CHydroSimulator::MdlInitializeSampleTimes (void)
<a class="LN" name="978"> 978</a>	{
<a class="LN" name="979"> 979</a>	}
<a class="LN" name="980"> 980</a>	
<a class="LN" name="981"> 981</a>	void CHydroSimulator::MdlInitialize (void)
<a class="LN" name="982"> 982</a>	{
<a class="LN" name="983"> 983</a>	}
<a class="LN" name="984"> 984</a>	
<a class="LN" name="985"> 985</a>	void CHydroSimulator::MdlStart (void)
<a class="LN" name="986"> 986</a>	{
<a class="LN" name="987"> 987</a>	  HydroSimulator_initialize();
<a class="LN" name="988"> 988</a>	}
<a class="LN" name="989"> 989</a>	
<a class="LN" name="990"> 990</a>	void CHydroSimulator::MdlTerminate (void)
<a class="LN" name="991"> 991</a>	{
<a class="LN" name="992"> 992</a>	  HydroSimulator_terminate();
<a class="LN" name="993"> 993</a>	}
<a class="LN" name="994"> 994</a>	
<a class="LN" name="995"> 995</a>	RT_MODEL_HydroSimulator_T* CHydroSimulator::HydroSimulator (void)
<a class="LN" name="996"> 996</a>	{
<a class="LN" name="997"> 997</a>	  <span class="CT">/* Registration code */</span>
<a class="LN" name="998"> 998</a>	
<a class="LN" name="999"> 999</a>	  <span class="CT">/* initialize non-finites */</span>
<a class="LN" name="1000"> 1000</a>	  rt_InitInfAndNaN(sizeof(real_T));
<a class="LN" name="1001"> 1001</a>	
<a class="LN" name="1002"> 1002</a>	  <span class="CT">/* non-finite (run-time) assignments */</span>
<a class="LN" name="1003"> 1003</a>	  m_ModelParameters.Saturation_UpperSat = rtInf;
<a class="LN" name="1004"> 1004</a>	
<a class="LN" name="1005"> 1005</a>	  <span class="CT">/* initialize real-time model */</span>
<a class="LN" name="1006"> 1006</a>	
<a class="LN" name="1007"> 1007</a>	
<a class="LN" name="1008"> 1008</a>	
<a class="LN" name="1009"> 1009</a>	  {
<a class="LN" name="1010"> 1010</a>	    <span class="CT">/* Setup solver object */</span>
<a class="LN" name="1011"> 1011</a>	    rtsiSetSimTimeStepPtr(&amp;(&amp;m_SimStruct)-&gt;solverInfo,
<a class="LN" name="1012"> 1012</a>	                          &amp;(&amp;m_SimStruct)-&gt;Timing.simTimeStep);
<a class="LN" name="1013"> 1013</a>	    rtsiSetTPtr(&amp;(&amp;m_SimStruct)-&gt;solverInfo, &amp;rtmGetTPtr((&amp;m_SimStruct)));
<a class="LN" name="1014"> 1014</a>	    rtsiSetStepSizePtr(&amp;(&amp;m_SimStruct)-&gt;solverInfo,
<a class="LN" name="1015"> 1015</a>	                       &amp;(&amp;m_SimStruct)-&gt;Timing.stepSize0);
<a class="LN" name="1016"> 1016</a>	    rtsiSetdXPtr(&amp;(&amp;m_SimStruct)-&gt;solverInfo, &amp;(&amp;m_SimStruct)-&gt;derivs);
<a class="LN" name="1017"> 1017</a>	    rtsiSetContStatesPtr(&amp;(&amp;m_SimStruct)-&gt;solverInfo, (real_T **)
<a class="LN" name="1018"> 1018</a>	                         &amp;(&amp;m_SimStruct)-&gt;contStates);
<a class="LN" name="1019"> 1019</a>	    rtsiSetNumContStatesPtr(&amp;(&amp;m_SimStruct)-&gt;solverInfo,
<a class="LN" name="1020"> 1020</a>	      &amp;(&amp;m_SimStruct)-&gt;Sizes.numContStates);
<a class="LN" name="1021"> 1021</a>	    rtsiSetNumPeriodicContStatesPtr(&amp;(&amp;m_SimStruct)-&gt;solverInfo,
<a class="LN" name="1022"> 1022</a>	      &amp;(&amp;m_SimStruct)-&gt;Sizes.numPeriodicContStates);
<a class="LN" name="1023"> 1023</a>	    rtsiSetPeriodicContStateIndicesPtr(&amp;(&amp;m_SimStruct)-&gt;solverInfo,
<a class="LN" name="1024"> 1024</a>	      &amp;(&amp;m_SimStruct)-&gt;periodicContStateIndices);
<a class="LN" name="1025"> 1025</a>	    rtsiSetPeriodicContStateRangesPtr(&amp;(&amp;m_SimStruct)-&gt;solverInfo,
<a class="LN" name="1026"> 1026</a>	      &amp;(&amp;m_SimStruct)-&gt;periodicContStateRanges);
<a class="LN" name="1027"> 1027</a>	    rtsiSetErrorStatusPtr(&amp;(&amp;m_SimStruct)-&gt;solverInfo, (&amp;rtmGetErrorStatus
<a class="LN" name="1028"> 1028</a>	      ((&amp;m_SimStruct))));
<a class="LN" name="1029"> 1029</a>	    rtsiSetRTModelPtr(&amp;(&amp;m_SimStruct)-&gt;solverInfo, (&amp;m_SimStruct));
<a class="LN" name="1030"> 1030</a>	  }
<a class="LN" name="1031"> 1031</a>	
<a class="LN" name="1032"> 1032</a>	  rtsiSetSimTimeStep(&amp;(&amp;m_SimStruct)-&gt;solverInfo, MAJOR_TIME_STEP);
<a class="LN" name="1033"> 1033</a>	  (&amp;m_SimStruct)-&gt;intgData.y = (&amp;m_SimStruct)-&gt;odeY;
<a class="LN" name="1034"> 1034</a>	  (&amp;m_SimStruct)-&gt;intgData.f[0] = (&amp;m_SimStruct)-&gt;odeF[0];
<a class="LN" name="1035"> 1035</a>	  (&amp;m_SimStruct)-&gt;intgData.f[1] = (&amp;m_SimStruct)-&gt;odeF[1];
<a class="LN" name="1036"> 1036</a>	  (&amp;m_SimStruct)-&gt;intgData.f[2] = (&amp;m_SimStruct)-&gt;odeF[2];
<a class="LN" name="1037"> 1037</a>	  (&amp;m_SimStruct)-&gt;contStates = ((real_T *) &amp;m_ContState);
<a class="LN" name="1038"> 1038</a>	  rtsiSetSolverData(&amp;(&amp;m_SimStruct)-&gt;solverInfo, (void *)
<a class="LN" name="1039"> 1039</a>	                    &amp;(&amp;m_SimStruct)-&gt;intgData);
<a class="LN" name="1040"> 1040</a>	  rtsiSetSolverName(&amp;(&amp;m_SimStruct)-&gt;solverInfo,<span class="PP">&quot;ode3&quot;</span>);
<a class="LN" name="1041"> 1041</a>	
<a class="LN" name="1042"> 1042</a>	  <span class="CT">/* Initialize timing info */</span>
<a class="LN" name="1043"> 1043</a>	  {
<a class="LN" name="1044"> 1044</a>	    int_T *mdlTsMap = (&amp;m_SimStruct)-&gt;Timing.sampleTimeTaskIDArray;
<a class="LN" name="1045"> 1045</a>	    mdlTsMap[0] = 0;
<a class="LN" name="1046"> 1046</a>	    mdlTsMap[1] = 1;
<a class="LN" name="1047"> 1047</a>	    mdlTsMap[2] = 2;
<a class="LN" name="1048"> 1048</a>	    mdlTsMap[3] = 3;
<a class="LN" name="1049"> 1049</a>	    (&amp;m_SimStruct)-&gt;Timing.sampleTimeTaskIDPtr = (&amp;mdlTsMap[0]);
<a class="LN" name="1050"> 1050</a>	    (&amp;m_SimStruct)-&gt;Timing.sampleTimes =
<a class="LN" name="1051"> 1051</a>	      (&amp;(&amp;m_SimStruct)-&gt;Timing.sampleTimesArray[0]);
<a class="LN" name="1052"> 1052</a>	    (&amp;m_SimStruct)-&gt;Timing.offsetTimes =
<a class="LN" name="1053"> 1053</a>	      (&amp;(&amp;m_SimStruct)-&gt;Timing.offsetTimesArray[0]);
<a class="LN" name="1054"> 1054</a>	
<a class="LN" name="1055"> 1055</a>	    <span class="CT">/* task periods */</span>
<a class="LN" name="1056"> 1056</a>	    (&amp;m_SimStruct)-&gt;Timing.sampleTimes[0] = (0.0);
<a class="LN" name="1057"> 1057</a>	    (&amp;m_SimStruct)-&gt;Timing.sampleTimes[1] = (0.005);
<a class="LN" name="1058"> 1058</a>	    (&amp;m_SimStruct)-&gt;Timing.sampleTimes[2] = (0.01);
<a class="LN" name="1059"> 1059</a>	    (&amp;m_SimStruct)-&gt;Timing.sampleTimes[3] = (1.0);
<a class="LN" name="1060"> 1060</a>	
<a class="LN" name="1061"> 1061</a>	    <span class="CT">/* task offsets */</span>
<a class="LN" name="1062"> 1062</a>	    (&amp;m_SimStruct)-&gt;Timing.offsetTimes[0] = (0.0);
<a class="LN" name="1063"> 1063</a>	    (&amp;m_SimStruct)-&gt;Timing.offsetTimes[1] = (0.0);
<a class="LN" name="1064"> 1064</a>	    (&amp;m_SimStruct)-&gt;Timing.offsetTimes[2] = (0.0);
<a class="LN" name="1065"> 1065</a>	    (&amp;m_SimStruct)-&gt;Timing.offsetTimes[3] = (0.0);
<a class="LN" name="1066"> 1066</a>	  }
<a class="LN" name="1067"> 1067</a>	
<a class="LN" name="1068"> 1068</a>	  rtmSetTPtr((&amp;m_SimStruct), &amp;(&amp;m_SimStruct)-&gt;Timing.tArray[0]);
<a class="LN" name="1069"> 1069</a>	
<a class="LN" name="1070"> 1070</a>	  {
<a class="LN" name="1071"> 1071</a>	    int_T *mdlSampleHits = (&amp;m_SimStruct)-&gt;Timing.sampleHitArray;
<a class="LN" name="1072"> 1072</a>	    mdlSampleHits[0] = 1;
<a class="LN" name="1073"> 1073</a>	    mdlSampleHits[1] = 1;
<a class="LN" name="1074"> 1074</a>	    mdlSampleHits[2] = 1;
<a class="LN" name="1075"> 1075</a>	    mdlSampleHits[3] = 1;
<a class="LN" name="1076"> 1076</a>	    (&amp;m_SimStruct)-&gt;Timing.sampleHits = (&amp;mdlSampleHits[0]);
<a class="LN" name="1077"> 1077</a>	  }
<a class="LN" name="1078"> 1078</a>	
<a class="LN" name="1079"> 1079</a>	  rtmSetTFinal((&amp;m_SimStruct), 240.0);
<a class="LN" name="1080"> 1080</a>	  (&amp;m_SimStruct)-&gt;Timing.stepSize0 = 0.005;
<a class="LN" name="1081"> 1081</a>	  (&amp;m_SimStruct)-&gt;Timing.stepSize1 = 0.005;
<a class="LN" name="1082"> 1082</a>	  (&amp;m_SimStruct)-&gt;Timing.stepSize2 = 0.01;
<a class="LN" name="1083"> 1083</a>	  (&amp;m_SimStruct)-&gt;Timing.stepSize3 = 1.0;
<a class="LN" name="1084"> 1084</a>	  (&amp;m_SimStruct)-&gt;solverInfoPtr = (&amp;(&amp;m_SimStruct)-&gt;solverInfo);
<a class="LN" name="1085"> 1085</a>	  (&amp;m_SimStruct)-&gt;Timing.stepSize = (0.005);
<a class="LN" name="1086"> 1086</a>	  rtsiSetFixedStepSize(&amp;(&amp;m_SimStruct)-&gt;solverInfo, 0.005);
<a class="LN" name="1087"> 1087</a>	  rtsiSetSolverMode(&amp;(&amp;m_SimStruct)-&gt;solverInfo, SOLVER_MODE_SINGLETASKING);
<a class="LN" name="1088"> 1088</a>	
<a class="LN" name="1089"> 1089</a>	  <span class="CT">/* block I/O */</span>
<a class="LN" name="1090"> 1090</a>	  (&amp;m_SimStruct)-&gt;blockIO = ((void *) &amp;m_BlockIO);
<a class="LN" name="1091"> 1091</a>	
<a class="LN" name="1092"> 1092</a>	
<a class="LN" name="1093"> 1093</a>	
<a class="LN" name="1094"> 1094</a>	  <span class="CT">/* parameters */</span>
<a class="LN" name="1095"> 1095</a>	  (&amp;m_SimStruct)-&gt;defaultParam = ((real_T *)&amp;m_ModelParameters);
<a class="LN" name="1096"> 1096</a>	
<a class="LN" name="1097"> 1097</a>	  <span class="CT">/* states (continuous) */</span>
<a class="LN" name="1098"> 1098</a>	  {
<a class="LN" name="1099"> 1099</a>	    real_T *x = (real_T *) &amp;m_ContState;
<a class="LN" name="1100"> 1100</a>	    (&amp;m_SimStruct)-&gt;contStates = (x);
<a class="LN" name="1101"> 1101</a>	
<a class="LN" name="1102"> 1102</a>	
<a class="LN" name="1103"> 1103</a>	  }
<a class="LN" name="1104"> 1104</a>	
<a class="LN" name="1105"> 1105</a>	  <span class="CT">/* states (dwork) */</span>
<a class="LN" name="1106"> 1106</a>	  (&amp;m_SimStruct)-&gt;dwork = ((void *) &amp;m_DWork);
<a class="LN" name="1107"> 1107</a>	
<a class="LN" name="1108"> 1108</a>	
<a class="LN" name="1109"> 1109</a>	
<a class="LN" name="1110"> 1110</a>	  <span class="CT">/* external inputs */</span>
<a class="LN" name="1111"> 1111</a>	  (&amp;m_SimStruct)-&gt;inputs = (((void*)&amp;m_Input));
<a class="LN" name="1112"> 1112</a>	
<a class="LN" name="1113"> 1113</a>	
<a class="LN" name="1114"> 1114</a>	  <span class="CT">/* external outputs */</span>
<a class="LN" name="1115"> 1115</a>	  (&amp;m_SimStruct)-&gt;outputs = (&amp;m_Output);
<a class="LN" name="1116"> 1116</a>	
<a class="LN" name="1117"> 1117</a>	
<a class="LN" name="1118"> 1118</a>	
<a class="LN" name="1119"> 1119</a>	  <span class="CT">/* Initialize Sizes */</span>
<a class="LN" name="1120"> 1120</a>	  (&amp;m_SimStruct)-&gt;Sizes.numContStates = (30);<span class="CT">/* Number of continuous states */</span>
<a class="LN" name="1121"> 1121</a>	  (&amp;m_SimStruct)-&gt;Sizes.numPeriodicContStates = (0);
<a class="LN" name="1122"> 1122</a>	                                      <span class="CT">/* Number of periodic continuous states */</span>
<a class="LN" name="1123"> 1123</a>	  (&amp;m_SimStruct)-&gt;Sizes.numY = (24); <span class="CT">/* Number of model outputs */</span>
<a class="LN" name="1124"> 1124</a>	  (&amp;m_SimStruct)-&gt;Sizes.numU = (10); <span class="CT">/* Number of model inputs */</span>
<a class="LN" name="1125"> 1125</a>	  (&amp;m_SimStruct)-&gt;Sizes.sysDirFeedThru = (1);<span class="CT">/* The model is direct feedthrough */</span>
<a class="LN" name="1126"> 1126</a>	  (&amp;m_SimStruct)-&gt;Sizes.numSampTimes = (4);<span class="CT">/* Number of sample times */</span>
<a class="LN" name="1127"> 1127</a>	  (&amp;m_SimStruct)-&gt;Sizes.numBlocks = (57);<span class="CT">/* Number of blocks */</span>
<a class="LN" name="1128"> 1128</a>	  (&amp;m_SimStruct)-&gt;Sizes.numBlockIO = (39);<span class="CT">/* Number of block outputs */</span>
<a class="LN" name="1129"> 1129</a>	  (&amp;m_SimStruct)-&gt;Sizes.numBlockPrms = (83);<span class="CT">/* Sum of parameter "widths" */</span>
<a class="LN" name="1130"> 1130</a>	  return (&amp;m_SimStruct);
<a class="LN" name="1131"> 1131</a>	}
<a class="LN" name="1132"> 1132</a>	</pre>
</td></tr></table>
</p>
</body>
</html>
