<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4020.12">
  <POU Name="StewartInterface" Id="{c939fb9b-18fc-49a0-acdf-554ae7fa888b}" SpecialFunc="None">
    <Declaration><![CDATA[{attribute 'c++_compatible'}
FUNCTION_BLOCK StewartInterface IMPLEMENTS ITcIoUdpProtocolRecv
VAR_INPUT
	mode 				: ModeStewart;
	cmnd				: DINT := 0;
END_VAR
VAR_OUTPUT
	feedback 			: FeedbackStewart;
END_VAR
VAR
	// UDP connection
	{attribute 'TcInitSymbol'}
	oid					: OTCID;
	ipUdp 				: ITcIoUdpProtocol;
	recvCounter			: UDINT := 0;
	sendCounter			: UDINT := 0;
	remoteUdpPort		: UINT;
	remoteIpAddr		: UDINT;	
	localUdpPort		: UINT;
	
	// UDP raw data structures
	rxUdpData			: RxStewart;
	txUdpData			: TxStewart;
	
	// HMI data
	pTxHmiData			: PVOID;
	txHmiData			: TxHmiStewart;
	
	// Ship simulation
	seed				: INT;
	ship				: ShipSimulator(seed);

END_VAR

VAR CONSTANT
	pi					: REAL := 3.141592653589793;
END_VAR

]]></Declaration>
    <Implementation>
      <ST><![CDATA[// Update IO data
UpdateIO();

// Update UDP data
UpdateUDP();

// Update HMI data
UpdateHMI();

// Update Ship simulation
ship();

// State machine
mode := MODE_SIMULATOR;
CASE mode OF
	MODE_IDLE:
		//
	MODE_SIMULATOR:
		//
		txUdpData.CMND := cmnd;
		
		txUdpData.X_EXTRA := ship.surge;
		txUdpData.Y_EXTRA := ship.sway;
		txUdpData.Z_EXTRA := ship.heave;
		txUdpData.PHI_EXTRA := ship.phi;
		txUdpData.THETA_EXTRA := ship.theta;
		txUdpData.PSI_EXTRA := ship.psi;
		
	MODE_REMOTE:
		//
	MODE_TRANSITION:
		//
	MODE_GENERATOR:
		//
	MODE_STOP:
		//	
END_CASE]]></ST>
    </Implementation>
    <Method Name="FB_exit" Id="{9f843761-ff40-4d99-b356-e763364cd913}">
      <Declaration><![CDATA[METHOD FB_exit : BOOL
VAR_INPUT
	bInCopyCode : BOOL; // if TRUE, the exit method is called for exiting an instance that is copied afterwards (online change).
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (NOT bInCopyCode AND ipUdp <> 0) THEN //Shutdown
	ipUdp.UnregisterReceiver(localUdpPort);
	FW_SafeRelease(ADR(ipUdp));
	FB_exit := TRUE;
ELSE
	FB_exit := FALSE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{020a883e-5120-41dd-a3ec-2f3c0d7f36b3}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	bInitRetains 		: BOOL; // if TRUE, the retain variables are initialized (warm start / cold start)
	bInCopyCode 		: BOOL;  // if TRUE, the instance afterwards gets moved into the copy code (online change)
	
	_remoteIpAddr		: UDINT;
	_remoteUdpPort		: UINT;
	_localUdpPort		: UINT;
	_seed				: INT;
	_pTxHmiData			: PVOID;
END_VAR

VAR
	ipSrv				: ITComObjectServer;
	hr 					: HRESULT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Initilize parameters
remoteIpAddr := _remoteIpAddr;
remoteUdpPort := _remoteUdpPort;
localUdpPort := _localUdpPort;
seed := _seed;
pTxHmiData :=_pTxHmiData;

ship.FB_init(bInitRetains, bInCopyCode, seed);

IF NOT bInCopyCode THEN // no online change
	IF ipUdp = 0 THEN
	    hr := FW_ObjMgr_GetObjectInstance(oid:=oid, iid:=TC_GLOBAL_IID_LIST.IID_ITcIoUdpProtocol, pipUnk:=ADR(ipUdp) );
		
		IF ( SUCCEEDED(hr) AND ipUdp.RegisterReceiver(localUdpPort, THIS^) = 0 ) THEN //open port
			FB_init := TRUE;
		ELSE
			FB_init := FALSE;			
			FW_SafeRelease(ADR(ipUdp));
		END_IF				
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_reinit" Id="{e6021bbf-bb70-496d-b3c7-44db9b6c1f55}">
      <Declaration><![CDATA[METHOD FB_reinit : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (ipUdp <> 0) THEN 
  ipUdp.RegisterReceiver(localUdpPort, THIS^);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="ReceiveData" Id="{b4bc5ad6-7146-4a6c-95b8-2fc54d0695a3}">
      <Declaration><![CDATA[{attribute 'c++_compatible'}
{attribute 'signature_flag' := '33554688'}
{attribute 'pack_mode' := '4'}
{attribute 'show'}
{attribute 'minimal_input_size' := '4'}
{attribute 'checksuperglobal'}

METHOD ReceiveData : HRESULT
VAR_INPUT
	ipAddr	: UDINT;
	udpDestPort	: UINT;
	udpSrcPort	: UINT;
	nData	: UDINT;
	pData	: PVOID;
	pVlan	: POINTER TO ETYPE_VLAN_HEADER := 0;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (nData = SIZEOF(rxUdpData)) THEN
	// Copy recieved pData to rxUdpData
	MEMCPY(ADR(rxUdpData), pData, nData);
	
	// Count number of recieved UDP packets
	recvCounter := recvCounter + 1;
END_IF;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="TcAddRef" Id="{9dd6f5c8-0fec-4407-abb9-1538799e7f74}">
      <Declaration><![CDATA[{attribute 'c++_compatible'}
{attribute 'signature_flag' := '33554688'}
{attribute 'pack_mode' := '4'}
{attribute 'show'}
{attribute 'minimal_input_size' := '4'}
{attribute 'checksuperglobal'}

METHOD TcAddRef : UDINT
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="TcQueryInterface" Id="{8cd9b41b-06c8-4b68-8277-06cb2b6e2b1e}">
      <Declaration><![CDATA[{attribute 'c++_compatible'}
{attribute 'signature_flag' := '33554688'}
{attribute 'pack_mode' := '4'}
{attribute 'show'}
{attribute 'minimal_input_size' := '4'}
{attribute 'checksuperglobal'}

METHOD TcQueryInterface : HRESULT
VAR_INPUT
	iid	: REFERENCE TO IID;
	pipItf	: POINTER TO PVOID;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="TcRelease" Id="{14ed236a-f3ea-4424-a3b9-7c858052425b}">
      <Declaration><![CDATA[{attribute 'c++_compatible'}
{attribute 'signature_flag' := '33554688'}
{attribute 'pack_mode' := '4'}
{attribute 'show'}
{attribute 'minimal_input_size' := '4'}
{attribute 'checksuperglobal'}

METHOD TcRelease : UDINT
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="UpdateHMI" Id="{e2917a57-1981-4cfc-9b8b-656bcbec569b}">
      <Declaration><![CDATA[METHOD PRIVATE UpdateHMI : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Updata HMI data
txHmiData.status := -1;

txHmiData.surge := rxUdpData.Actual_platform_position_surge;
txHmiData.sway := rxUdpData.Actual_platform_position_sway;
txHmiData.heave := rxUdpData.Actual_platform_position_heave;
txHmiData.phi := rxUdpData.Actual_platform_position_roll;
txHmiData.theta := rxUdpData.Actual_platform_position_pitch;
txHmiData.psi := rxUdpData.Actual_platform_position_yaw;

txHmiData.surge_ref := rxUdpData.Platform_setpoint_surge;
txHmiData.sway_ref := rxUdpData.Platform_setpoint_sway;
txHmiData.heave_ref := rxUdpData.Platform_setpoint_heave;
txHmiData.phi_ref := rxUdpData.Platform_setpoint_roll;
txHmiData.theta_ref := rxUdpData.Platform_setpoint_pitch;
txHmiData.psi_ref := rxUdpData.Platform_setpoint_yaw;

txHmiData.L1 := rxUdpData.Actual_position_actuator_1;
txHmiData.L2 := rxUdpData.Actual_position_actuator_2;
txHmiData.L3 := rxUdpData.Actual_position_actuator_3;
txHmiData.L4 := rxUdpData.Actual_position_actuator_4;
txHmiData.L5 := rxUdpData.Actual_position_actuator_5;
txHmiData.L6 := rxUdpData.Actual_position_actuator_6;

txHMiData.surge_sim := ship.surge;
txHMiData.sway_sim := ship.sway;
txHMiData.heave_sim := ship.heave;
txHMiData.phi_sim := ship.phi;
txHMiData.theta_sim := ship.theta;
txHMiData.psi_sim := ship.psi;

// Copy data to global HMI struct
MEMCPY(pTxHmidata, ADR(txHmiData), SIZEOF(TxHmiData));

]]></ST>
      </Implementation>
    </Method>
    <Method Name="UpdateIO" Id="{11363a20-11fa-41fe-ae67-678a8a0bd7de}">
      <Declaration><![CDATA[METHOD PRIVATE UpdateIO : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Update feedback data
feedback.surge 			:= rxUdpData.Actual_platform_position_surge;
feedback.sway 			:= rxUdpData.Actual_platform_position_sway;
feedback.heave 			:= rxUdpData.Actual_platform_position_heave;
feedback.phi 			:= rxUdpData.Actual_platform_position_roll;
feedback.theta 			:= rxUdpData.Actual_platform_position_pitch;
feedback.phi 			:= rxUdpData.Actual_platform_position_yaw;

feedback.surge_t		:= rxUdpData.Actual_platform_velocity_surge;
feedback.sway_t			:= rxUdpData.Actual_platform_velocity_sway;
feedback.heave_t		:= rxUdpData.Actual_platform_velocity_heave;
feedback.phi_t			:= rxUdpData.Actual_platform_velocity_roll;
feedback.theta_t		:= rxUdpData.Actual_platform_velocity_pitch;
feedback.psi_t			:= rxUdpData.Actual_platform_velocity_yaw;

feedback.surge_tt		:= rxUdpData.Actual_platform_acceleration_surge;
feedback.sway_tt		:= rxUdpData.Actual_platform_acceleration_sway;
feedback.heave_tt		:= rxUdpData.Actual_platform_acceleration_heave;
feedback.phi_tt			:= rxUdpData.Actual_platform_acceleration_roll;
feedback.theta_tt		:= rxUdpData.Actual_platform_acceleration_pitch;
feedback.psi_tt			:= rxUdpData.Actual_platform_acceleration_yaw;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="UpdateREMOTE" Id="{2940a620-a8dd-4496-9e0d-bfe0a0be433f}">
      <Declaration><![CDATA[METHOD PRIVATE UpdateREMOTE : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="UpdateUDP" Id="{f77c1d15-1115-4786-8b89-7467216fa00a}">
      <Declaration><![CDATA[METHOD PRIVATE UpdateUDP : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Send data to remote UDP server
IF ipUdp <> 0 THEN
	// Send data to remote UDP server
	ipUdp.SendData(remoteIpAddr, remoteUdpPort, localUdpPort, SIZEOF(txUdpData), ADR(txUdpData), TRUE, 0);
	sendCounter := sendCounter + 1;
	
	// Check for recieved data
	ipUdp.CheckReceived();
END_IF

// Update counter
txUdpData.COUNT := txUdpData.COUNT + 1;


]]></ST>
      </Implementation>
    </Method>
    <Method Name="xyz2zyx" Id="{f24a9c2a-84c4-4b96-a64d-6d8462d9a6cf}">
      <Declaration><![CDATA[METHOD PRIVATE xyz2zyx : ARRAY [0..2] OF REAL
VAR_INPUT
	phi : ARRAY [0..2] OF REAL;
END_VAR

VAR
	t1: REAL;
	t2: REAL;
	t3: REAL;
	t4: REAL;
	t5: REAL;
	t6: REAL;
	t7: REAL;
	t8: REAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Maple optimized code
t1 := COS(phi[0]);
t2 := SIN(phi[1]);
t3 := SIN(phi[2]);
t4 := SIN(phi[0]);
t5 := COS(phi[2]);
t6 := t1 * t3;
t7 := t4 * t5;
t8 := COS(phi[1]);

xyz2zyx[0] := ATAN((t6 * t2 + t7)/(t1 * t8));
xyz2zyx[1] := -ASIN(-t1 * t2 * t5 + t3 * t4);
xyz2zyx[2] := ATAN((t7 * t2 + t6)/(t5 * t8));]]></ST>
      </Implementation>
    </Method>
    <Method Name="zyx2xyz" Id="{e1df9cb1-636f-44d5-bef2-19b214a0ce52}">
      <Declaration><![CDATA[METHOD PRIVATE zyx2xyz : ARRAY [0..2] OF REAL
VAR_INPUT
	phi : ARRAY [0..2] OF REAL;
END_VAR

VAR
	t1: REAL;
	t2: REAL;
	t3: REAL;
	t4: REAL;
	t5: REAL;
	t6: REAL;
	t7: REAL;
	t8: REAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Maple optimized code
t1 := SIN(phi[0]);
t2 := COS(phi[2]);
t3 := COS(phi[0]);
t4 := SIN(phi[1]);
t5 := SIN(phi[2]);
t6 := t3 * t5;
t7 := t1 * t2;
t8 := COS(phi[1]);

zyx2xyz[0] := ATAN((-t6 * t4 + t7)/(t3 * t8));
zyx2xyz[1] := ASIN(t3 * t4 * t2 + t1 * t5);
zyx2xyz[2] := ATAN((-t7 * t4 + t6)/( t2 * t8));]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="StewartInterface">
      <LineId Id="552" Count="0" />
      <LineId Id="548" Count="0" />
      <LineId Id="413" Count="0" />
      <LineId Id="337" Count="0" />
      <LineId Id="375" Count="2" />
      <LineId Id="553" Count="2" />
      <LineId Id="481" Count="0" />
      <LineId Id="498" Count="0" />
      <LineId Id="496" Count="0" />
      <LineId Id="482" Count="4" />
      <LineId Id="499" Count="0" />
      <LineId Id="501" Count="0" />
      <LineId Id="504" Count="2" />
      <LineId Id="503" Count="0" />
      <LineId Id="507" Count="1" />
      <LineId Id="502" Count="0" />
      <LineId Id="487" Count="8" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="StewartInterface.FB_exit">
      <LineId Id="7" Count="5" />
      <LineId Id="6" Count="0" />
    </LineIds>
    <LineIds Name="StewartInterface.FB_init">
      <LineId Id="35" Count="0" />
      <LineId Id="33" Count="1" />
      <LineId Id="66" Count="0" />
      <LineId Id="50" Count="0" />
      <LineId Id="82" Count="1" />
      <LineId Id="16" Count="12" />
      <LineId Id="7" Count="0" />
    </LineIds>
    <LineIds Name="StewartInterface.FB_reinit">
      <LineId Id="6" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="StewartInterface.ReceiveData">
      <LineId Id="19" Count="1" />
      <LineId Id="25" Count="0" />
      <LineId Id="21" Count="3" />
      <LineId Id="18" Count="0" />
    </LineIds>
    <LineIds Name="StewartInterface.TcAddRef">
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="StewartInterface.TcQueryInterface">
      <LineId Id="14" Count="0" />
    </LineIds>
    <LineIds Name="StewartInterface.TcRelease">
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="StewartInterface.UpdateHMI">
      <LineId Id="10" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="11" Count="2" />
      <LineId Id="15" Count="4" />
      <LineId Id="25" Count="9" />
      <LineId Id="36" Count="1" />
      <LineId Id="44" Count="6" />
      <LineId Id="38" Count="2" />
      <LineId Id="35" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="StewartInterface.UpdateIO">
      <LineId Id="6" Count="20" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="StewartInterface.UpdateREMOTE">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="StewartInterface.UpdateUDP">
      <LineId Id="6" Count="7" />
      <LineId Id="16" Count="0" />
      <LineId Id="22" Count="1" />
      <LineId Id="17" Count="0" />
      <LineId Id="14" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="StewartInterface.xyz2zyx">
      <LineId Id="18" Count="11" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="StewartInterface.zyx2xyz">
      <LineId Id="17" Count="11" />
      <LineId Id="5" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>