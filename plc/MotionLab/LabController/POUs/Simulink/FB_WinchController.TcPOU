<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.7">
  <POU Name="FB_WinchController" Id="{ab78257d-6425-4b90-9129-916b14dd85f0}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_WinchController
VAR_INPUT
	useMru: BOOL := FALSE;
	origoPlaneOffset: LREAL := -0.1690;
	lengthExtra: LREAL := -1.0;
	lengthExtra_t: LREAL := 0.0;
	stFeedback: ST_Feedback;
END_VAR
VAR_OUTPUT
	stWinchControl: ST_ControlWinch;
END_VAR
VAR
	eta1: ARRAY[0..5] OF LREAL;
	v1: ARRAY[0..5] OF LREAL;
	eta2: ARRAY[0..5] OF LREAL;
	v2: ARRAY[0..5] OF LREAL;
	Rn1b1: ARRAY[0..8] OF LREAL;
	Rn2b2: ARRAY[0..8] OF LREAL;
	Rn2b2_t: ARRAY[0..8] OF LREAL;
	w: ARRAY[0..2] OF LREAL;
	w_t: ARRAY[0..2] OF LREAL;
	nd: ARRAY[0..2] OF LREAL;
	a: LREAL;
	b: LREAL;
	b_t: LREAL;
	unusedU1: ARRAY[0..5] OF LREAL;
	i: DINT;
	tmp: ARRAY[0..5] OF LREAL;
	tmp_0: ARRAY[0..8] OF LREAL;
	i_0: DINT;
	e: ARRAY[0..2] OF LREAL;
	eta2_0: ARRAY[0..2] OF LREAL;
	Rn1b1_0: ARRAY[0..8] OF LREAL;
	tmp_1: ARRAY[0..8] OF LREAL;
	Rn1b1_1: ARRAY[0..8] OF LREAL;
	d_a: ARRAY[0..2] OF LREAL;
	nd_tmp_tmp: LREAL;
	Rn1b1_tmp: LREAL;
	Rn1b1_tmp_0: LREAL;
	Rn1b1_tmp_1: LREAL;
	Rn1b1_tmp_2: LREAL;
	Rn1b1_tmp_3: LREAL;
	Rn1b1_tmp_4: LREAL;
	Rn1b1_tmp_5: LREAL;
	Rn2b2_t_tmp: DINT;
	Rn2b2_t_tmp_0: DINT;
	nd_tmp: LREAL;
	nd_tmp_0: LREAL;
	nd_tmp_1: LREAL;
	nd_tmp_tmp_0: LREAL;
	nd_tmp_tmp_1: LREAL;
	nd_tmp_tmp_2: LREAL;
	i0_eulerToBody: eulerToBody;
	b_e: ARRAY[0..2] OF LREAL := [-1.0820240997479491, 1.536041691521612, -1.0244614487807751];
	e_a: ARRAY[0..8] OF LREAL := [-0.49716724243009747, 0.86764746505320345, 0.0035509774996006884, 0.86764051357801664, 0.49717836120759562, -0.0036900331983521608, -0.004967117124448933, 0.0012464083117572659, -0.999986887020921];
	b_d: ARRAY[0..2] OF LREAL := [-3.7688459512217709, 3.3476011179532041, 0.973619107013598];
	c_a: ARRAY[0..8] OF LREAL := [0.99997697651804751, 0.0066748605654442265, -0.0012217488515357546, -0.0066752203799496221, 0.99997767822357031, -0.00029066729569189343, 0.0012197814162613592, 0.0002988160463516084, 0.9999992114208226];
	b_d_a: ARRAY[0..2] OF SINT := [0, 0, 1];
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[
(* MATLAB Function: '<S1>/Wire Length' incorporates:
 *  BusCreator: '<S1>/BusConversion_InsertedFor_Wire Length_at_inport_2' *)
(* MATLAB Function 'FB_WinchController/Wire Length': '<S2>:1' *)
(* '<S2>:1:3' if useMru *)

IF useMru THEN 
    (* Stack data from MRU *)
    (* '<S2>:1:5' eta1 = feedback.mru1.eta; *)
    (* '<S2>:1:6' v1 = feedback.mru1.v; *)
    (* '<S2>:1:8' eta2 = feedback.mru2.eta; *)
    (* '<S2>:1:9' v2 = feedback.mru2.v; *)

    FOR i := 0 TO 5 DO 
        eta1[i] := stFeedback.mru1.eta[i];
        v1[i] := stFeedback.mru1.v[i];
        eta2[i] := stFeedback.mru2.eta[i];
        v2[i] := stFeedback.mru2.v[i];
    END_FOR;

ELSE 
    (* '<S2>:1:10' else *)
    (* Use Stewart feedback *)
    (* '<S2>:1:12' eta1 = feedback.em8000.eta; *)
    (* '<S2>:1:13' eta1_t = feedback.em8000.eta_t; *)
    (* '<S2>:1:14' [v1, ~] = math3d.eulerToBody(eta1, eta1_t, zeros(6,1), 'xyz'); *)

    FOR i := 0 TO 5 DO 
        eta1[i] := stFeedback.em8000.eta[i];
        tmp[i] := 0.0;
    END_FOR;

    i0_eulerToBody(eta := stFeedback.em8000.eta, eta_t := stFeedback.em8000.eta_t, eta_tt := tmp);
    v1 := i0_eulerToBody.v;
    eta2 := i0_eulerToBody.v_t;
    (* '<S2>:1:14' ~ *)
    (* '<S2>:1:16' eta2 = feedback.em1500.eta; *)
    (* '<S2>:1:17' eta2_t = feedback.em1500.eta_t; *)
    (* '<S2>:1:18' [v2, ~] = math3d.eulerToBody(eta2, eta2_t, zeros(6,1), 'xyz'); *)

    FOR i := 0 TO 5 DO 
        eta2[i] := stFeedback.em1500.eta[i];
        tmp[i] := 0.0;
    END_FOR;

    i0_eulerToBody(eta := stFeedback.em1500.eta, eta_t := stFeedback.em1500.eta_t, eta_tt := tmp);
    v2 := i0_eulerToBody.v;
    unusedU1 := i0_eulerToBody.v_t;
    (* '<S2>:1:18' ~ *)
END_IF;

(* Comau angle feedback signals *)
(* '<S2>:1:22' q = feedback.comau.q; *)
(* '<S2>:1:23' q_t = feedback.comau.q_t; *)
(* Comau forward kineamtics *)
(* '<S2>:1:26' [p, p_t, ~] = motionlab.comau.forward(q, q_t, zeros(3,1)); *)
(* Static link lengths *)
(* 'forward:4' a1 = 0.350; *)
(* 'forward:5' a2 = 1.160; *)
(* 'forward:6' a3 = 0.250; *)
(* 'forward:7' d1 = 0.830; *)
(* 'forward:8' d4 = 1.4922; *)
(* 'forward:9' d6 = 0.210; *)
(* To wire exit point *)
(* 'forward:12' dt = 0.567; *)
(* To WRE from joint 2 *)
(* 'forward:15' L = d4 + d6 + dt; *)
(* Position {b} -> {t} *)
(* 'forward:18' q1 = q(1); *)
(* 'forward:19' q2 = q(2); *)
(* 'forward:20' q3 = q(3); *)
(* 'forward:22' q1_t = q_t(1); *)
(* 'forward:23' q2_t = q_t(2); *)
(* 'forward:24' q3_t = q_t(3); *)
(* Obtained from formForwardModel *)
(* 'forward:27' p = [ *)
(* 'forward:28'     cos(q1)*(a1 - L*sin(q3) - a3*cos(q3) + a2*sin(q2)); *)
(* 'forward:29'     -sin(q1)*(a1 - L*sin(q3) - a3*cos(q3) + a2*sin(q2)); *)
(* 'forward:30'     d1 + L*cos(q3) + a2*cos(q2) - a3*sin(q3); *)
(* 'forward:31' ]; *)
nd_tmp_tmp := COS(stFeedback.comau.q[2]);
a := SIN(stFeedback.comau.q[2]);
nd_tmp_tmp_1 := SIN(stFeedback.comau.q[1]);
nd_tmp_tmp_2 := 0.25 * nd_tmp_tmp;
b := ((0.35 - (2.2691999999999997 * a)) - nd_tmp_tmp_2) + (1.16 * nd_tmp_tmp_1);
b_t := COS(stFeedback.comau.q[0]);
nd[0] := b * b_t;
nd_tmp_tmp_0 := SIN(stFeedback.comau.q[0]);
nd_tmp := b * ( -nd_tmp_tmp_0);
nd[1] := nd_tmp;
nd_tmp_0 := COS(stFeedback.comau.q[1]);
nd_tmp_tmp := 2.2691999999999997 * nd_tmp_tmp;
nd_tmp_1 := 0.25 * a;
nd[2] := ((nd_tmp_tmp + 0.83) + (1.16 * nd_tmp_0)) - nd_tmp_1;
(* 'forward:33' J = [ *)
(* 'forward:34'     -sin(q1)*(a1 - L*sin(q3) - a3*cos(q3) + a2*sin(q2)),  a2*cos(q1)*cos(q2), -cos(q1)*(L*cos(q3) - a3*sin(q3)); *)
(* 'forward:35'     -cos(q1)*(a1 - L*sin(q3) - a3*cos(q3) + a2*sin(q2)), -a2*cos(q2)*sin(q1),  sin(q1)*(L*cos(q3) - a3*sin(q3)); *)
(* 'forward:36'                                                       0,         -a2*sin(q2),          - L*sin(q3) - a3*cos(q3); *)
(* 'forward:37' ]; *)
(* 'forward:39' J_t = [ *)
(* 'forward:40'     q3_t*sin(q1)*(L*cos(q3) - a3*sin(q3)) - q1_t*cos(q1)*(a1 - L*sin(q3) - a3*cos(q3) + a2*sin(q2)) - a2*q2_t*cos(q2)*sin(q1), - a2*q1_t*cos(q2)*sin(q1) - a2*q2_t*cos(q1)*sin(q2), q3_t*cos(q1)*(L*sin(q3) + a3*cos(q3)) + q1_t*sin(q1)*(L*cos(q3) - a3*sin(q3)); *)
(* 'forward:41'     q3_t*cos(q1)*(L*cos(q3) - a3*sin(q3)) + q1_t*sin(q1)*(a1 - L*sin(q3) - a3*cos(q3) + a2*sin(q2)) - a2*q2_t*cos(q1)*cos(q2),   a2*q2_t*sin(q1)*sin(q2) - a2*q1_t*cos(q1)*cos(q2), q1_t*cos(q1)*(L*cos(q3) - a3*sin(q3)) - q3_t*sin(q1)*(L*sin(q3) + a3*cos(q3)); *)
(* 'forward:42'                                                                                                                             0,                                    -a2*q2_t*cos(q2),                                                -q3_t*(L*cos(q3) - a3*sin(q3)); *)
(* 'forward:43' ]; *)
(* Velocity *)
(* 'forward:46' p_t = J*q_t; *)
(* Acceleration *)
(* 'forward:49' p_tt = J_t*q_t + J*q_tt; *)
(* '<S2>:1:26' ~ *)
(* Load calibration data *)
(* '<S2>:1:29' data = coder.load('motionlab/calib.mat'); *)
(* '<S2>:1:30' calib = data.calib; *)
(* Crane/robot location *)
(* '<S2>:1:33' Hbc = calib.EM8000_TO_COMAU.H; *)
(* Heading offset *)
(* '<S2>:1:36' Hn1n2 = calib.EM8000_TO_EM1500.H; *)
(* '<S2>:1:38' Rn1b1 = math3d.Rxyz(eta1(4:6)); *)
(* 'Rxyz:3' rx = phi(1); *)
(* 'Rxyz:4' ry = phi(2); *)
(* 'Rxyz:5' rz = phi(3); *)
(* 'Rxyz:7' R = [ *)
(* 'Rxyz:8'                               cos(ry)*cos(rz),                          -cos(ry)*sin(rz),          sin(ry); *)
(* 'Rxyz:9'     cos(rx)*sin(rz) + cos(rz)*sin(rx)*sin(ry), cos(rx)*cos(rz) - sin(rx)*sin(ry)*sin(rz), -cos(ry)*sin(rx); *)
(* 'Rxyz:10'     sin(rx)*sin(rz) - cos(rx)*cos(rz)*sin(ry), cos(rz)*sin(rx) + cos(rx)*sin(ry)*sin(rz),  cos(rx)*cos(ry) *)
(* 'Rxyz:11' ]; *)
Rn1b1_tmp := COS(eta1[4]);
Rn1b1_tmp_0 := COS(eta1[5]);
Rn1b1[0] := Rn1b1_tmp * Rn1b1_tmp_0;
Rn1b1_tmp_2 := SIN(eta1[5]);
Rn1b1[3] := ( -Rn1b1_tmp) * Rn1b1_tmp_2;
Rn1b1_tmp_1 := SIN(eta1[4]);
Rn1b1[6] := Rn1b1_tmp_1;
Rn1b1_tmp_3 := COS(eta1[3]);
Rn1b1_tmp_4 := SIN(eta1[3]);
Rn1b1_tmp_5 := Rn1b1_tmp_0 * Rn1b1_tmp_4;
Rn1b1[1] := (Rn1b1_tmp_5 * Rn1b1_tmp_1) + (Rn1b1_tmp_3 * Rn1b1_tmp_2);
Rn1b1_tmp_0 := Rn1b1_tmp_3 * Rn1b1_tmp_0;
Rn1b1[4] := Rn1b1_tmp_0 - ((Rn1b1_tmp_4 * Rn1b1_tmp_1) * Rn1b1_tmp_2);
Rn1b1[7] := ( -COS(eta1[4])) * Rn1b1_tmp_4;
Rn1b1[2] := (Rn1b1_tmp_4 * Rn1b1_tmp_2) - (Rn1b1_tmp_0 * Rn1b1_tmp_1);
Rn1b1[5] := ((Rn1b1_tmp_3 * Rn1b1_tmp_1) * Rn1b1_tmp_2) + Rn1b1_tmp_5;
Rn1b1[8] := Rn1b1_tmp_3 * Rn1b1_tmp;
(* '<S2>:1:39' Rn1b1_t = Rn1b1*math3d.skew(v1(4:6)); *)
(* 'skew:3' vSkew = [ *)
(* 'skew:4'        0, -v(3),  v(2); *)
(* 'skew:5'     v(3),     0, -v(1); *)
(* 'skew:6'    -v(2),  v(1),    0; *)
(* 'skew:7' ]; *)
(* '<S2>:1:41' Rn2b2 = math3d.Rxyz(eta2(4:6)); *)
(* 'Rxyz:3' rx = phi(1); *)
(* 'Rxyz:4' ry = phi(2); *)
(* 'Rxyz:5' rz = phi(3); *)
(* 'Rxyz:7' R = [ *)
(* 'Rxyz:8'                               cos(ry)*cos(rz),                          -cos(ry)*sin(rz),          sin(ry); *)
(* 'Rxyz:9'     cos(rx)*sin(rz) + cos(rz)*sin(rx)*sin(ry), cos(rx)*cos(rz) - sin(rx)*sin(ry)*sin(rz), -cos(ry)*sin(rx); *)
(* 'Rxyz:10'     sin(rx)*sin(rz) - cos(rx)*cos(rz)*sin(ry), cos(rz)*sin(rx) + cos(rx)*sin(ry)*sin(rz),  cos(rx)*cos(ry) *)
(* 'Rxyz:11' ]; *)
Rn1b1_tmp := COS(eta2[4]);
Rn1b1_tmp_0 := COS(eta2[5]);
Rn2b2[0] := Rn1b1_tmp * Rn1b1_tmp_0;
Rn1b1_tmp_2 := SIN(eta2[5]);
Rn2b2[3] := ( -Rn1b1_tmp) * Rn1b1_tmp_2;
Rn1b1_tmp_1 := SIN(eta2[4]);
Rn2b2[6] := Rn1b1_tmp_1;
Rn1b1_tmp_3 := COS(eta2[3]);
Rn1b1_tmp_4 := SIN(eta2[3]);
Rn1b1_tmp_5 := Rn1b1_tmp_0 * Rn1b1_tmp_4;
Rn2b2[1] := (Rn1b1_tmp_5 * Rn1b1_tmp_1) + (Rn1b1_tmp_3 * Rn1b1_tmp_2);
Rn1b1_tmp_0 := Rn1b1_tmp_3 * Rn1b1_tmp_0;
Rn2b2[4] := Rn1b1_tmp_0 - ((Rn1b1_tmp_4 * Rn1b1_tmp_1) * Rn1b1_tmp_2);
Rn2b2[7] := ( -COS(eta2[4])) * Rn1b1_tmp_4;
Rn2b2[2] := (Rn1b1_tmp_4 * Rn1b1_tmp_2) - (Rn1b1_tmp_0 * Rn1b1_tmp_1);
Rn2b2[5] := ((Rn1b1_tmp_3 * Rn1b1_tmp_1) * Rn1b1_tmp_2) + Rn1b1_tmp_5;
Rn2b2[8] := Rn1b1_tmp_3 * Rn1b1_tmp;
(* '<S2>:1:42' Rn2b2_t = Rn2b2*math3d.skew(v2(4:6)); *)
(* 'skew:3' vSkew = [ *)
(* 'skew:4'        0, -v(3),  v(2); *)
(* 'skew:5'     v(3),     0, -v(1); *)
(* 'skew:6'    -v(2),  v(1),    0; *)
(* 'skew:7' ]; *)
tmp_0[0] := 0.0;
tmp_0[3] :=  -v2[5];
tmp_0[6] := v2[4];
tmp_0[1] := v2[5];
tmp_0[4] := 0.0;
tmp_0[7] :=  -v2[3];
tmp_0[2] :=  -v2[4];
tmp_0[5] := v2[3];
tmp_0[8] := 0.0;
(* Tool in {n1} *)
(* '<S2>:1:45' rt = eta1(1:3) + Rn1b1*(Hbc(1:3,4) + Hbc(1:3,1:3)*p); *)
(* '<S2>:1:46' rt_t = v1(1:3) + Rn1b1_t*(Hbc(1:3,4) + Hbc(1:3,1:3)*p) + Rn1b1*Hbc(1:3,1:3)*p_t; *)
(* Plane point pd in {n1} *)
(* '<S2>:1:49' r = [0; 0; h]; *)
(* '<S2>:1:50' rd = Hn1n2(1:3,4) + Hn1n2(1:3,1:3)*(eta2(1:3) + Rn2b2*r); *)
(* '<S2>:1:51' rd_t = Hn1n2(1:3,1:3)*(v2(1:3) + Rn2b2_t*r); *)
(* Vector w *)
(* '<S2>:1:54' w = rt - rd; *)

FOR i := 0 TO 2 DO 
    Rn1b1_tmp := 0.0;

    FOR i_0 := 0 TO 2 DO 
        Rn2b2_t_tmp := i + (3 * i_0);
        Rn2b2_t[Rn2b2_t_tmp] := 0.0;
        Rn2b2_t_tmp_0 := (3 * i_0) + i;
        Rn2b2_t[Rn2b2_t_tmp] := Rn2b2_t[Rn2b2_t_tmp_0] + (tmp_0[3 * i_0] * Rn2b2[i]);
        Rn2b2_t[Rn2b2_t_tmp] := (tmp_0[(3 * i_0) + 1] * Rn2b2[i + 3]) + Rn2b2_t[(3 * i_0) + i];
        Rn2b2_t[Rn2b2_t_tmp] := (tmp_0[(3 * i_0) + 2] * Rn2b2[i + 6]) + Rn2b2_t[(3 * i_0) + i];
        Rn1b1_tmp := (e_a[Rn2b2_t_tmp_0] * nd[i_0]) + Rn1b1_tmp;
    END_FOR;

    e[i] := b_e[i] + Rn1b1_tmp;
    eta2_0[i] := (Rn2b2[i + 6] * origoPlaneOffset) + eta2[i];
END_FOR;

(* '<S2>:1:55' w_t = rt_t  - rd_t; *)
tmp_0[0] := 0.0;
tmp_0[3] :=  -v1[5];
tmp_0[6] := v1[4];
tmp_0[1] := v1[5];
tmp_0[4] := 0.0;
tmp_0[7] :=  -v1[3];
tmp_0[2] :=  -v1[4];
tmp_0[5] := v1[3];
tmp_0[8] := 0.0;
tmp_1[0] := nd_tmp;
tmp_1[3] := (1.16 * b_t) * nd_tmp_0;
Rn1b1_tmp := nd_tmp_tmp - nd_tmp_1;
tmp_1[6] := Rn1b1_tmp * ( -b_t);
tmp_1[1] := b * ( -COS(stFeedback.comau.q[0]));
tmp_1[4] := (-1.16 * nd_tmp_0) * nd_tmp_tmp_0;
tmp_1[7] := Rn1b1_tmp * nd_tmp_tmp_0;
tmp_1[2] := 0.0;
tmp_1[5] := -1.16 * nd_tmp_tmp_1;
tmp_1[8] := (-2.2691999999999997 * a) - nd_tmp_tmp_2;
(* MATLAB Function: '<S1>/Wire Length' incorporates:
 *  BusCreator: '<S1>/BusConversion_InsertedFor_Wire Length_at_inport_2' *)

FOR i := 0 TO 2 DO 
    Rn1b1_tmp := 0.0;

    FOR i_0 := 0 TO 2 DO 
        Rn2b2_t_tmp := (3 * i_0) + i;
        Rn1b1_tmp := (c_a[Rn2b2_t_tmp] * eta2_0[i_0]) + Rn1b1_tmp;
        Rn2b2_t_tmp_0 := i + (3 * i_0);
        Rn1b1_0[Rn2b2_t_tmp_0] := 0.0;
        Rn1b1_0[Rn2b2_t_tmp_0] := Rn1b1_0[Rn2b2_t_tmp] + (tmp_0[3 * i_0] * Rn1b1[i]);
        Rn1b1_0[Rn2b2_t_tmp_0] := (tmp_0[(3 * i_0) + 1] * Rn1b1[i + 3]) + Rn1b1_0[(3 * i_0) + i];
        Rn1b1_0[Rn2b2_t_tmp_0] := (tmp_0[(3 * i_0) + 2] * Rn1b1[i + 6]) + Rn1b1_0[(3 * i_0) + i];
    END_FOR;

    w[i] := ((((Rn1b1[i + 3] * e[1]) + (Rn1b1[i] * e[0])) + (Rn1b1[i + 6] * e[2])) + eta1[i]) - (b_d[i] + Rn1b1_tmp);
    Rn1b1_tmp := 0.0;

    FOR i_0 := 0 TO 2 DO 
        Rn2b2_t_tmp := (3 * i_0) + i;
        Rn1b1_tmp := (e_a[Rn2b2_t_tmp] * nd[i_0]) + Rn1b1_tmp;
        Rn2b2_t_tmp_0 := i + (3 * i_0);
        Rn1b1_1[Rn2b2_t_tmp_0] := 0.0;
        Rn1b1_1[Rn2b2_t_tmp_0] := Rn1b1_1[Rn2b2_t_tmp] + (e_a[3 * i_0] * Rn1b1[i]);
        Rn1b1_1[Rn2b2_t_tmp_0] := (e_a[(3 * i_0) + 1] * Rn1b1[i + 3]) + Rn1b1_1[(3 * i_0) + i];
        Rn1b1_1[Rn2b2_t_tmp_0] := (e_a[(3 * i_0) + 2] * Rn1b1[i + 6]) + Rn1b1_1[(3 * i_0) + i];
    END_FOR;

    w_t[i] := b_e[i] + Rn1b1_tmp;
    d_a[i] := (tmp_1[i + 6] * stFeedback.comau.q_t[2]) + ((tmp_1[i + 3] * stFeedback.comau.q_t[1]) + (tmp_1[i] * stFeedback.comau.q_t[0]));
END_FOR;


FOR i := 0 TO 2 DO 
    nd[i] := (((Rn1b1_0[i + 3] * w_t[1]) + (Rn1b1_0[i] * w_t[0])) + (Rn1b1_0[i + 6] * w_t[2])) + v1[i];
    eta2_0[i] := (Rn2b2_t[i + 6] * origoPlaneOffset) + v2[i];
    e[i] := (Rn1b1_1[i + 6] * d_a[2]) + ((Rn1b1_1[i + 3] * d_a[1]) + (Rn1b1_1[i] * d_a[0]));
END_FOR;

(* Vector nd *)
(* '<S2>:1:58' Rn1b2 = Hn1n2(1:3,1:3)*Rn2b2; *)
(* '<S2>:1:59' Rn1b2_t = Hn1n2(1:3,1:3)*Rn2b2_t; *)
(* '<S2>:1:61' nd = -([0, 0, 1]*Rn1b2')'; *)
(* MATLAB Function: '<S1>/Wire Length' *)

FOR i := 0 TO 2 DO 
    Rn1b1_tmp := 0.0;

    FOR i_0 := 0 TO 2 DO 
        Rn2b2_t_tmp := (3 * i_0) + i;
        Rn1b1_tmp := (c_a[Rn2b2_t_tmp] * eta2_0[i_0]) + Rn1b1_tmp;
        Rn2b2_t_tmp_0 := i + (3 * i_0);
        Rn1b1[Rn2b2_t_tmp_0] := 0.0;
        Rn1b1[Rn2b2_t_tmp_0] := Rn1b1[Rn2b2_t_tmp] + (Rn2b2[3 * i] * c_a[i_0]);
        Rn1b1[Rn2b2_t_tmp_0] := (Rn2b2[(3 * i) + 1] * c_a[i_0 + 3]) + Rn1b1[(3 * i_0) + i];
        Rn1b1[Rn2b2_t_tmp_0] := (Rn2b2[(3 * i) + 2] * c_a[i_0 + 6]) + Rn1b1[(3 * i_0) + i];
    END_FOR;

    w_t[i] := (nd[i] + e[i]) - Rn1b1_tmp;
END_FOR;

(* '<S2>:1:62' nd_t = -([0, 0, 1]*Rn1b2_t')'; *)
(* MATLAB Function: '<S1>/Wire Length' *)

FOR i := 0 TO 2 DO 
    d_a[i] := 0.0;

    FOR i_0 := 0 TO 2 DO 
        Rn2b2_t_tmp_0 := i + (3 * i_0);
        Rn2b2[Rn2b2_t_tmp_0] := 0.0;
        Rn2b2[Rn2b2_t_tmp_0] := Rn2b2[(3 * i_0) + i] + (Rn2b2_t[3 * i] * c_a[i_0]);
        Rn2b2[Rn2b2_t_tmp_0] := (Rn2b2_t[(3 * i) + 1] * c_a[i_0 + 3]) + Rn2b2[(3 * i_0) + i];
        Rn2b2[Rn2b2_t_tmp_0] := (Rn2b2_t[(3 * i) + 2] * c_a[i_0 + 6]) + Rn2b2[(3 * i_0) + i];
        d_a[i] := (Rn1b1[(3 * i) + i_0] * SINT_TO_LREAL(b_d_a[i_0])) + d_a[i];
    END_FOR;

    nd[i] :=  -d_a[i];
END_FOR;

(* Vector nz *)
(* '<S2>:1:65' nz = [0; 0; 1]; *)
(* a and a_t *)
(* '<S2>:1:68' a = dot(w, nd); *)
a := 0.0;
(* '<S2>:1:69' a_t = dot(w_t, nd) + dot(w, nd_t); *)
nd_tmp_tmp_1 := 0.0;
nd_tmp_tmp_2 := 0.0;
(* b and b_t *)
(* '<S2>:1:72' b = dot(nz, nd); *)
b := 0.0;
(* '<S2>:1:73' b_t = dot(nz, nd_t); *)
b_t := 0.0;

FOR i := 0 TO 2 DO 
    a := (w[i] * nd[i]) + a;
    nd_tmp_tmp_1 := (w_t[i] * nd[i]) + nd_tmp_tmp_1;
    nd_tmp_tmp_2 := (w[i] * ( -Rn2b2[(3 * i) + 2])) + nd_tmp_tmp_2;
    b := (SINT_TO_LREAL(b_d_a[i]) * nd[i]) + b;
    b_t := (SINT_TO_LREAL(b_d_a[i]) * ( -Rn2b2[(3 * i) + 2])) + b_t;
END_FOR;

(* BusCreator: '<Root>/BusConversion_InsertedFor_stWinchControl_at_inport_0' incorporates:
 *  Constant: '<S1>/Constant18'
 *  MATLAB Function: '<S1>/Wire Length'
 *  Outport: '<Root>/stWinchControl'
 *  Sum: '<S1>/Sum'
 *  Sum: '<S1>/Sum1' *)
(* Calculate wire length *)
(* '<S2>:1:76' d = -a/b; *)
(* '<S2>:1:77' d_t = (a*b_t)/(b^2) - a_t/b; *)
stWinchControl.length := (( -a) / b) + lengthExtra;
stWinchControl.length_t := (((a * b_t) / (b * b)) - ((nd_tmp_tmp_1 + nd_tmp_tmp_2) / b)) + lengthExtra_t;
stWinchControl.length_tt := 0.0;
]]></ST>
    </Implementation>
    <LineIds Name="FB_WinchController">
      <LineId Id="3" Count="349" />
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>