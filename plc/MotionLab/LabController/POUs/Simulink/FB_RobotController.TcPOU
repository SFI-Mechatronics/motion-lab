<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.7">
  <POU Name="FB_RobotController" Id="{eb9dd35b-1ef8-435b-bb67-f1a5b5011599}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_RobotController
VAR_INPUT
	ssMethodType: SINT;
	stFeedback: ST_Feedback;
	cmpRollPitch: BOOL := FALSE;
	useMru: BOOL := FALSE;
	antiSway: BOOL := FALSE;
	qRef: ARRAY[0..2] OF LREAL := [0.0, 0.0, -1.57];
	qRef_t: ARRAY[0..2] OF LREAL := [0.0, 0.0, 0.0];
	phi: ARRAY[0..1] OF LREAL := [0.0, 0.0];
	phi_t: ARRAY[0..1] OF LREAL := [0.0, 0.0];
END_VAR
VAR_OUTPUT
	stComauControl: ST_ControlComau;
END_VAR
VAR
	b_eta: ARRAY[0..5] OF LREAL;
	b_v: ARRAY[0..5] OF LREAL;
	pt: ARRAY[0..2] OF LREAL;
	Rnb: ARRAY[0..8] OF LREAL;
	Rnb_t: ARRAY[0..8] OF LREAL;
	Rnr: ARRAY[0..8] OF LREAL;
	T1: ARRAY[0..15] OF LREAL;
	b_Pt: ARRAY[0..3] OF LREAL;
	b_D: LREAL;
	theta2: LREAL;
	invH: ARRAY[0..15] OF LREAL;
	rtb_pt_t: ARRAY[0..2] OF LREAL;
	upLimVar: LREAL;
	rtb_Saturation: ARRAY[0..2] OF LREAL;
	rtb_u: ARRAY[0..2] OF LREAL;
	rtb_z_t: ARRAY[0..4] OF LREAL;
	i: DINT;
	e: ARRAY[0..35] OF LREAL;
	tmp: ARRAY[0..44] OF LREAL;
	tmp_0: ARRAY[0..14] OF LREAL;
	i_0: DINT;
	pt_0: ARRAY[0..2] OF LREAL;
	T1_0: ARRAY[0..8] OF LREAL;
	tmp_1: ARRAY[0..8] OF LREAL;
	Rnb_t_0: ARRAY[0..2] OF LREAL;
	phi_idx_0: LREAL;
	phi_t_idx_0: LREAL;
	phi_idx_1: LREAL;
	phi_t_idx_1: LREAL;
	temp1: LREAL;
	Rnb_tmp: LREAL;
	Rnb_tmp_0: LREAL;
	Rnb_t_tmp: DINT;
	temp2: LREAL;
	temp3: LREAL;
	temp4: LREAL;
	temp5: LREAL;
	temp6: LREAL;
	Rnb_t_tmp_0: DINT;
	i0_mldivide_k: mldivide_k;
	i0_mldivide: mldivide_1;
	c_DiscreteTimeIntegrator2_D: ARRAY[0..4] OF LREAL;
	c_DiscreteTimeIntegrator1_D: ARRAY[0..2] OF LREAL;
	c_DiscreteTimeIntegrator_DS: ARRAY[0..2] OF LREAL;
	DiscreteTimeIntegrator_IC: ARRAY[0..2] OF LREAL;
	DiscreteTimeIntegrator1_IC: ARRAY[0..2] OF LREAL;
	Constant_Value: ARRAY[0..4] OF LREAL;
	K: ARRAY[0..44] OF LREAL := [-0.10000000000000148, 2.3998617768167419E-15, -7.4337235538639152E-16, 1.67992137073174E-16, -0.10000000000000125, 4.2016868433485607E-16, 1.8665165582444926E-16, 4.0366490820384718E-16, -0.099999999999999839, 4.6566128730773926E-9, -2.7255737222731113E-8, -3.8394138415353517E-9, 1.5308614820241928E-8, 2.4447217583656311E-8, -3.0329177928908277E-9, 5.1341098958335678, -2.1665956291287936E-12, 4.1415350287884745E-15, 2.6791778471283515E-12, 5.1341098958171614, 1.5735178946568415E-16, -3.9042008768615473E-15, 1.7066124046036825E-17, 5.0662915942610827, 6.795422111521475, -2.7794158086180687E-9, -3.9137469553732049E-10, -1.558873918838799E-9, 6.7954221085092286, 3.0916521801423521E-10, -2.0674448026072707E-16, -8.2727643661900463E-16, 3.336552590402583, 33.339745523233432, 8.3173290477134287E-10, 1.174063363719074E-10, -4.6884451876394451E-10, -33.339745524102909, 9.275667460711021E-11, 0.41080609406344593, 8.3309714682400227E-9, 1.1741234663785208E-9, -4.6711647883057594E-9, -0.41080610326025635, 9.2749813587201547E-10];
	b_e: ARRAY[0..5] OF SINT := [1, 0, 0, 0, 0, 0];
	f: ARRAY[0..5] OF SINT := [0, 1, 0, 0, 0, 0];
	g: ARRAY[0..5] OF SINT := [0, 0, 1, 0, 0, 0];
	a: ARRAY[0..8] OF LREAL := [-0.49716724243009747, 0.86764746505320345, 0.0035509774996006884, 0.86764051357801664, 0.49717836120759562, -0.0036900331983521608, -0.004967117124448933, 0.0012464083117572659, -0.999986887020921];
	r1: ARRAY[0..2] OF LREAL := [-1.0820240997479491, 1.536041691521612, -1.0244614487807751];
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[

CASE ssMethodType OF
    0: 
        (* InitializeConditions for DiscreteIntegrator: '<S1>/Discrete-Time Integrator' *)
        c_DiscreteTimeIntegrator_DS[0] := DiscreteTimeIntegrator_IC[0];
        (* InitializeConditions for DiscreteIntegrator: '<S1>/Discrete-Time Integrator1' *)
        c_DiscreteTimeIntegrator1_D[0] := DiscreteTimeIntegrator1_IC[0];
        (* InitializeConditions for DiscreteIntegrator: '<S1>/Discrete-Time Integrator' *)
        c_DiscreteTimeIntegrator_DS[1] := DiscreteTimeIntegrator_IC[1];
        (* InitializeConditions for DiscreteIntegrator: '<S1>/Discrete-Time Integrator1' *)
        c_DiscreteTimeIntegrator1_D[1] := DiscreteTimeIntegrator1_IC[1];
        (* InitializeConditions for DiscreteIntegrator: '<S1>/Discrete-Time Integrator' *)
        c_DiscreteTimeIntegrator_DS[2] := DiscreteTimeIntegrator_IC[2];
        (* InitializeConditions for DiscreteIntegrator: '<S1>/Discrete-Time Integrator1' *)
        c_DiscreteTimeIntegrator1_D[2] := DiscreteTimeIntegrator1_IC[2];
        (* InitializeConditions for DiscreteIntegrator: '<S1>/Discrete-Time Integrator2' *)

        FOR i := 0 TO 4 DO 
            c_DiscreteTimeIntegrator2_D[i] := 0.0;
        END_FOR;

        (* End of InitializeConditions for DiscreteIntegrator: '<S1>/Discrete-Time Integrator2' *)
    1: 
        (* DiscreteIntegrator: '<S1>/Discrete-Time Integrator' *)
        rtb_pt_t[0] := c_DiscreteTimeIntegrator_DS[0];
        rtb_pt_t[1] := c_DiscreteTimeIntegrator_DS[1];
        rtb_pt_t[2] := c_DiscreteTimeIntegrator_DS[2];
        (* MATLAB Function: '<S1>/MATLAB Function' incorporates:
         *  Constant: '<S1>/Constant'
         *  Constant: '<S1>/Constant4'
         *  DiscreteIntegrator: '<S1>/Discrete-Time Integrator'
         *  DiscreteIntegrator: '<S1>/Discrete-Time Integrator1'
         *  DiscreteIntegrator: '<S1>/Discrete-Time Integrator2' *)
        phi_idx_0 := phi[0];
        phi_t_idx_0 := phi_t[0];
        phi_idx_1 := phi[1];
        phi_t_idx_1 := phi_t[1];
        (* MATLAB Function 'FB_RobotController/MATLAB Function': '<S2>:1' *)
        (* '<S2>:1:3' if ~active *)

        IF  NOT antiSway THEN 
            (* '<S2>:1:4' phi = zeros(2,1); *)
            (* '<S2>:1:5' phi_t = zeros(2,1); *)
            phi_idx_0 := 0.0;
            phi_t_idx_0 := 0.0;
            phi_idx_1 := 0.0;
            phi_t_idx_1 := 0.0;
        END_IF;

        (* '<S2>:1:8' x = [ *)
        (* '<S2>:1:9'     pt *)
        (* '<S2>:1:10'     pt_t *)
        (* '<S2>:1:11'     phi *)
        (* '<S2>:1:12'     phi_t *)
        (* '<S2>:1:13' ]; *)
        (* '<S2>:1:15' y = [ *)
        (* '<S2>:1:16'     pt *)
        (* '<S2>:1:17'     phi *)
        (* '<S2>:1:18' ]; *)
        (* '<S2>:1:21' z_t = r - y; *)
        rtb_z_t[0] := Constant_Value[0] - c_DiscreteTimeIntegrator1_D[0];
        rtb_z_t[1] := Constant_Value[1] - c_DiscreteTimeIntegrator1_D[1];
        rtb_z_t[2] := Constant_Value[2] - c_DiscreteTimeIntegrator1_D[2];
        rtb_z_t[3] := Constant_Value[3] - phi_idx_0;
        rtb_z_t[4] := Constant_Value[4] - phi_idx_1;
        (* '<S2>:1:23' xi = [ *)
        (* '<S2>:1:24'     z *)
        (* '<S2>:1:25'     x *)
        (* '<S2>:1:26' ]; *)
        (* '<S2>:1:28' u = -K*xi; *)

        FOR i_0 := 0 TO 14 DO 
            tmp[3 * i_0] :=  -K[3 * i_0];
            tmp[1 + (3 * i_0)] :=  -K[(3 * i_0) + 1];
            tmp[2 + (3 * i_0)] :=  -K[(3 * i_0) + 2];
        END_FOR;


        FOR i_0 := 0 TO 4 DO 
            tmp_0[i_0] := c_DiscreteTimeIntegrator2_D[i_0];
        END_FOR;

        tmp_0[5] := c_DiscreteTimeIntegrator1_D[0];
        tmp_0[8] := c_DiscreteTimeIntegrator_DS[0];
        tmp_0[6] := c_DiscreteTimeIntegrator1_D[1];
        tmp_0[9] := c_DiscreteTimeIntegrator_DS[1];
        tmp_0[7] := c_DiscreteTimeIntegrator1_D[2];
        tmp_0[10] := c_DiscreteTimeIntegrator_DS[2];
        tmp_0[11] := phi_idx_0;
        tmp_0[13] := phi_t_idx_0;
        tmp_0[12] := phi_idx_1;
        tmp_0[14] := phi_t_idx_1;
        (* Saturate: '<S1>/Saturation' *)

        FOR i := 0 TO 2 DO 
            (* MATLAB Function: '<S1>/MATLAB Function' *)
            rtb_u[i] := 0.0;

            FOR i_0 := 0 TO 14 DO 
                rtb_u[i] := (tmp[(3 * i_0) + i] * tmp_0[i_0]) + rtb_u[i];
            END_FOR;

            (* Saturate: '<S1>/Saturation' incorporates:
             *  DiscreteIntegrator: '<S1>/Discrete-Time Integrator1' *)

            IF c_DiscreteTimeIntegrator1_D[i] >= 0.5 THEN 
                rtb_Saturation[i] := 0.5;
            ELSIF c_DiscreteTimeIntegrator1_D[i] > -0.5 THEN 
                rtb_Saturation[i] := c_DiscreteTimeIntegrator1_D[i];
            ELSE 
                rtb_Saturation[i] := -0.5;
            END_IF;

        END_FOR;

        (* MATLAB Function: '<S1>/Robot Position' incorporates:
         *  BusCreator: '<S1>/BusConversion_InsertedFor_Robot Position_at_inport_6' *)
        (* EM8000 motion *)
        (* MATLAB Function 'FB_RobotController/Robot Position': '<S3>:1' *)
        (* '<S3>:1:4' if useMru *)

        IF useMru THEN 
            (* '<S3>:1:5' eta = feedback.mru1.eta; *)
            (* '<S3>:1:6' v = feedback.mru1.v; *)

            FOR i := 0 TO 5 DO 
                b_eta[i] := stFeedback.mru1.eta[i];
                b_v[i] := stFeedback.mru1.v[i];
            END_FOR;

        ELSE 
            (* '<S3>:1:7' else *)
            (* '<S3>:1:8' eta = feedback.em8000.eta; *)
            (* '<S3>:1:9' eta_t = feedback.em8000.eta_t; *)
            (* '<S3>:1:11' [v, ~] = math3d.eulerToBody(eta, eta_t, zeros(6,1), 'xyz'); *)
            (* Velocity *)
            (* 'eulerToBody:4' J = velocityJacobian(eta, angleSequence); *)
            (* 'eulerToBody:15' phi = eta(4); *)
            (* 'eulerToBody:16' theta = eta(5); *)
            (* 'eulerToBody:17' psi = eta(6); *)
            (* 'eulerToBody:19' if strcmp(sequence, 'xyz') *)
            (* 'eulerToBody:20' J = [ *)
            (* 'eulerToBody:21'             1, 0, 0,                                 0,                                0, 0 *)
            (* 'eulerToBody:22'             0, 1, 0,                                 0,                                0, 0 *)
            (* 'eulerToBody:23'             0, 0, 1,                                 0,                                0, 0 *)
            (* 'eulerToBody:24'             0, 0, 0,               cos(psi)/cos(theta),             -sin(psi)/cos(theta), 0 *)
            (* 'eulerToBody:25'             0, 0, 0,                          sin(psi),                         cos(psi), 0 *)
            (* 'eulerToBody:26'             0, 0, 0, -(cos(psi)*sin(theta))/cos(theta), (sin(psi)*sin(theta))/cos(theta), 1 *)
            (* 'eulerToBody:27'         ]; *)
            (* 'eulerToBody:5' v = J\eta_t; *)
            (* Acceleration *)
            (* 'eulerToBody:8' J_t = accelerationJacobian(eta, eta_t, angleSequence); *)
            (* 'eulerToBody:43' phi = eta(4); *)
            (* 'eulerToBody:44' theta = eta(5); *)
            (* 'eulerToBody:45' psi = eta(6); *)
            (* 'eulerToBody:47' phi_t = eta_t(4); *)
            (* 'eulerToBody:48' theta_t = eta_t(5); *)
            (* 'eulerToBody:49' psi_t = eta_t(6); *)
            (* 'eulerToBody:51' if strcmp(sequence, 'xyz') *)
            (* 'eulerToBody:52' J_t = [ *)
            (* 'eulerToBody:53'             0, 0, 0,                                                                       0,                                                                       0, 0 *)
            (* 'eulerToBody:54'             0, 0, 0,                                                                       0,                                                                       0, 0 *)
            (* 'eulerToBody:55'             0, 0, 0,                                                                       0,                                                                       0, 0 *)
            (* 'eulerToBody:56'             0, 0, 0,  (cos(psi)*sin(theta)*theta_t - cos(theta)*sin(psi)*psi_t)/cos(theta)^2, -(cos(theta)*cos(psi)*psi_t + sin(theta)*sin(psi)*theta_t)/cos(theta)^2, 0 *)
            (* 'eulerToBody:57'             0, 0, 0,                                                          cos(psi)*psi_t,                                                         -sin(psi)*psi_t, 0 *)
            (* 'eulerToBody:58'             0, 0, 0, -(cos(psi)*theta_t - cos(theta)*sin(theta)*sin(psi)*psi_t)/cos(theta)^2,  (sin(psi)*theta_t + cos(theta)*cos(psi)*sin(theta)*psi_t)/cos(theta)^2, 0 *)
            (* 'eulerToBody:59'         ]; *)
            (* 'eulerToBody:9' v_t = J\(eta_tt - J_t*v); *)

            FOR i := 0 TO 5 DO 
                b_eta[i] := stFeedback.em8000.eta[i];
                b_v[i] := stFeedback.em8000.eta_t[i];
                e[6 * i] := SINT_TO_LREAL(b_e[i]);
                e[1 + (6 * i)] := SINT_TO_LREAL(f[i]);
                e[2 + (6 * i)] := SINT_TO_LREAL(g[i]);
            END_FOR;

            e[3] := 0.0;
            e[9] := 0.0;
            e[15] := 0.0;
            phi_idx_0 := COS(stFeedback.em8000.eta[4]);
            phi_t_idx_0 := COS(stFeedback.em8000.eta[5]);
            e[21] := phi_t_idx_0 / phi_idx_0;
            phi_idx_1 := SIN(stFeedback.em8000.eta[5]);
            e[27] := ( -phi_idx_1) / phi_idx_0;
            e[33] := 0.0;
            e[4] := 0.0;
            e[10] := 0.0;
            e[16] := 0.0;
            e[22] := phi_idx_1;
            e[28] := phi_t_idx_0;
            e[34] := 0.0;
            e[5] := 0.0;
            e[11] := 0.0;
            e[17] := 0.0;
            phi_t_idx_1 := SIN(stFeedback.em8000.eta[4]);
            e[23] := ( -(phi_t_idx_0 * phi_t_idx_1)) / phi_idx_0;
            e[29] := (phi_idx_1 * phi_t_idx_1) / phi_idx_0;
            e[35] := 1.0;
            i0_mldivide_k(A := e, B := b_v);
            (* '<S3>:1:11' ~ *)
        END_IF;

        (* Load Calibration data *)
        (* '<S3>:1:15' data = coder.load('motionlab/calib.mat'); *)
        (* '<S3>:1:16' calib = data.calib; *)
        (* Opåeration point in {r} *)
        (* '<S3>:1:19' [p0, p0_t, ~] = motionlab.comau.forward(q0, q0_t, zeros(3,1)); *)
        (* Static link lengths *)
        (* 'forward:4' a1 = 0.350; *)
        (* 'forward:5' a2 = 1.160; *)
        (* 'forward:6' a3 = 0.250; *)
        (* 'forward:7' d1 = 0.830; *)
        (* 'forward:8' d4 = 1.4922; *)
        (* 'forward:9' d6 = 0.210; *)
        (* To wire exit point *)
        (* 'forward:12' dt = 0.567; *)
        (* To WRE from joint 2 *)
        (* 'forward:15' L = d4 + d6 + dt; *)
        (* Position {b} -> {t} *)
        (* 'forward:18' q1 = q(1); *)
        (* 'forward:19' q2 = q(2); *)
        (* 'forward:20' q3 = q(3); *)
        (* 'forward:22' q1_t = q_t(1); *)
        (* 'forward:23' q2_t = q_t(2); *)
        (* 'forward:24' q3_t = q_t(3); *)
        (* Obtained from formForwardModel *)
        (* 'forward:27' p = [ *)
        (* 'forward:28'     cos(q1)*(a1 - L*sin(q3) - a3*cos(q3) + a2*sin(q2)); *)
        (* 'forward:29'     -sin(q1)*(a1 - L*sin(q3) - a3*cos(q3) + a2*sin(q2)); *)
        (* 'forward:30'     d1 + L*cos(q3) + a2*cos(q2) - a3*sin(q3); *)
        (* 'forward:31' ]; *)
        (* 'forward:33' J = [ *)
        (* 'forward:34'     -sin(q1)*(a1 - L*sin(q3) - a3*cos(q3) + a2*sin(q2)),  a2*cos(q1)*cos(q2), -cos(q1)*(L*cos(q3) - a3*sin(q3)); *)
        (* 'forward:35'     -cos(q1)*(a1 - L*sin(q3) - a3*cos(q3) + a2*sin(q2)), -a2*cos(q2)*sin(q1),  sin(q1)*(L*cos(q3) - a3*sin(q3)); *)
        (* 'forward:36'                                                       0,         -a2*sin(q2),          - L*sin(q3) - a3*cos(q3); *)
        (* 'forward:37' ]; *)
        (* 'forward:39' J_t = [ *)
        (* 'forward:40'     q3_t*sin(q1)*(L*cos(q3) - a3*sin(q3)) - q1_t*cos(q1)*(a1 - L*sin(q3) - a3*cos(q3) + a2*sin(q2)) - a2*q2_t*cos(q2)*sin(q1), - a2*q1_t*cos(q2)*sin(q1) - a2*q2_t*cos(q1)*sin(q2), q3_t*cos(q1)*(L*sin(q3) + a3*cos(q3)) + q1_t*sin(q1)*(L*cos(q3) - a3*sin(q3)); *)
        (* 'forward:41'     q3_t*cos(q1)*(L*cos(q3) - a3*sin(q3)) + q1_t*sin(q1)*(a1 - L*sin(q3) - a3*cos(q3) + a2*sin(q2)) - a2*q2_t*cos(q1)*cos(q2),   a2*q2_t*sin(q1)*sin(q2) - a2*q1_t*cos(q1)*cos(q2), q1_t*cos(q1)*(L*cos(q3) - a3*sin(q3)) - q3_t*sin(q1)*(L*sin(q3) + a3*cos(q3)); *)
        (* 'forward:42'                                                                                                                             0,                                    -a2*q2_t*cos(q2),                                                -q3_t*(L*cos(q3) - a3*sin(q3)); *)
        (* 'forward:43' ]; *)
        (* Velocity *)
        (* 'forward:46' p_t = J*q_t; *)
        (* Acceleration *)
        (* 'forward:49' p_tt = J_t*q_t + J*q_tt; *)
        (* '<S3>:1:19' ~ *)
        (* Tool in {n} *)
        (* '<S3>:1:22' Hbr = calib.EM8000_TO_COMAU.H; *)
        (* '<S3>:1:23' r1 = Hbr(1:3,4); *)
        (* '<S3>:1:24' Rbr = Hbr(1:3,1:3); *)
        (* '<S3>:1:26' pt =  r1 + Rbr*p0 + LQR; *)
        temp1 := COS(qRef[2]);
        phi_idx_0 := SIN(qRef[2]);
        phi_t_idx_0 := SIN(qRef[1]);
        phi_idx_1 := 0.25 * temp1;
        phi_t_idx_1 := ((0.35 - (2.2691999999999997 * phi_idx_0)) - phi_idx_1) + (1.16 * phi_t_idx_0);
        temp3 := COS(qRef[0]);
        upLimVar := phi_t_idx_1 * temp3;
        temp6 := SIN(qRef[0]);
        temp2 := phi_t_idx_1 * ( -temp6);
        temp4 := COS(qRef[1]);
        temp1 := 2.2691999999999997 * temp1;
        temp5 := 0.25 * phi_idx_0;
        b_D := ((temp1 + 0.83) + (1.16 * temp4)) - temp5;
        (* MATLAB Function: '<S1>/Robot Position' *)

        FOR i_0 := 0 TO 2 DO 
            pt[i_0] := ((((a[i_0 + 3] * temp2) + (a[i_0] * upLimVar)) + (a[i_0 + 6] * b_D)) + r1[i_0]) + rtb_Saturation[i_0];
        END_FOR;

        (* '<S3>:1:27' pt_t = Rbr*p0_t + LQR_t; *)
        (* Tool given in {r} when EM800 is moving *)
        (* '<S3>:1:30' if cmpRollPicth *)

        IF cmpRollPitch THEN 
            (* '<S3>:1:31' Rnb = math3d.Rxyz([eta(4:5); 0]); *)
            (* 'Rxyz:3' rx = phi(1); *)
            (* 'Rxyz:4' ry = phi(2); *)
            (* 'Rxyz:5' rz = phi(3); *)
            (* 'Rxyz:7' R = [ *)
            (* 'Rxyz:8'                               cos(ry)*cos(rz),                          -cos(ry)*sin(rz),          sin(ry); *)
            (* 'Rxyz:9'     cos(rx)*sin(rz) + cos(rz)*sin(rx)*sin(ry), cos(rx)*cos(rz) - sin(rx)*sin(ry)*sin(rz), -cos(ry)*sin(rx); *)
            (* 'Rxyz:10'     sin(rx)*sin(rz) - cos(rx)*cos(rz)*sin(ry), cos(rz)*sin(rx) + cos(rx)*sin(ry)*sin(rz),  cos(rx)*cos(ry) *)
            (* 'Rxyz:11' ]; *)
            upLimVar := COS(b_eta[4]);
            Rnb[0] := upLimVar;
            Rnb[3] := 0.0;
            b_D := SIN(b_eta[4]);
            Rnb[6] := b_D;
            theta2 := SIN(b_eta[3]);
            Rnb_tmp := theta2 * b_D;
            Rnb_tmp_0 := COS(b_eta[3]);
            Rnb[1] := Rnb_tmp;
            Rnb[4] := Rnb_tmp_0;
            Rnb[7] := ( -COS(b_eta[4])) * theta2;
            b_D := Rnb_tmp_0 * b_D;
            Rnb[2] := 0.0 - b_D;
            Rnb[5] := theta2;
            Rnb[8] := Rnb_tmp_0 * upLimVar;
            (* '<S3>:1:32' Rnb_t = Rnb*math3d.skew([v(4:5); 0]); *)
            (* 'skew:3' vSkew = [ *)
            (* 'skew:4'        0, -v(3),  v(2); *)
            (* 'skew:5'     v(3),     0, -v(1); *)
            (* 'skew:6'    -v(2),  v(1),    0; *)
            (* 'skew:7' ]; *)
            T1_0[0] := 0.0;
            T1_0[3] := -0.0;
            T1_0[6] := b_v[4];
            T1_0[1] := 0.0;
            T1_0[4] := 0.0;
            T1_0[7] :=  -b_v[3];
            T1_0[2] :=  -b_v[4];
            T1_0[5] := b_v[3];
            T1_0[8] := 0.0;

            FOR i_0 := 0 TO 2 DO 

                FOR i := 0 TO 2 DO 
                    Rnb_t_tmp := i + (3 * i_0);
                    Rnb_t[Rnb_t_tmp] := 0.0;
                    Rnb_t[Rnb_t_tmp] := Rnb_t[(3 * i_0) + i] + (T1_0[3 * i_0] * Rnb[i]);
                    Rnb_t[Rnb_t_tmp] := (T1_0[(3 * i_0) + 1] * Rnb[i + 3]) + Rnb_t[(3 * i_0) + i];
                    Rnb_t[Rnb_t_tmp] := (T1_0[(3 * i_0) + 2] * Rnb[i + 6]) + Rnb_t[(3 * i_0) + i];
                END_FOR;

            END_FOR;

        ELSE 
            (* '<S3>:1:33' else *)
            (* '<S3>:1:34' Rnb = eye(3); *)

            FOR i_0 := 0 TO 8 DO 
                Rnb[i_0] := 0.0;
                Rnb_t[i_0] := 0.0;
            END_FOR;

            Rnb[0] := 1.0;
            Rnb[4] := 1.0;
            Rnb[8] := 1.0;
            (* '<S3>:1:35' Rnb_t = zeros(3,3); *)
        END_IF;

        (* '<S3>:1:38' Rnr = Rnb*Rbr; *)
        (* '<S3>:1:39' Rnr_t = Rnb_t*Rbr; *)
        (* '<S3>:1:41' p = Rnr'*(pt - r1); *)

        FOR i_0 := 0 TO 2 DO 

            FOR i := 0 TO 2 DO 
                Rnb_t_tmp := i_0 + (3 * i);
                Rnr[Rnb_t_tmp] := 0.0;
                Rnr[Rnb_t_tmp] := Rnr[(3 * i) + i_0] + (a[3 * i] * Rnb[i_0]);
                Rnr[Rnb_t_tmp] := (a[(3 * i) + 1] * Rnb[i_0 + 3]) + Rnr[(3 * i) + i_0];
                Rnr[Rnb_t_tmp] := (a[(3 * i) + 2] * Rnb[i_0 + 6]) + Rnr[(3 * i) + i_0];
            END_FOR;

            pt_0[i_0] := pt[i_0] - r1[i_0];
        END_FOR;

        (* MATLAB Function: '<S1>/Robot Position' *)

        FOR i_0 := 0 TO 2 DO 
            rtb_Saturation[i_0] := (Rnr[(3 * i_0) + 2] * pt_0[2]) + ((Rnr[(3 * i_0) + 1] * pt_0[1]) + (Rnr[3 * i_0] * pt_0[0]));
        END_FOR;

        (* '<S3>:1:42' p_t = Rnr_t'*(pt - r1) + Rnr'*(pt_t); *)
        (* Inverse kineamtics *)
        (* '<S3>:1:45' [q, q_t, ~] = motionlab.comau.inverse(p, p_t, zeros(3,1)); *)
        (* Static link lengths *)
        (* 'inverse:4' a1 = 0.350; *)
        (* 'inverse:5' a2 = 1.160; *)
        (* 'inverse:6' a3 = 0.250; *)
        (* 'inverse:7' d1 = 0.830; *)
        (* 'inverse:8' d4 = 1.4922; *)
        (* 'inverse:9' d6 = 0.210; *)
        (* To wire exit point *)
        (* 'inverse:12' dt = 0.567; *)
        (* To WRE from joint 2 *)
        (* 'inverse:15' L = d4 + d6 + dt; *)
        (* Positional angles *)
        (* 'inverse:18' q1 = -atan2(p(2), p(1)); *)
        b_D := rt_atan2d(u0 := rtb_Saturation[1], u1 := rtb_Saturation[0]);
        upLimVar :=  -rt_atan2d(u0 := rtb_Saturation[1], u1 := rtb_Saturation[0]);
        (* {t} given in {j1} *)
        (* 'inverse:21' T1 = math3d.DH(-q1, d1, a1, pi/2); *)
        (* 'DH:3' T = [cos(theta),-sin(theta)*cos(alpha), sin(theta)*sin(alpha),a*cos(theta); *)
        (* 'DH:4'      sin(theta), cos(theta)*cos(alpha),-cos(theta)*sin(alpha),a*sin(theta); *)
        (* 'DH:5'      0         , sin(alpha)           , cos(alpha)           ,d           ; *)
        (* 'DH:6'      0         ,0                     ,0                     ,1           ]; *)
        T1[0] := COS( -( -b_D));
        T1[4] := ( -SIN( -( -b_D))) * 6.123233995736766E-17;
        T1[8] := SIN( -( -b_D));
        T1[12] := 0.35 * COS( -( -b_D));
        T1[1] := SIN( -( -b_D));
        T1[5] := COS( -( -b_D)) * 6.123233995736766E-17;
        T1[9] :=  -COS( -( -b_D));
        T1[13] := 0.35 * SIN( -( -b_D));
        T1[2] := 0.0;
        T1[3] := 0.0;
        T1[6] := 1.0;
        T1[7] := 0.0;
        T1[10] := 6.123233995736766E-17;
        T1[11] := 0.0;
        T1[14] := 0.83;
        T1[15] := 1.0;
        (* 'inverse:22' Pt = math3d.InvH(T1)*[p(1); p(2); p(3); 1]; *)
        (* Reverse homgoenous rigid motions *)
        (* More efficient than using inv(H) *)
        
        (* INPUTS: *)
        (* H         : Homogeneus transformation matrix 4x4 *)
        (* OUT: *)
        (* invH      : Reversed rigid motion matrix 4x4 *)
        (* 'InvH:12' R = H(1:3,1:3); *)
        (* 'InvH:13' d = H(1:3,4); *)
        (* 'InvH:15' invH = eye(4,4); *)
        (* MATLAB Function: '<S1>/Robot Position' *)

        FOR i_0 := 0 TO 15 DO 
            invH[i_0] := 0.0;
        END_FOR;

        invH[0] := 1.0;
        invH[5] := 1.0;
        invH[10] := 1.0;
        invH[15] := 1.0;
        (* 'InvH:17' invH(1:3,1:3) = R'; *)
        (* 'InvH:18' invH(1:3,4) = -R'*d; *)

        FOR i_0 := 0 TO 2 DO 
            invH[i_0 * 4] := T1[i_0];
            T1_0[3 * i_0] :=  -T1[i_0];
            invH[1 + (i_0 * 4)] := T1[i_0 + 4];
            T1_0[1 + (3 * i_0)] :=  -T1[i_0 + 4];
            invH[2 + (i_0 * 4)] := T1[i_0 + 8];
            T1_0[2 + (3 * i_0)] :=  -T1[i_0 + 8];
        END_FOR;


        FOR i_0 := 0 TO 2 DO 
            invH[12 + i_0] := 0.0;
            invH[12 + i_0] := invH[12 + i_0] + (T1_0[i_0] * T1[12]);
            invH[12 + i_0] := (T1_0[i_0 + 3] * T1[13]) + invH[12 + i_0];
            invH[12 + i_0] := (T1_0[i_0 + 6] * 0.83) + invH[12 + i_0];
        END_FOR;

        (* 'InvH:20' invH(4,1:4) = [0,0,0,1]; *)
        invH[3] := 0.0;
        invH[7] := 0.0;
        invH[11] := 0.0;
        invH[15] := 1.0;
        (* MATLAB Function: '<S1>/Robot Position' *)

        FOR i_0 := 0 TO 3 DO 
            b_D := invH[i_0 + 12] + ((invH[i_0 + 8] * rtb_Saturation[2]) + ((invH[i_0 + 4] * rtb_Saturation[1]) + (invH[i_0] * rtb_Saturation[0])));
            b_Pt[i_0] := b_D;
        END_FOR;

        (* Solve q2 and q3 *)
        (* 'inverse:25' x = Pt(1); *)
        (* 'inverse:26' y = Pt(2); *)
        (* 'inverse:28' r = sqrt(a3^2 + L^2); *)
        (* 'inverse:29' dtheta = atan2(a3, L); *)
        (* 'inverse:30' D = (x^2 + y^2 - a2^2 - r^2)/(2*a2*r); *)
        b_D := ((((b_Pt[0] * b_Pt[0]) + (b_Pt[1] * b_Pt[1])) - 1.3456) - 5.2117686399999972) / 5.2963972215021773;
        (* 'inverse:32' theta2 = atan2(-sqrt(1 - D^2), D); *)
        theta2 := rt_atan2d(u0 :=  -SQRT(1.0 - (b_D * b_D)), u1 := b_D);
        (* 'inverse:33' theta1 = atan2(y, x) - atan2(r*sin(theta2), a2 + r*cos(theta2)); *)
        Rnb_tmp := 2.2829298368543869 * SIN(theta2);
        Rnb_tmp_0 := (2.2829298368543869 * COS(theta2)) + 1.16;
        (* Convert to robot angles *)
        (* 'inverse:36' q2 = -theta1 + pi/2; *)
        b_D := ( -(rt_atan2d(u0 := b_Pt[1], u1 := b_Pt[0]) - rt_atan2d(u0 := Rnb_tmp, u1 := Rnb_tmp_0))) + 1.5707963267948966;
        (* 'inverse:37' q3 = theta2 - dtheta - q2; *)
        theta2 := (theta2 - 0.10972846481387506) - (( -(rt_atan2d(u0 := b_Pt[1], u1 := b_Pt[0]) - rt_atan2d(u0 := Rnb_tmp, u1 := Rnb_tmp_0))) + 1.5707963267948966);
        (* BusCreator: '<Root>/BusConversion_InsertedFor_stComauControl_at_inport_0' incorporates:
         *  MATLAB Function: '<S1>/Robot Position'
         *  Outport: '<Root>/stComauControl' *)
        (* Posititons *)
        (* 'inverse:40' q = [q1; q2; q3]; *)
        (* Velocity *)
        (* 'inverse:43' J = [ *)
        (* 'inverse:44'     -sin(q1)*(a1 - L*sin(q3) - a3*cos(q3) + a2*sin(q2)),  a2*cos(q1)*cos(q2), -cos(q1)*(L*cos(q3) - a3*sin(q3)); *)
        (* 'inverse:45'     -cos(q1)*(a1 - L*sin(q3) - a3*cos(q3) + a2*sin(q2)), -a2*cos(q2)*sin(q1),  sin(q1)*(L*cos(q3) - a3*sin(q3)); *)
        (* 'inverse:46'                                                       0,         -a2*sin(q2),          - L*sin(q3) - a3*cos(q3); *)
        (* 'inverse:47' ]; *)
        (* 'inverse:49' q_t = J\p_t; *)
        (* Accelerations *)
        (* 'inverse:52' q1_t = q_t(1); *)
        (* 'inverse:53' q2_t = q_t(2); *)
        (* 'inverse:54' q3_t = q_t(3); *)
        (* 'inverse:56' J_t = [ *)
        (* 'inverse:57'     q3_t*sin(q1)*(L*cos(q3) - a3*sin(q3)) - q1_t*cos(q1)*(a1 - L*sin(q3) - a3*cos(q3) + a2*sin(q2)) - a2*q2_t*cos(q2)*sin(q1), - a2*q1_t*cos(q2)*sin(q1) - a2*q2_t*cos(q1)*sin(q2), q3_t*cos(q1)*(L*sin(q3) + a3*cos(q3)) + q1_t*sin(q1)*(L*cos(q3) - a3*sin(q3)); *)
        (* 'inverse:58'     q3_t*cos(q1)*(L*cos(q3) - a3*sin(q3)) + q1_t*sin(q1)*(a1 - L*sin(q3) - a3*cos(q3) + a2*sin(q2)) - a2*q2_t*cos(q1)*cos(q2),   a2*q2_t*sin(q1)*sin(q2) - a2*q1_t*cos(q1)*cos(q2), q1_t*cos(q1)*(L*cos(q3) - a3*sin(q3)) - q3_t*sin(q1)*(L*sin(q3) + a3*cos(q3)); *)
        (* 'inverse:59'                                                                                                                             0,                                    -a2*q2_t*cos(q2),                                                -q3_t*(L*cos(q3) - a3*sin(q3)); *)
        (* 'inverse:60' ]; *)
        (* 'inverse:62' q_tt = J\(p_tt - J_t*q_t); *)
        (* '<S3>:1:45' ~ *)
        stComauControl.q[0] := upLimVar;
        stComauControl.q[1] := b_D;
        stComauControl.q[2] := theta2;
        (* MATLAB Function: '<S1>/Robot Position' *)
        T1_0[0] := (((0.35 - (2.2691999999999997 * SIN(theta2))) - (0.25 * COS(theta2))) + (1.16 * SIN(b_D))) * ( -SIN(upLimVar));
        T1_0[3] := (1.16 * COS(upLimVar)) * COS(b_D);
        T1_0[6] := ((2.2691999999999997 * COS(theta2)) - (0.25 * SIN(theta2))) * ( -COS(upLimVar));
        T1_0[1] := (((0.35 - (2.2691999999999997 * SIN(theta2))) - (0.25 * COS(theta2))) + (1.16 * SIN(b_D))) * ( -COS(upLimVar));
        T1_0[4] := (-1.16 * COS(b_D)) * SIN(upLimVar);
        T1_0[7] := ((2.2691999999999997 * COS(theta2)) - (0.25 * SIN(theta2))) * SIN(upLimVar);
        T1_0[2] := 0.0;
        T1_0[5] := -1.16 * SIN(b_D);
        T1_0[8] := (-2.2691999999999997 * SIN(theta2)) - (0.25 * COS(theta2));
        tmp_1[0] := temp2;
        tmp_1[3] := (1.16 * temp3) * temp4;
        temp2 := temp1 - temp5;
        tmp_1[6] := temp2 * ( -temp3);
        tmp_1[1] := phi_t_idx_1 * ( -COS(qRef[0]));
        tmp_1[4] := (-1.16 * temp4) * temp6;
        tmp_1[7] := temp2 * temp6;
        tmp_1[2] := 0.0;
        tmp_1[5] := -1.16 * phi_t_idx_0;
        tmp_1[8] := (-2.2691999999999997 * phi_idx_0) - phi_idx_1;

        FOR i_0 := 0 TO 2 DO 
            pt_0[i_0] := pt[i_0] - r1[i_0];
            rtb_Saturation[i_0] := 0.0;

            FOR i := 0 TO 2 DO 
                Rnb_t_tmp := i_0 + (3 * i);
                Rnb[Rnb_t_tmp] := 0.0;
                Rnb_t_tmp_0 := (3 * i) + i_0;
                Rnb[Rnb_t_tmp] := Rnb[Rnb_t_tmp_0] + (a[3 * i_0] * Rnb_t[i]);
                Rnb[Rnb_t_tmp] := (a[(3 * i_0) + 1] * Rnb_t[i + 3]) + Rnb[(3 * i) + i_0];
                Rnb[Rnb_t_tmp] := (a[(3 * i_0) + 2] * Rnb_t[i + 6]) + Rnb[(3 * i) + i_0];
                rtb_Saturation[i_0] := (tmp_1[Rnb_t_tmp_0] * qRef_t[i]) + rtb_Saturation[i_0];
            END_FOR;

        END_FOR;


        FOR i_0 := 0 TO 2 DO 
            pt[i_0] := (((a[i_0 + 3] * rtb_Saturation[1]) + (a[i_0] * rtb_Saturation[0])) + (a[i_0 + 6] * rtb_Saturation[2])) + rtb_pt_t[i_0];
            Rnb_t_0[i_0] := (Rnb[i_0 + 6] * pt_0[2]) + ((Rnb[i_0 + 3] * pt_0[1]) + (Rnb[i_0] * pt_0[0]));
        END_FOR;


        FOR i := 0 TO 2 DO 
            pt_0[i] := Rnb_t_0[i] + ((Rnr[(3 * i) + 2] * pt[2]) + ((Rnr[(3 * i) + 1] * pt[1]) + (Rnr[3 * i] * pt[0])));
            (* BusCreator: '<Root>/BusConversion_InsertedFor_stComauControl_at_inport_0' incorporates:
             *  Outport: '<Root>/stComauControl' *)
            stComauControl.q_tt[i] := 0.0;
            (* Update for DiscreteIntegrator: '<S1>/Discrete-Time Integrator' *)
            c_DiscreteTimeIntegrator_DS[i] := (0.005 * rtb_u[i]) + c_DiscreteTimeIntegrator_DS[i];
            (* Update for DiscreteIntegrator: '<S1>/Discrete-Time Integrator1' *)
            c_DiscreteTimeIntegrator1_D[i] := (0.005 * rtb_pt_t[i]) + c_DiscreteTimeIntegrator1_D[i];
        END_FOR;

        (* BusCreator: '<Root>/BusConversion_InsertedFor_stComauControl_at_inport_0' incorporates:
         *  MATLAB Function: '<S1>/Robot Position'
         *  Outport: '<Root>/stComauControl' *)
        i0_mldivide(A := T1_0, B := pt_0);
        stComauControl.q_t := i0_mldivide.Y;
        (* Update for DiscreteIntegrator: '<S1>/Discrete-Time Integrator2' *)

        FOR i_0 := 0 TO 4 DO 
            c_DiscreteTimeIntegrator2_D[i_0] := (0.005 * rtb_z_t[i_0]) + c_DiscreteTimeIntegrator2_D[i_0];
        END_FOR;

        (* End of Update for DiscreteIntegrator: '<S1>/Discrete-Time Integrator2' *)
END_CASE;

]]></ST>
    </Implementation>
    <LineIds Name="FB_RobotController">
      <LineId Id="3" Count="571" />
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>