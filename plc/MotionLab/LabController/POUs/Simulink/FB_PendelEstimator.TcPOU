<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.7">
  <POU Name="FB_PendelEstimator" Id="{91eb407a-c1bf-47cd-8ec5-6379fd5c6e8f}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_PendelEstimator
VAR_INPUT
	ssMethodType: SINT;
	stFeedback: ST_Feedback;
	useMru: BOOL := FALSE;
	Ts: LREAL := 0.005;
	diagQ: ARRAY[0..18] OF LREAL := [1.000000E-06,1.000000E-06,1.000000E-06,1.000000E-06,1.000000E-06,1.000000E-06,1.000000E-06,1.000000E-06,1.000000E-06,1.000000E-06,1.000000E-06,1.000000E-06,1.000000E-06,1.000000E-06,1.000000E-06,1.000000E-06,1.000000E-06,1.000000E-06,1.000000E-06];
	diagR: ARRAY[0..10] OF LREAL := [2.500000E-05,2.500000E-05,2.500000E-05,2.500000E-05,2.500000E-05,2.500000E-05,2.500000E-05,2.500000E-05,2.500000E-05,2.500000E-05,2.500000E-05];	
END_VAR
VAR_OUTPUT
	pt: ARRAY[0..2] OF LREAL;
	pt_t: ARRAY[0..2] OF LREAL;
	pt_tt: ARRAY[0..2] OF LREAL;
	phi: ARRAY[0..1] OF LREAL;
	phi_t: ARRAY[0..1] OF LREAL;
	length: LREAL;
	length_t: LREAL;
	e: ARRAY[0..2] OF LREAL;
	c: LREAL;
	xEst: ARRAY[0..18] OF LREAL;
END_VAR
VAR
	Rnb: ARRAY[0..8] OF LREAL;
	b_p: ARRAY[0..2] OF LREAL;
	b_v: ARRAY[0..5] OF LREAL;
	v_t: ARRAY[0..5] OF LREAL;
	b_J: ARRAY[0..35] OF LREAL;
	xPred: ARRAY[0..18] OF LREAL;
	b_F: ARRAY[0..360] OF LREAL;
	PPred: ARRAY[0..360] OF LREAL;
	b_H: ARRAY[0..208] OF LREAL;
	K: ARRAY[0..208] OF LREAL;
	i: DINT;
	tmp: ARRAY[0..10] OF LREAL;
	tmp_0: ARRAY[0..120] OF LREAL;
	H_0: ARRAY[0..120] OF LREAL;
	tmp_1: ARRAY[0..360] OF LREAL;
	tmp_2: ARRAY[0..35] OF LREAL;
	i_0: DINT;
	i_1: DINT;
	F_0: ARRAY[0..360] OF LREAL;
	H_1: ARRAY[0..208] OF LREAL;
	b_r: ARRAY[0..2] OF LREAL;
	tmp_3: ARRAY[0..8] OF LREAL;
	Rnb_0: ARRAY[0..8] OF LREAL;
	r_0: ARRAY[0..2] OF LREAL;
	tmp_4: ARRAY[0..8] OF LREAL;
	tmp_5: ARRAY[0..2] OF LREAL;
	v_0: ARRAY[0..2] OF LREAL;
	stFeedback_0: ARRAY[0..3] OF LREAL;
	a: ARRAY[0..3] OF LREAL;
	stFeedback_1: ARRAY[0..10] OF LREAL;
	stFeedback_2: ARRAY[0..10] OF LREAL;
	p_tmp: LREAL;
	p_tmp_tmp: LREAL;
	p_tmp_tmp_0: LREAL;
	b_J_tmp: LREAL;
	b_J_tmp_0: LREAL;
	b_J_tmp_1: LREAL;
	b_J_tmp_2: LREAL;
	b_J_tmp_3: LREAL;
	Rnb_tmp: LREAL;
	Rnb_tmp_0: LREAL;
	F_tmp: DINT;
	p_tmp_0: LREAL;
	p_tmp_1: LREAL;
	p_tmp_2: LREAL;
	p_tmp_3: LREAL;
	p_tmp_tmp_1: LREAL;
	p_tmp_tmp_2: LREAL;
	p_tmp_tmp_3: LREAL;
	i0_mldivide: mldivide;
	i0_f: f;
	i0_fJacobian: fJacobian;
	i0_hJacobian: hJacobian;
	i0_diag: diag;
	i0_h: h;
	i0_inv: inv;
	i0_diag_j: diag_j;
	Memory2_PreviousInput: ARRAY[0..18] OF LREAL;
	Memory1_PreviousInput: ARRAY[0..360] OF LREAL;
	x0: ARRAY[0..18] OF LREAL := [-3.0, 3.0, -2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 3.0, 0.0, 0.0, 0.0, 0.0, 0.0];
	P0: ARRAY[0..360] OF LREAL := [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0];
	b: ARRAY[0..5] OF SINT := [1, 0, 0, 0, 0, 0];
	b_c: ARRAY[0..5] OF SINT := [0, 1, 0, 0, 0, 0];
	b_d: ARRAY[0..5] OF SINT := [0, 0, 1, 0, 0, 0];
	c_r: ARRAY[0..2] OF LREAL := [-1.0820240997479491, 1.536041691521612, -1.0244614487807751];
	b_a: ARRAY[0..8] OF LREAL := [-0.49716724243009747, 0.86764746505320345, 0.0035509774996006884, 0.86764051357801664, 0.49717836120759562, -0.0036900331983521608, -0.004967117124448933, 0.0012464083117572659, -0.999986887020921];
	c_a: ARRAY[0..15] OF LREAL := [0.99998740770842731, 0.0050171411889520217, -0.00011277796818366014, 0.0, -0.0050171350277709928, 0.99998741259469692, 5.4847760914265311E-5, 0.0, 0.00011305172756206975, -5.4281247960732992E-5, 0.999999992136427, 0.0, -2.7683128968927635, 3.6522207498847075, 1.2409717457248, 1.0];
	b_I: ARRAY[0..360] OF SINT := [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1];
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[

CASE ssMethodType OF
    0: 
        (* InitializeConditions for Memory: '<S1>/Memory2' *)

        FOR i := 0 TO 18 DO 
            Memory2_PreviousInput[i] := x0[i];
        END_FOR;

        (* End of InitializeConditions for Memory: '<S1>/Memory2' *)
        (* InitializeConditions for Memory: '<S1>/Memory1' *)

        FOR i := 0 TO 360 DO 
            Memory1_PreviousInput[i] := P0[i];
        END_FOR;

        (* End of InitializeConditions for Memory: '<S1>/Memory1' *)
    1: 
        (* MATLAB Function: '<S1>/VectorizeData' incorporates:
         *  BusCreator: '<S1>/BusConversion_InsertedFor_VectorizeData_at_inport_0' *)
        (* % Load Calibration data *)
        (* data = coder.load('motionlab/calib.mat'); *)
        (* calib = data.calib; *)
        (* MATLAB Function 'FB_PendelEstimator/VectorizeData': '<S3>:1' *)
        (* Get body velocites *)
        (* '<S3>:1:8' eta = feedback.em8000.eta; *)
        (* '<S3>:1:9' eta_t = feedback.em8000.eta_t; *)
        (* '<S3>:1:10' eta_tt = feedback.em8000.eta_tt; *)
        (* '<S3>:1:12' q = feedback.comau.q; *)
        (* '<S3>:1:13' q_t = feedback.comau.q_t; *)
        (* '<S3>:1:14' q_tt = zeros(3,1); *)
        (* '<S3>:1:16' [p, p_t, p_tt] = motionlab.comau.forward(q, q_t, q_tt); *)
        (* Static link lengths *)
        (* 'forward:4' a1 = 0.350; *)
        (* 'forward:5' a2 = 1.160; *)
        (* 'forward:6' a3 = 0.250; *)
        (* 'forward:7' d1 = 0.830; *)
        (* 'forward:8' d4 = 1.4922; *)
        (* 'forward:9' d6 = 0.210; *)
        (* To wire exit point *)
        (* 'forward:12' dt = 0.567; *)
        (* To WRE from joint 2 *)
        (* 'forward:15' L = d4 + d6 + dt; *)
        (* Position {b} -> {t} *)
        (* 'forward:18' q1 = q(1); *)
        (* 'forward:19' q2 = q(2); *)
        (* 'forward:20' q3 = q(3); *)
        (* 'forward:22' q1_t = q_t(1); *)
        (* 'forward:23' q2_t = q_t(2); *)
        (* 'forward:24' q3_t = q_t(3); *)
        (* Obtained from formForwardModel *)
        (* 'forward:27' p = [ *)
        (* 'forward:28'     cos(q1)*(a1 - L*sin(q3) - a3*cos(q3) + a2*sin(q2)); *)
        (* 'forward:29'     -sin(q1)*(a1 - L*sin(q3) - a3*cos(q3) + a2*sin(q2)); *)
        (* 'forward:30'     d1 + L*cos(q3) + a2*cos(q2) - a3*sin(q3); *)
        (* 'forward:31' ]; *)
        p_tmp_tmp := COS(stFeedback.comau.q[2]);
        p_tmp_tmp_0 := SIN(stFeedback.comau.q[2]);
        p_tmp_tmp_2 := SIN(stFeedback.comau.q[1]);
        p_tmp_tmp_3 := 0.25 * p_tmp_tmp;
        p_tmp := ((0.35 - (2.2691999999999997 * p_tmp_tmp_0)) - p_tmp_tmp_3) + (1.16 * p_tmp_tmp_2);
        p_tmp_1 := COS(stFeedback.comau.q[0]);
        b_p[0] := p_tmp * p_tmp_1;
        p_tmp_tmp_1 := SIN(stFeedback.comau.q[0]);
        p_tmp_0 := p_tmp * ( -p_tmp_tmp_1);
        b_p[1] := p_tmp_0;
        p_tmp_2 := COS(stFeedback.comau.q[1]);
        p_tmp_tmp := 2.2691999999999997 * p_tmp_tmp;
        p_tmp_3 := 0.25 * p_tmp_tmp_0;
        b_p[2] := ((p_tmp_tmp + 0.83) + (1.16 * p_tmp_2)) - p_tmp_3;
        (* 'forward:33' J = [ *)
        (* 'forward:34'     -sin(q1)*(a1 - L*sin(q3) - a3*cos(q3) + a2*sin(q2)),  a2*cos(q1)*cos(q2), -cos(q1)*(L*cos(q3) - a3*sin(q3)); *)
        (* 'forward:35'     -cos(q1)*(a1 - L*sin(q3) - a3*cos(q3) + a2*sin(q2)), -a2*cos(q2)*sin(q1),  sin(q1)*(L*cos(q3) - a3*sin(q3)); *)
        (* 'forward:36'                                                       0,         -a2*sin(q2),          - L*sin(q3) - a3*cos(q3); *)
        (* 'forward:37' ]; *)
        (* 'forward:39' J_t = [ *)
        (* 'forward:40'     q3_t*sin(q1)*(L*cos(q3) - a3*sin(q3)) - q1_t*cos(q1)*(a1 - L*sin(q3) - a3*cos(q3) + a2*sin(q2)) - a2*q2_t*cos(q2)*sin(q1), - a2*q1_t*cos(q2)*sin(q1) - a2*q2_t*cos(q1)*sin(q2), q3_t*cos(q1)*(L*sin(q3) + a3*cos(q3)) + q1_t*sin(q1)*(L*cos(q3) - a3*sin(q3)); *)
        (* 'forward:41'     q3_t*cos(q1)*(L*cos(q3) - a3*sin(q3)) + q1_t*sin(q1)*(a1 - L*sin(q3) - a3*cos(q3) + a2*sin(q2)) - a2*q2_t*cos(q1)*cos(q2),   a2*q2_t*sin(q1)*sin(q2) - a2*q1_t*cos(q1)*cos(q2), q1_t*cos(q1)*(L*cos(q3) - a3*sin(q3)) - q3_t*sin(q1)*(L*sin(q3) + a3*cos(q3)); *)
        (* 'forward:42'                                                                                                                             0,                                    -a2*q2_t*cos(q2),                                                -q3_t*(L*cos(q3) - a3*sin(q3)); *)
        (* 'forward:43' ]; *)
        (* Velocity *)
        (* 'forward:46' p_t = J*q_t; *)
        (* Acceleration *)
        (* 'forward:49' p_tt = J_t*q_t + J*q_tt; *)
        (* '<S3>:1:18' [v, v_t] = math3d.eulerToBody(eta, eta_t, eta_tt, 'xyz'); *)
        (* Velocity *)
        (* 'eulerToBody:4' J = velocityJacobian(eta, angleSequence); *)
        (* 'eulerToBody:15' phi = eta(4); *)
        (* 'eulerToBody:16' theta = eta(5); *)
        (* 'eulerToBody:17' psi = eta(6); *)
        (* 'eulerToBody:19' if strcmp(sequence, 'xyz') *)
        (* 'eulerToBody:20' J = [ *)
        (* 'eulerToBody:21'             1, 0, 0,                                 0,                                0, 0 *)
        (* 'eulerToBody:22'             0, 1, 0,                                 0,                                0, 0 *)
        (* 'eulerToBody:23'             0, 0, 1,                                 0,                                0, 0 *)
        (* 'eulerToBody:24'             0, 0, 0,               cos(psi)/cos(theta),             -sin(psi)/cos(theta), 0 *)
        (* 'eulerToBody:25'             0, 0, 0,                          sin(psi),                         cos(psi), 0 *)
        (* 'eulerToBody:26'             0, 0, 0, -(cos(psi)*sin(theta))/cos(theta), (sin(psi)*sin(theta))/cos(theta), 1 *)
        (* 'eulerToBody:27'         ]; *)
        b_J[3] := 0.0;
        b_J[9] := 0.0;
        b_J[15] := 0.0;
        b_J_tmp := COS(stFeedback.em8000.eta[4]);
        b_J_tmp_1 := COS(stFeedback.em8000.eta[5]);
        b_J[21] := b_J_tmp_1 / b_J_tmp;
        b_J_tmp_0 := SIN(stFeedback.em8000.eta[5]);
        b_J[27] := ( -b_J_tmp_0) / b_J_tmp;
        b_J[33] := 0.0;
        b_J[4] := 0.0;
        b_J[10] := 0.0;
        b_J[16] := 0.0;
        b_J[22] := b_J_tmp_0;
        b_J[28] := b_J_tmp_1;
        b_J[34] := 0.0;
        b_J[5] := 0.0;
        b_J[11] := 0.0;
        b_J[17] := 0.0;
        b_J_tmp_2 := SIN(stFeedback.em8000.eta[4]);
        b_J_tmp_3 := b_J_tmp_1 * b_J_tmp_2;
        b_J[23] := ( -b_J_tmp_3) / b_J_tmp;
        b_J[29] := (b_J_tmp_0 * b_J_tmp_2) / b_J_tmp;
        b_J[35] := 1.0;
        (* 'eulerToBody:5' v = J\eta_t; *)
        (* MATLAB Function: '<S1>/VectorizeData' incorporates:
         *  BusCreator: '<S1>/BusConversion_InsertedFor_VectorizeData_at_inport_0' *)

        FOR i := 0 TO 5 DO 
            b_J[6 * i] := SINT_TO_LREAL(b[i]);
            b_J[1 + (6 * i)] := SINT_TO_LREAL(b_c[i]);
            b_J[2 + (6 * i)] := SINT_TO_LREAL(b_d[i]);
            b_v[i] := stFeedback.em8000.eta_t[i];
        END_FOR;

        i0_mldivide(A := b_J, B := b_v);
        (* Acceleration *)
        (* 'eulerToBody:8' J_t = accelerationJacobian(eta, eta_t, angleSequence); *)
        (* 'eulerToBody:43' phi = eta(4); *)
        (* 'eulerToBody:44' theta = eta(5); *)
        (* 'eulerToBody:45' psi = eta(6); *)
        (* 'eulerToBody:47' phi_t = eta_t(4); *)
        (* 'eulerToBody:48' theta_t = eta_t(5); *)
        (* 'eulerToBody:49' psi_t = eta_t(6); *)
        (* 'eulerToBody:51' if strcmp(sequence, 'xyz') *)
        (* 'eulerToBody:52' J_t = [ *)
        (* 'eulerToBody:53'             0, 0, 0,                                                                       0,                                                                       0, 0 *)
        (* 'eulerToBody:54'             0, 0, 0,                                                                       0,                                                                       0, 0 *)
        (* 'eulerToBody:55'             0, 0, 0,                                                                       0,                                                                       0, 0 *)
        (* 'eulerToBody:56'             0, 0, 0,  (cos(psi)*sin(theta)*theta_t - cos(theta)*sin(psi)*psi_t)/cos(theta)^2, -(cos(theta)*cos(psi)*psi_t + sin(theta)*sin(psi)*theta_t)/cos(theta)^2, 0 *)
        (* 'eulerToBody:57'             0, 0, 0,                                                          cos(psi)*psi_t,                                                         -sin(psi)*psi_t, 0 *)
        (* 'eulerToBody:58'             0, 0, 0, -(cos(psi)*theta_t - cos(theta)*sin(theta)*sin(psi)*psi_t)/cos(theta)^2,  (sin(psi)*theta_t + cos(theta)*cos(psi)*sin(theta)*psi_t)/cos(theta)^2, 0 *)
        (* 'eulerToBody:59'         ]; *)
        (* 'eulerToBody:9' v_t = J\(eta_tt - J_t*v); *)

        FOR i_0 := 0 TO 5 DO 
            tmp_2[6 * i_0] := 0.0;
            tmp_2[1 + (6 * i_0)] := 0.0;
            tmp_2[2 + (6 * i_0)] := 0.0;
        END_FOR;

        tmp_2[3] := 0.0;
        tmp_2[9] := 0.0;
        tmp_2[15] := 0.0;
        tmp_2[21] := ((b_J_tmp_3 * stFeedback.em8000.eta_t[4]) - ((b_J_tmp * b_J_tmp_0) * stFeedback.em8000.eta_t[5])) / (b_J_tmp * b_J_tmp);
        b_J_tmp_3 := b_J_tmp * b_J_tmp_1;
        tmp_2[27] := ( -((b_J_tmp_3 * stFeedback.em8000.eta_t[5]) + ((b_J_tmp_2 * b_J_tmp_0) * stFeedback.em8000.eta_t[4]))) / (b_J_tmp * b_J_tmp);
        tmp_2[33] := 0.0;
        tmp_2[4] := 0.0;
        tmp_2[10] := 0.0;
        tmp_2[16] := 0.0;
        tmp_2[22] := b_J_tmp_1 * stFeedback.em8000.eta_t[5];
        tmp_2[28] := ( -SIN(stFeedback.em8000.eta[5])) * stFeedback.em8000.eta_t[5];
        tmp_2[34] := 0.0;
        tmp_2[5] := 0.0;
        tmp_2[11] := 0.0;
        tmp_2[17] := 0.0;
        tmp_2[23] := ( -((b_J_tmp_1 * stFeedback.em8000.eta_t[4]) - (((b_J_tmp * b_J_tmp_2) * b_J_tmp_0) * stFeedback.em8000.eta_t[5]))) / (b_J_tmp * b_J_tmp);
        tmp_2[29] := (((b_J_tmp_3 * b_J_tmp_2) * stFeedback.em8000.eta_t[5]) + (b_J_tmp_0 * stFeedback.em8000.eta_t[4])) / (b_J_tmp * b_J_tmp);
        tmp_2[35] := 0.0;
        (* MATLAB Function: '<S1>/VectorizeData' incorporates:
         *  BusCreator: '<S1>/BusConversion_InsertedFor_VectorizeData_at_inport_0' *)

        FOR i_0 := 0 TO 5 DO 
            Rnb_tmp := 0.0;

            FOR i_1 := 0 TO 5 DO 
                Rnb_tmp := (tmp_2[(6 * i_1) + i_0] * b_v[i_1]) + Rnb_tmp;
            END_FOR;

            v_t[i_0] := stFeedback.em8000.eta_tt[i_0] - Rnb_tmp;
        END_FOR;

        i0_mldivide(A := b_J, B := v_t);
        (* Load Calibration data *)
        (* '<S3>:1:21' data = coder.load('motionlab/calib.mat'); *)
        (* '<S3>:1:22' calib = data.calib; *)
        (* Robot pose relative to EM8000 *)
        (* '<S3>:1:25' Hbr = calib.EM8000_TO_COMAU.H; *)
        (* Ship/stewart {b} orientation matrix relative to {n} *)
        (* '<S3>:1:28' Rnb = math3d.Rxyz(eta(4:6)); *)
        (* 'Rxyz:3' rx = phi(1); *)
        (* 'Rxyz:4' ry = phi(2); *)
        (* 'Rxyz:5' rz = phi(3); *)
        (* 'Rxyz:7' R = [ *)
        (* 'Rxyz:8'                               cos(ry)*cos(rz),                          -cos(ry)*sin(rz),          sin(ry); *)
        (* 'Rxyz:9'     cos(rx)*sin(rz) + cos(rz)*sin(rx)*sin(ry), cos(rx)*cos(rz) - sin(rx)*sin(ry)*sin(rz), -cos(ry)*sin(rx); *)
        (* 'Rxyz:10'     sin(rx)*sin(rz) - cos(rx)*cos(rz)*sin(ry), cos(rz)*sin(rx) + cos(rx)*sin(ry)*sin(rz),  cos(rx)*cos(ry) *)
        (* 'Rxyz:11' ]; *)
        Rnb[0] := b_J_tmp_3;
        Rnb[3] := ( -b_J_tmp) * b_J_tmp_0;
        Rnb[6] := b_J_tmp_2;
        b_J_tmp_3 := COS(stFeedback.em8000.eta[3]);
        Rnb_tmp := SIN(stFeedback.em8000.eta[3]);
        Rnb_tmp_0 := b_J_tmp_1 * Rnb_tmp;
        Rnb[1] := (Rnb_tmp_0 * b_J_tmp_2) + (b_J_tmp_3 * b_J_tmp_0);
        b_J_tmp_1 := b_J_tmp_3 * b_J_tmp_1;
        Rnb[4] := b_J_tmp_1 - ((Rnb_tmp * b_J_tmp_2) * b_J_tmp_0);
        Rnb[7] := ( -COS(stFeedback.em8000.eta[4])) * Rnb_tmp;
        Rnb[2] := (Rnb_tmp * b_J_tmp_0) - (b_J_tmp_1 * b_J_tmp_2);
        Rnb[5] := ((b_J_tmp_3 * b_J_tmp_2) * b_J_tmp_0) + Rnb_tmp_0;
        Rnb[8] := b_J_tmp_3 * b_J_tmp;
        (* MATLAB Function: '<S1>/Discrete EKF' incorporates:
         *  Memory: '<S1>/Memory1'
         *  Memory: '<S1>/Memory2' *)
        (* Body fixed velocity and acceleration skew matrices *)
        (* '<S3>:1:31' W = math3d.skew(v(4:6)); *)
        (* 'skew:3' vSkew = [ *)
        (* 'skew:4'        0, -v(3),  v(2); *)
        (* 'skew:5'     v(3),     0, -v(1); *)
        (* 'skew:6'    -v(2),  v(1),    0; *)
        (* 'skew:7' ]; *)
        (* '<S3>:1:32' W_t = math3d.skew(v_t(4:6)); *)
        (* 'skew:3' vSkew = [ *)
        (* 'skew:4'        0, -v(3),  v(2); *)
        (* 'skew:5'     v(3),     0, -v(1); *)
        (* 'skew:6'    -v(2),  v(1),    0; *)
        (* 'skew:7' ]; *)
        (* '<S3>:1:34' Rnb_t = Rnb*W; *)
        (* '<S3>:1:35' Rnb_tt = Rnb*W*W + Rnb*W_t; *)
        (* Constant offsets {b} -> {r} *)
        (* '<S3>:1:38' r = Hbr(1:3,4); *)
        (* '<S3>:1:39' Rbr = Hbr(1:3,1:3); *)
        (* Position of {t}/{n} given in {n} *)
        (* '<S3>:1:42' pt = eta(1:3) + Rnb*(r + Rbr*p); *)
        (* Velocity of {t}/{n} given in {n} *)
        (* '<S3>:1:45' pt_t = v(1:3) + Rnb_t*(r + Rbr*p) + Rnb*(Rbr*p_t); *)
        (* Acceleration of {t}/{n} given in {n} *)
        (* '<S3>:1:48' pt_tt = v_t(1:3) + Rnb_tt*(r + Rbr*p)... *)
        (* '<S3>:1:49'     + 2*Rnb_t*(Rbr*p_t) + Rnb*(Rbr*p_tt); *)
        (* Hook measurement *)
        (* '<S3>:1:52' ph = feedback.qtm.pos; *)
        (* '<S3>:1:53' Hnq = math3d.InvH(calib.WORLD_TO_EM8000.H)*calib.WORLD_TO_QTM.H; *)
        (* '<S3>:1:54' Ph = Hnq*[ph; 1]; *)
        (* '<S3>:1:56' u = [ *)
        (* '<S3>:1:57'     pt_tt *)
        (* '<S3>:1:58' ]; *)
        (* '<S3>:1:60' z = [     *)
        (* '<S3>:1:61'     pt *)
        (* '<S3>:1:62'     pt_t *)
        (* '<S3>:1:63'     feedback.winch.length *)
        (* '<S3>:1:64'     feedback.winch.length_t *)
        (* '<S3>:1:65'     Ph(1:3) *)
        (* '<S3>:1:66' ]; *)
        (* Make Q and R *)
        (* MATLAB Function 'FB_PendelEstimator/Discrete EKF': '<S2>:1' *)
        (* '<S2>:1:4' Q = diag(diagQ); *)
        (* '<S2>:1:5' R = diag(diagR); *)
        (* Prediction *)
        (* '<S2>:1:8' xPred = observer.f(x, u, Ts); *)
        i0_f(in1 := Memory2_PreviousInput, Ts := Ts);
        xPred := i0_f.f_0;
        (* '<S2>:1:9' F = observer.fJacobian(x, u, Ts); *)
        i0_fJacobian(in1 := Memory2_PreviousInput, Ts := Ts);
        b_F := i0_fJacobian.F;
        (* '<S2>:1:10' PPred = F*P*F' + Q; *)
        i0_diag(v := diagQ);
        tmp_1 := i0_diag.b_d;

        FOR i_0 := 0 TO 18 DO 

            FOR i_1 := 0 TO 18 DO 
                F_tmp := i_0 + (19 * i_1);
                F_0[F_tmp] := 0.0;

                FOR i := 0 TO 18 DO 
                    F_0[F_tmp] := (b_F[(19 * i) + i_0] * Memory1_PreviousInput[(19 * i_1) + i]) + F_0[(19 * i_1) + i_0];
                END_FOR;

            END_FOR;


            FOR i_1 := 0 TO 18 DO 
                b_J_tmp_3 := 0.0;

                FOR i := 0 TO 18 DO 
                    b_J_tmp_3 := (F_0[(19 * i) + i_0] * b_F[(19 * i) + i_1]) + b_J_tmp_3;
                END_FOR;

                PPred[i_0 + (19 * i_1)] := tmp_1[(19 * i_1) + i_0] + b_J_tmp_3;
            END_FOR;

        END_FOR;

        (* Measurement update *)
        (* '<S2>:1:13' y = z - observer.h(xPred); *)
        (* '<S2>:1:15' H = observer.hJacobian(xPred); *)
        i0_hJacobian(in1 := xPred);
        b_H := i0_hJacobian.H;
        (* '<S2>:1:16' S = H*PPred*H' + R; *)
        (* '<S2>:1:18' K = PPred*H'*inv(S); *)
        i0_diag_j(v := diagR);
        tmp_0 := i0_diag_j.b_d;

        FOR i_0 := 0 TO 10 DO 

            FOR i_1 := 0 TO 18 DO 
                F_tmp := i_0 + (11 * i_1);
                H_1[F_tmp] := 0.0;

                FOR i := 0 TO 18 DO 
                    H_1[F_tmp] := (b_H[(11 * i) + i_0] * PPred[(19 * i_1) + i]) + H_1[(11 * i_1) + i_0];
                END_FOR;

            END_FOR;


            FOR i_1 := 0 TO 10 DO 
                b_J_tmp_3 := 0.0;

                FOR i := 0 TO 18 DO 
                    b_J_tmp_3 := (H_1[(11 * i) + i_0] * b_H[(11 * i) + i_1]) + b_J_tmp_3;
                END_FOR;

                H_0[i_0 + (11 * i_1)] := tmp_0[(11 * i_1) + i_0] + b_J_tmp_3;
            END_FOR;

        END_FOR;

        i0_inv(x := H_0);
        tmp_0 := i0_inv.y;

        FOR i_0 := 0 TO 18 DO 

            FOR i_1 := 0 TO 10 DO 
                F_tmp := i_0 + (19 * i_1);
                H_1[F_tmp] := 0.0;

                FOR i := 0 TO 18 DO 
                    H_1[F_tmp] := (PPred[(19 * i) + i_0] * b_H[(11 * i) + i_1]) + H_1[(19 * i_1) + i_0];
                END_FOR;

            END_FOR;


            FOR i_1 := 0 TO 10 DO 
                F_tmp := i_0 + (19 * i_1);
                K[F_tmp] := 0.0;

                FOR i := 0 TO 10 DO 
                    K[F_tmp] := (H_1[(19 * i) + i_0] * tmp_0[(11 * i_1) + i]) + K[(19 * i_1) + i_0];
                END_FOR;

            END_FOR;

        END_FOR;

        (* '<S2>:1:21' x = xPred + K*y; *)
        i0_h(in1 := xPred);
        tmp := i0_h.h_0;
        (* MATLAB Function: '<S1>/VectorizeData' incorporates:
         *  BusCreator: '<S1>/BusConversion_InsertedFor_VectorizeData_at_inport_0'
         *  MATLAB Function: '<S1>/Discrete EKF' *)
        tmp_3[0] := 0.0;
        tmp_3[3] :=  -b_v[5];
        tmp_3[6] := b_v[4];
        tmp_3[1] := b_v[5];
        tmp_3[4] := 0.0;
        tmp_3[7] :=  -b_v[3];
        tmp_3[2] :=  -b_v[4];
        tmp_3[5] := b_v[3];
        tmp_3[8] := 0.0;
        tmp_4[0] := p_tmp_0;
        tmp_4[3] := (1.16 * p_tmp_1) * p_tmp_2;
        b_J_tmp_3 := p_tmp_tmp - p_tmp_3;
        tmp_4[6] := b_J_tmp_3 * ( -p_tmp_1);
        tmp_4[1] := p_tmp * ( -COS(stFeedback.comau.q[0]));
        tmp_4[4] := (-1.16 * p_tmp_2) * p_tmp_tmp_1;
        tmp_4[7] := b_J_tmp_3 * p_tmp_tmp_1;
        tmp_4[2] := 0.0;
        tmp_4[5] := -1.16 * p_tmp_tmp_2;
        tmp_4[8] := (-2.2691999999999997 * p_tmp_tmp_0) - p_tmp_tmp_3;

        FOR i_0 := 0 TO 2 DO 
            b_J_tmp_3 := 0.0;

            FOR i_1 := 0 TO 2 DO 
                i := (3 * i_1) + i_0;
                b_J_tmp_3 := (b_a[i] * b_p[i_1]) + b_J_tmp_3;
                F_tmp := i_0 + (3 * i_1);
                Rnb_0[F_tmp] := 0.0;
                Rnb_0[F_tmp] := Rnb_0[i] + (tmp_3[3 * i_1] * Rnb[i_0]);
                Rnb_0[F_tmp] := (tmp_3[(3 * i_1) + 1] * Rnb[i_0 + 3]) + Rnb_0[(3 * i_1) + i_0];
                Rnb_0[F_tmp] := (tmp_3[(3 * i_1) + 2] * Rnb[i_0 + 6]) + Rnb_0[(3 * i_1) + i_0];
            END_FOR;

            b_r[i_0] := c_r[i_0] + b_J_tmp_3;
            r_0[i_0] := (((b_a[i_0 + 3] * p_tmp_0) + (b_a[i_0] * b_p[0])) + (b_a[i_0 + 6] * b_p[2])) + c_r[i_0];
            tmp_5[i_0] := (tmp_4[i_0 + 6] * stFeedback.comau.q_t[2]) + ((tmp_4[i_0 + 3] * stFeedback.comau.q_t[1]) + (tmp_4[i_0] * stFeedback.comau.q_t[0]));
        END_FOR;


        FOR i_0 := 0 TO 2 DO 
            v_0[i_0] := (((Rnb_0[i_0 + 3] * r_0[1]) + (Rnb_0[i_0] * r_0[0])) + (Rnb_0[i_0 + 6] * r_0[2])) + b_v[i_0];
            b_p[i_0] := (b_a[i_0 + 6] * tmp_5[2]) + ((b_a[i_0 + 3] * tmp_5[1]) + (b_a[i_0] * tmp_5[0]));
        END_FOR;


        FOR i_0 := 0 TO 2 DO 
            stFeedback_0[i_0] := stFeedback.qtm.pos[i_0];
            r_0[i_0] := (Rnb[i_0 + 6] * b_p[2]) + ((Rnb[i_0 + 3] * b_p[1]) + (Rnb[i_0] * b_p[0]));
        END_FOR;


        FOR i_0 := 0 TO 3 DO 
            p_tmp_tmp_0 := c_a[i_0 + 12] + ((c_a[i_0 + 8] * stFeedback_0[2]) + ((c_a[i_0 + 4] * stFeedback_0[1]) + (c_a[i_0] * stFeedback_0[0])));
            a[i_0] := p_tmp_tmp_0;
        END_FOR;

        stFeedback_1[6] := stFeedback.winch.length;
        stFeedback_1[7] := stFeedback.winch.length_t;

        FOR i_0 := 0 TO 2 DO 
            stFeedback_1[i_0] := (((Rnb[i_0 + 3] * b_r[1]) + (Rnb[i_0] * b_r[0])) + (Rnb[i_0 + 6] * b_r[2])) + stFeedback.em8000.eta[i_0];
            stFeedback_1[i_0 + 3] := v_0[i_0] + r_0[i_0];
            stFeedback_1[i_0 + 8] := a[i_0];
        END_FOR;

        (* MATLAB Function: '<S1>/Discrete EKF' *)

        FOR i_0 := 0 TO 10 DO 
            stFeedback_2[i_0] := stFeedback_1[i_0] - tmp[i_0];
        END_FOR;

        (* MATLAB Function: '<S1>/Discrete EKF' *)

        FOR i_0 := 0 TO 18 DO 
            b_J_tmp_3 := 0.0;

            FOR i_1 := 0 TO 10 DO 
                b_J_tmp_3 := (K[(19 * i_1) + i_0] * stFeedback_2[i_1]) + b_J_tmp_3;
            END_FOR;

            xEst[i_0] := xPred[i_0] + b_J_tmp_3;
        END_FOR;

        (* Outport: '<Root>/pt' incorporates:
         *  MATLAB Function: '<S1>/Discrete EKF' *)
        (* '<S2>:1:22' I = eye(length(x)); *)
        (* '<S2>:1:23' P = (I - K*H)*PPred; *)
        (* Convert from x -> variables *)
        (* '<S2>:1:26' pt = x(1:3); *)
        (* '<S2>:1:27' pt_t = x(4:6); *)
        (* '<S2>:1:28' pt_tt = x(7:9); *)
        (* '<S2>:1:29' phi = x(10:11); *)
        (* '<S2>:1:30' phi_t = x(12:13); *)
        (* '<S2>:1:31' l = x(14); *)
        (* '<S2>:1:32' l_t = x(15); *)
        (* '<S2>:1:33' e = x(16:18); *)
        (* '<S2>:1:34' c = x(19); *)
        pt[0] := xEst[0];
        (* Outport: '<Root>/pt_t' incorporates:
         *  MATLAB Function: '<S1>/Discrete EKF' *)
        pt_t[0] := xEst[3];
        (* Outport: '<Root>/pt_tt' incorporates:
         *  MATLAB Function: '<S1>/Discrete EKF' *)
        pt_tt[0] := xEst[6];
        (* Outport: '<Root>/pt' incorporates:
         *  MATLAB Function: '<S1>/Discrete EKF' *)
        pt[1] := xEst[1];
        (* Outport: '<Root>/pt_t' incorporates:
         *  MATLAB Function: '<S1>/Discrete EKF' *)
        pt_t[1] := xEst[4];
        (* Outport: '<Root>/pt_tt' incorporates:
         *  MATLAB Function: '<S1>/Discrete EKF' *)
        pt_tt[1] := xEst[7];
        (* Outport: '<Root>/pt' incorporates:
         *  MATLAB Function: '<S1>/Discrete EKF' *)
        pt[2] := xEst[2];
        (* Outport: '<Root>/pt_t' incorporates:
         *  MATLAB Function: '<S1>/Discrete EKF' *)
        pt_t[2] := xEst[5];
        (* Outport: '<Root>/pt_tt' incorporates:
         *  MATLAB Function: '<S1>/Discrete EKF' *)
        pt_tt[2] := xEst[8];
        (* Outport: '<Root>/phi' incorporates:
         *  MATLAB Function: '<S1>/Discrete EKF' *)
        phi[0] := xEst[9];
        (* Outport: '<Root>/phi_t' incorporates:
         *  MATLAB Function: '<S1>/Discrete EKF' *)
        phi_t[0] := xEst[11];
        (* Outport: '<Root>/phi' incorporates:
         *  MATLAB Function: '<S1>/Discrete EKF' *)
        phi[1] := xEst[10];
        (* Outport: '<Root>/phi_t' incorporates:
         *  MATLAB Function: '<S1>/Discrete EKF' *)
        phi_t[1] := xEst[12];
        (* Outport: '<Root>/length' incorporates:
         *  MATLAB Function: '<S1>/Discrete EKF' *)
        length := xEst[13];
        (* Outport: '<Root>/length_t' incorporates:
         *  MATLAB Function: '<S1>/Discrete EKF' *)
        length_t := xEst[14];
        (* Outport: '<Root>/e' incorporates:
         *  MATLAB Function: '<S1>/Discrete EKF' *)
        e[0] := xEst[15];
        e[1] := xEst[16];
        e[2] := xEst[17];
        (* Outport: '<Root>/c' incorporates:
         *  MATLAB Function: '<S1>/Discrete EKF' *)
        c := xEst[18];
        (* MATLAB Function: '<S1>/Discrete EKF' *)

        FOR i := 0 TO 18 DO 
            (* Update for Memory: '<S1>/Memory2' *)
            Memory2_PreviousInput[i] := xEst[i];
            (* MATLAB Function: '<S1>/Discrete EKF' *)

            FOR i_0 := 0 TO 18 DO 
                b_J_tmp_3 := 0.0;

                FOR i_1 := 0 TO 10 DO 
                    b_J_tmp_3 := (K[(19 * i_1) + i] * b_H[(11 * i_0) + i_1]) + b_J_tmp_3;
                END_FOR;

                b_F[i + (19 * i_0)] := SINT_TO_LREAL(b_I[(19 * i_0) + i]) - b_J_tmp_3;
            END_FOR;

            (* Update for Memory: '<S1>/Memory1' incorporates:
             *  MATLAB Function: '<S1>/Discrete EKF' *)

            FOR i_0 := 0 TO 18 DO 
                (* MATLAB Function: '<S1>/Discrete EKF' *)
                F_tmp := i + (19 * i_0);
                Memory1_PreviousInput[F_tmp] := 0.0;

                FOR i_1 := 0 TO 18 DO 
                    Memory1_PreviousInput[F_tmp] := (b_F[(19 * i_1) + i] * PPred[(19 * i_0) + i_1]) + Memory1_PreviousInput[(19 * i_0) + i];
                END_FOR;

            END_FOR;

            (* End of Update for Memory: '<S1>/Memory1' *)
        END_FOR;

END_CASE;

]]></ST>
    </Implementation>
    <LineIds Name="FB_PendelEstimator">
      <LineId Id="3" Count="555" />
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>